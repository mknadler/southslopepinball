"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@urql+exchange-graphcache@6.5.1_graphql@16.8.1";
exports.ids = ["vendor-chunks/@urql+exchange-graphcache@6.5.1_graphql@16.8.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@urql+exchange-graphcache@6.5.1_graphql@16.8.1/node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@urql+exchange-graphcache@6.5.1_graphql@16.8.1/node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Store: () => (/* binding */ Store),\n/* harmony export */   cacheExchange: () => (/* binding */ cacheExchange),\n/* harmony export */   offlineExchange: () => (/* binding */ offlineExchange)\n/* harmony export */ });\n/* harmony import */ var _urql_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @urql/core */ \"(ssr)/./node_modules/.pnpm/@urql+core@4.3.0_graphql@16.8.1/node_modules/@urql/core/dist/urql-core-chunk.mjs\");\n/* harmony import */ var _urql_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @urql/core */ \"(ssr)/./node_modules/.pnpm/@urql+core@4.3.0_graphql@16.8.1/node_modules/@urql/core/dist/urql-core.mjs\");\n/* harmony import */ var _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @0no-co/graphql.web */ \"(ssr)/./node_modules/.pnpm/@0no-co+graphql.web@1.0.7_graphql@16.8.1/node_modules/@0no-co/graphql.web/dist/graphql.web.mjs\");\n/* harmony import */ var wonka__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wonka */ \"(ssr)/./node_modules/.pnpm/wonka@6.3.4/node_modules/wonka/dist/wonka.mjs\");\n\n\n\n\n\n\nvar h = \"\\nhttps://bit.ly/2XbVrpR#\";\n\nvar m = new Set;\n\nvar g = [];\n\nvar popDebugNode = () => g.pop();\n\nvar pushDebugNode = (e, r) => {\n  var t = \"\";\n  if (r.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.INLINE_FRAGMENT) {\n    t = e ? `Inline Fragment on \"${e}\"` : \"Inline Fragment\";\n  } else if (r.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n    t = `${r.name ? `\"${r.name.value}\"` : \"Unnamed\"} ${r.operation}`;\n  } else if (r.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_DEFINITION) {\n    t = `\"${r.name.value}\" Fragment`;\n  }\n  if (t) {\n    g.push(t);\n  }\n};\n\nvar getDebugOutput = () => g.length ? \"\\n(Caused At: \" + g.join(\", \") + \")\" : \"\";\n\nfunction invariant(e, r, t) {\n  if (!e) {\n    var a = r || \"Minfied Error #\" + t + \"\\n\";\n    if (true) {\n      a += getDebugOutput();\n    }\n    var i = new Error(a + h + t);\n    i.name = \"Graphcache Error\";\n    throw i;\n  }\n}\n\nfunction warn(e, r, t) {\n  if (!m.has(e)) {\n    if (t) {\n      t(\"warn\", e + getDebugOutput() + h + r);\n    } else {\n      console.warn(e + getDebugOutput() + h + r);\n    }\n    m.add(e);\n  }\n}\n\nvar _ = {};\n\nvar getDirectives = e => e._directives || _;\n\nvar getName = e => e.name.value;\n\nvar getFragmentTypeName = e => e.typeCondition.name.value;\n\nvar getFieldAlias = e => e.alias ? e.alias.value : e.name.value;\n\nvar N = [];\n\nvar getSelectionSet = e => e.selectionSet ? e.selectionSet.selections : N;\n\nvar getTypeCondition = e => e.typeCondition ? e.typeCondition.name.value : null;\n\nvar getFieldArguments = (e, r) => {\n  var t = null;\n  if (e.arguments) {\n    for (var a = 0, i = e.arguments.length; a < i; a++) {\n      var n = e.arguments[a];\n      var s = (0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(n.value, r);\n      if (null != s) {\n        if (!t) {\n          t = {};\n        }\n        t[getName(n)] = s;\n      }\n    }\n  }\n  return t;\n};\n\nvar filterVariables = (e, r) => {\n  if (!r || !e.variableDefinitions) {\n    return;\n  }\n  var t = {};\n  for (var a = 0, i = e.variableDefinitions.length; a < i; a++) {\n    var n = getName(e.variableDefinitions[a].variable);\n    t[n] = r[n];\n  }\n  return t;\n};\n\nvar normalizeVariables = (e, r) => {\n  var t = {};\n  if (!r) {\n    return t;\n  }\n  if (e.variableDefinitions) {\n    for (var a = 0, i = e.variableDefinitions.length; a < i; a++) {\n      var n = e.variableDefinitions[a];\n      var s = getName(n.variable);\n      t[s] = void 0 === r[s] && n.defaultValue ? (0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(n.defaultValue, r) : r[s];\n    }\n  }\n  for (var l in r) {\n    if (!(l in t)) {\n      t[l] = r[l];\n    }\n  }\n  return t;\n};\n\nfunction getMainOperation(e) {\n  for (var r = 0; r < e.definitions.length; r++) {\n    if (e.definitions[r].kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n      return e.definitions[r];\n    }\n  }\n  invariant(!1,  true ? \"Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation.\" : 0, 1);\n}\n\nvar getFragments = e => {\n  var r = {};\n  for (var t = 0; t < e.definitions.length; t++) {\n    var a = e.definitions[t];\n    if (a.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_DEFINITION) {\n      r[getName(a)] = a;\n    }\n  }\n  return r;\n};\n\nvar shouldInclude = (e, r) => {\n  var t = getDirectives(e);\n  if (t.include || t.skip) {\n    for (var a in t) {\n      var i = t[a];\n      if (i && (\"include\" === a || \"skip\" === a) && i.arguments && i.arguments[0] && \"if\" === getName(i.arguments[0])) {\n        var n = (0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(i.arguments[0].value, r);\n        return \"include\" === a ? !!n : !n;\n      }\n    }\n  }\n  return !0;\n};\n\nvar isDeferred = (e, r) => {\n  var {defer: t} = getDirectives(e);\n  if (t) {\n    for (var a of t.arguments || []) {\n      if (\"if\" === getName(a)) {\n        return !!(0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(a.value, r);\n      }\n    }\n    return !0;\n  }\n  return !1;\n};\n\nvar isOptional = e => {\n  var {optional: r, required: t} = getDirectives(e);\n  if (t) {\n    return !1;\n  }\n  if (r) {\n    return !0;\n  }\n  return;\n};\n\nvar k = \"__\";\n\nvar isFieldNullable = (e, r, t, a) => {\n  var i = getField(e, r, t, a);\n  return !!i && \"NON_NULL\" !== i.type.kind;\n};\n\nvar isListNullable = (e, r, t, a) => {\n  var i = getField(e, r, t, a);\n  if (!i) {\n    return !1;\n  }\n  var n = \"NON_NULL\" === i.type.kind ? i.type.ofType : i.type;\n  return \"LIST\" === n.kind && \"NON_NULL\" !== n.ofType.kind;\n};\n\nvar isFieldAvailableOnType = (e, r, t, a) => 0 === t.indexOf(k) || 0 === r.indexOf(k) || !!getField(e, r, t, a);\n\nvar isInterfaceOfType = (e, r, t) => {\n  if (!t) {\n    return !1;\n  }\n  var a = getTypeCondition(r);\n  if (!a || t === a) {\n    return !0;\n  } else if (e.types.has(a) && \"OBJECT\" === e.types.get(a).kind) {\n    return a === t;\n  }\n  !function expectAbstractType(e, r) {\n    invariant(e.types.has(r) && (\"INTERFACE\" === e.types.get(r).kind || \"UNION\" === e.types.get(r).kind),  true ? \"Invalid Abstract type: The type `\" + r + \"` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition.\" : 0, 5);\n  }(e, a);\n  expectObjectType(e, t);\n  return e.isSubType(a, t);\n};\n\nvar getField = (e, r, t, a) => {\n  if (0 === t.indexOf(k) || 0 === r.indexOf(k)) {\n    return;\n  }\n  expectObjectType(e, r);\n  var i = e.types.get(r).fields()[t];\n  if (true) {\n    if (!i) {\n      warn(\"Invalid field: The field `\" + t + \"` does not exist on `\" + r + \"`, but the GraphQL document expects it to exist.\\nTraversal will continue, however this may lead to undefined behavior!\", 4, a);\n    }\n  }\n  return i;\n};\n\nfunction expectObjectType(e, r) {\n  invariant(e.types.has(r) && \"OBJECT\" === e.types.get(r).kind,  true ? \"Invalid Object type: The type `\" + r + \"` is not an object in the defined schema, but the GraphQL document is traversing it.\" : 0, 3);\n}\n\nfunction warnAboutResolver(e, r) {\n   true && warn(`Invalid resolver: \\`${e}\\` is not in the defined schema, but the \\`resolvers\\` option is referencing it.`, 23, r);\n}\n\nfunction warnAboutAbstractResolver(e, r, t) {\n   true && warn(`Invalid resolver: \\`${e}\\` does not match to a concrete type in the schema, but the \\`resolvers\\` option is referencing it. Implement the resolver for the types that ${\"UNION\" === r ? \"make up the union\" : \"implement the interface\"} instead.`, 26, t);\n}\n\nvar keyOfField = (r, t) => t ? `${r}(${(0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.i)(t)})` : r;\n\nvar joinKeys = (e, r) => `${e}.${r}`;\n\nvar fieldInfoOfKey = e => {\n  var r = e.indexOf(\"(\");\n  if (r > -1) {\n    return {\n      fieldKey: e,\n      fieldName: e.slice(0, r),\n      arguments: JSON.parse(e.slice(r + 1, -1))\n    };\n  } else {\n    return {\n      fieldKey: e,\n      fieldName: e,\n      arguments: null\n    };\n  }\n};\n\nvar deserializeKeyInfo = e => {\n  var r = e.indexOf(\".\");\n  return {\n    entityKey: e.slice(0, r).replace(/%2e/g, \".\"),\n    fieldKey: e.slice(r + 1)\n  };\n};\n\nvar E = null;\n\nvar O = null;\n\nvar w = null;\n\nvar b = null;\n\nvar D = null;\n\nvar x = null;\n\nvar V = !1;\n\nvar I = !1;\n\nfunction makeData(e, r) {\n  var t;\n  if (e) {\n    if (E.has(e)) {\n      return e;\n    }\n    t = O.get(e);\n  }\n  if (null == t) {\n    t = r ? [] : {};\n  }\n  if (e) {\n    O.set(e, t);\n  }\n  E.add(t);\n  return t;\n}\n\nvar ownsData = e => !!e && E.has(e);\n\nvar initDataState = (e, r, t, a, i) => {\n  E = new WeakSet;\n  O = new WeakMap;\n  D = e;\n  w = r;\n  x = new Set;\n  I = !!a;\n  V = !!i;\n  if (true) {\n    g.length = 0;\n  }\n  if (!t) {\n    b = null;\n  } else if (\"read\" === D) {\n    b = t;\n  } else if (a || r.hydrating || r.optimisticOrder.length > 1) {\n    if (!a && !r.commutativeKeys.has(t)) {\n      reserveLayer(r, t);\n    } else if (a) {\n      if (-1 !== r.optimisticOrder.indexOf(t) && !r.commutativeKeys.has(t)) {\n        r.optimisticOrder.splice(r.optimisticOrder.indexOf(t), 1);\n      }\n      r.commutativeKeys.delete(t);\n    }\n    b = t;\n    createLayer(r, t);\n  } else {\n    b = null;\n    deleteLayer(r, t);\n  }\n};\n\nvar clearDataState = () => {\n  if (true) {\n    getCurrentDependencies();\n  }\n  var e = w;\n  var r = b;\n  I = !1;\n  b = null;\n  if (!e.hydrating && r && e.optimisticOrder.indexOf(r) > -1) {\n    var t = e.optimisticOrder.length;\n    while (--t >= 0 && e.dirtyKeys.has(e.optimisticOrder[t]) && e.commutativeKeys.has(e.optimisticOrder[t])) {\n      squashLayer(e.optimisticOrder[t]);\n    }\n  }\n  E = null;\n  O = null;\n  D = null;\n  w = null;\n  x = null;\n  if (true) {\n    g.length = 0;\n  }\n  if (true) {\n    if (!e.defer && (e.storage || !e.optimisticOrder.length)) {\n      e.defer = !0;\n      setTimeout((() => {\n        initDataState(\"read\", e, null);\n        gc();\n        persistData();\n        clearDataState();\n        e.defer = !1;\n      }));\n    }\n  }\n};\n\nvar noopDataState = (e, r, t) => {\n  if (r && !t) {\n    e.deferredKeys.delete(r);\n  }\n  initDataState(\"write\", e, r, t);\n  clearDataState();\n};\n\nvar getCurrentDependencies = () => {\n  invariant(null !== x,  true ? \"Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs.\" : 0, 2);\n  return x;\n};\n\nvar q = new Set;\n\nvar setNode = (e, r, t, a) => {\n  if (true) {\n    invariant(\"read\" !== D,  true ? \"Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance.\" : 0, 27);\n  }\n  var i = b ? e.optimistic.get(b) : e.base;\n  var n = i.get(r);\n  if (void 0 === n) {\n    i.set(r, n = Object.create(null));\n  }\n  if (void 0 === a && !b) {\n    delete n[t];\n  } else {\n    n[t] = a;\n  }\n};\n\nvar getNode = (e, r, t) => {\n  var a;\n  var i = !I && \"read\" === D && b && w.commutativeKeys.has(b);\n  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {\n    var s = w.optimisticOrder[n];\n    var l = e.optimistic.get(s);\n    i = i && s !== b;\n    if (l && (!i || !w.commutativeKeys.has(s)) && (!I || \"write\" === D || w.commutativeKeys.has(s)) && void 0 !== (a = l.get(r)) && t in a) {\n      return a[t];\n    }\n  }\n  return void 0 !== (a = e.base.get(r)) ? a[t] : void 0;\n};\n\nvar updateRCForLink = (e, r) => {\n  if (Array.isArray(e)) {\n    for (var t = 0, a = e.length; t < a; t++) {\n      updateRCForLink(e[t], r);\n    }\n  } else if (\"string\" == typeof e) {\n    ((e, r) => {\n      var t = w.refCount.get(e) || 0;\n      var a = t + r > 0 ? t + r : 0;\n      w.refCount.set(e, a);\n      if (!a) {\n        w.gc.add(e);\n      } else if (!t && a) {\n        w.gc.delete(e);\n      }\n    })(e, r);\n  }\n};\n\nvar extractNodeFields = (e, r, t) => {\n  if (void 0 !== t) {\n    for (var a in t) {\n      if (!r.has(a)) {\n        e.push(fieldInfoOfKey(a));\n        r.add(a);\n      }\n    }\n  }\n};\n\nvar extractNodeMapFields = (e, r, t, a) => {\n  extractNodeFields(e, r, a.base.get(t));\n  for (var i = 0, n = w.optimisticOrder.length; i < n; i++) {\n    var o = a.optimistic.get(w.optimisticOrder[i]);\n    if (void 0 !== o) {\n      extractNodeFields(e, r, o.get(t));\n    }\n  }\n};\n\nvar gc = () => {\n  if (w.optimisticOrder.length) {\n    return;\n  }\n  for (var e of w.gc.keys()) {\n    w.gc.delete(e);\n    if ((w.refCount.get(e) || 0) > 0) {\n      continue;\n    }\n    var r = w.records.base.get(e);\n    w.refCount.delete(e);\n    w.records.base.delete(e);\n    var t = r && r.__typename;\n    if (t) {\n      var a = w.types.get(t);\n      if (a) {\n        a.delete(e);\n      }\n    }\n    var i = w.links.base.get(e);\n    if (i) {\n      w.links.base.delete(e);\n      for (var n in i) {\n        updateRCForLink(i[n], -1);\n      }\n    }\n  }\n};\n\nvar updateDependencies = (e, r) => {\n  if (e !== w.queryRootKey) {\n    x.add(e);\n  } else if (void 0 !== r && \"__typename\" !== r) {\n    x.add(joinKeys(e, r));\n  }\n};\n\nvar updatePersist = (e, r) => {\n  if (!I && w.storage) {\n    w.persist.add(((e, r) => `${e.replace(/\\./g, \"%2e\")}.${r}`)(e, r));\n  }\n};\n\nvar readRecord = (e, r) => {\n  updateDependencies(e, r);\n  return getNode(w.records, e, r);\n};\n\nvar readLink = (e, r) => {\n  updateDependencies(e, r);\n  return getNode(w.links, e, r);\n};\n\nvar writeRecord = (e, r, t) => {\n  updateDependencies(e, r);\n  updatePersist(e, r);\n  setNode(w.records, e, r, t);\n};\n\nvar hasField = (e, r) => void 0 !== readRecord(e, r) || void 0 !== readLink(e, r);\n\nvar writeLink = (e, r, t) => {\n  var a = b ? w.links.optimistic.get(b) : w.links.base;\n  if (!b) {\n    var i = a && a.get(e);\n    updateRCForLink(i && i[r], -1);\n    updateRCForLink(t, 1);\n  }\n  updateDependencies(e, r);\n  updatePersist(e, r);\n  setNode(w.links, e, r, t);\n};\n\nvar reserveLayer = (e, r, t) => {\n  var a = e.optimisticOrder.indexOf(r);\n  if (a > -1) {\n    e.optimisticOrder.splice(a, 1);\n  }\n  if (t) {\n    e.deferredKeys.add(r);\n    for (a = a > -1 ? a : 0; a < e.optimisticOrder.length && !e.deferredKeys.has(e.optimisticOrder[a]) && (!e.dirtyKeys.has(e.optimisticOrder[a]) || !e.commutativeKeys.has(e.optimisticOrder[a])); a++) {}\n  } else {\n    e.deferredKeys.delete(r);\n    if (a > -1 && !e.commutativeKeys.has(r)) {\n      clearLayer(e, r);\n    }\n    a = 0;\n  }\n  e.optimisticOrder.splice(a, 0, r);\n  e.commutativeKeys.add(r);\n};\n\nvar createLayer = (e, r) => {\n  if (-1 === e.optimisticOrder.indexOf(r)) {\n    e.optimisticOrder.unshift(r);\n  }\n  if (!e.dirtyKeys.has(r)) {\n    e.dirtyKeys.add(r);\n    e.links.optimistic.set(r, new Map);\n    e.records.optimistic.set(r, new Map);\n  }\n};\n\nvar clearLayer = (e, r) => {\n  if (e.dirtyKeys.has(r)) {\n    e.dirtyKeys.delete(r);\n    e.records.optimistic.delete(r);\n    e.links.optimistic.delete(r);\n    e.deferredKeys.delete(r);\n  }\n};\n\nvar deleteLayer = (e, r) => {\n  var t = e.optimisticOrder.indexOf(r);\n  if (t > -1) {\n    e.optimisticOrder.splice(t, 1);\n    e.commutativeKeys.delete(r);\n  }\n  clearLayer(e, r);\n};\n\nvar squashLayer = e => {\n  var r = x;\n  x = new Set;\n  D = \"write\";\n  var t = w.links.optimistic.get(e);\n  if (t) {\n    for (var a of t.entries()) {\n      var i = a[0];\n      var n = a[1];\n      for (var o in n) {\n        writeLink(i, o, n[o]);\n      }\n    }\n  }\n  var s = w.records.optimistic.get(e);\n  if (s) {\n    for (var l of s.entries()) {\n      var v = l[0];\n      var d = l[1];\n      for (var u in d) {\n        writeRecord(v, u, d[u]);\n      }\n    }\n  }\n  x = r;\n  deleteLayer(w, e);\n};\n\nvar inspectFields = e => {\n  var {links: r, records: t} = w;\n  var a = [];\n  var i = new Set;\n  updateDependencies(e);\n  extractNodeMapFields(a, i, e, r);\n  extractNodeMapFields(a, i, e, t);\n  return a;\n};\n\nvar persistData = () => {\n  if (w.storage) {\n    I = !0;\n    D = \"read\";\n    var r = {};\n    for (var t of w.persist.keys()) {\n      var {entityKey: a, fieldKey: i} = deserializeKeyInfo(t);\n      var n = void 0;\n      if (void 0 !== (n = readLink(a, i))) {\n        r[t] = `:${(0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.i)(n)}`;\n      } else if (void 0 !== (n = readRecord(a, i))) {\n        r[t] = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.i)(n);\n      } else {\n        r[t] = void 0;\n      }\n    }\n    I = !1;\n    w.storage.writeData(r);\n    w.persist.clear();\n  }\n};\n\nvar S = null;\n\nvar T = !1;\n\nvar A = void 0;\n\nvar getFieldError = e => e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(\".\")] : void 0;\n\nvar makeContext = (e, r, t, a, i, n) => {\n  var o = {\n    store: e,\n    variables: r,\n    fragments: t,\n    parent: {\n      __typename: a\n    },\n    parentTypeName: a,\n    parentKey: i,\n    parentFieldKey: \"\",\n    fieldName: \"\",\n    error: void 0,\n    partial: !1,\n    hasNext: !1,\n    optimistic: I,\n    __internal: {\n      path: [],\n      errorMap: void 0\n    }\n  };\n  if (n && n.graphQLErrors) {\n    for (var s = 0; s < n.graphQLErrors.length; s++) {\n      var l = n.graphQLErrors[s];\n      if (l.path && l.path.length) {\n        if (!o.__internal.errorMap) {\n          o.__internal.errorMap = Object.create(null);\n        }\n        o.__internal.errorMap[l.path.join(\".\")] = l;\n      }\n    }\n  }\n  return o;\n};\n\nvar updateContext = (e, r, t, a, i, n) => {\n  S = e;\n  e.parent = r;\n  e.parentTypeName = t;\n  e.parentKey = a;\n  e.parentFieldKey = i;\n  e.fieldName = n;\n  e.error = getFieldError(e);\n};\n\nvar isFragmentHeuristicallyMatching = (e, r, t, a, i) => {\n  if (!r) {\n    return !1;\n  }\n  var o = getTypeCondition(e);\n  if (!o || r === o) {\n    return !0;\n  }\n   true && warn(\"Heuristic Fragment Matching: A fragment is trying to match against the `\" + r + \"` type, but the type condition is `\" + o + \"`. Since GraphQL allows for interfaces `\" + o + \"` may be an interface.\\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!\", 16, i);\n  return \"write\" === D || !getSelectionSet(e).some((e => {\n    if (e.kind !== _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.FIELD) {\n      return !1;\n    }\n    var r = keyOfField(getName(e), getFieldArguments(e, a));\n    return !hasField(t, r);\n  }));\n};\n\nfunction makeSelectionIterator(e, r, t, a, i, o) {\n  var s;\n  var l = 0;\n  return function next() {\n    var v;\n    while (s || l < i.length) {\n      v = void 0;\n      T = t;\n      A = a;\n      if (s) {\n        if (v = s()) {\n          return v;\n        } else {\n          s = void 0;\n          if (true) {\n            popDebugNode();\n          }\n        }\n      } else {\n        var d = i[l++];\n        if (!shouldInclude(d, o.variables)) {} else if (d.kind !== _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.FIELD) {\n          var u = d.kind !== _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.INLINE_FRAGMENT ? o.fragments[getName(d)] : d;\n          if (u) {\n            if (!u.typeCondition || (o.store.schema ? isInterfaceOfType(o.store.schema, u, e) : isFragmentHeuristicallyMatching(u, e, r, o.variables, o.store.logger))) {\n              if (true) {\n                pushDebugNode(e, u);\n              }\n              var c = isOptional(d);\n              s = makeSelectionIterator(e, r, t || isDeferred(d, o.variables), void 0 !== c ? c : a, getSelectionSet(u), o);\n            }\n          }\n        } else if (\"write\" === D || !d._generated) {\n          return d;\n        }\n      }\n    }\n  };\n}\n\nvar ensureData = e => null == e ? null : e;\n\nvar ensureLink = (e, r) => {\n  if (!r) {\n    return r || null;\n  } else if (Array.isArray(r)) {\n    var t = new Array(r.length);\n    for (var a = 0, i = t.length; a < i; a++) {\n      t[a] = ensureLink(e, r[a]);\n    }\n    return t;\n  }\n  var n = e.keyOfEntity(r);\n  if (true) {\n    if (!n && r && \"object\" == typeof r) {\n      warn(\"Can't generate a key for link(...) item.\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + r.__typename + \"`.\", 12, e.logger);\n    }\n  }\n  return n;\n};\n\nvar _query = (e, t, a, i) => {\n  var n = (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.formatDocument)(t.query);\n  var o = getMainOperation(n);\n  var s = e.rootFields[o.operation];\n  var l = getSelectionSet(o);\n  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), s, s, i);\n  if (true) {\n    pushDebugNode(s, o);\n  }\n  var d = s !== v.store.rootFields.query ? readRoot(v, s, l, a || makeData()) : readSelection(v, s, l, a || makeData());\n  if (true) {\n    popDebugNode();\n    getCurrentDependencies();\n  }\n  return {\n    dependencies: x,\n    partial: v.partial || !d,\n    hasNext: v.hasNext,\n    data: d || null\n  };\n};\n\nvar readRoot = (e, r, t, a) => {\n  if (\"string\" != typeof (e.store.rootNames[r] ? r : a.__typename)) {\n    return a;\n  }\n  var i = makeSelectionIterator(r, r, !1, void 0, t, e);\n  var n;\n  var o = V;\n  var s = makeData(a);\n  while (n = i()) {\n    var l = getFieldAlias(n);\n    var v = a[l];\n    e.__internal.path.push(l);\n    var d = void 0;\n    if (n.selectionSet && null !== v) {\n      d = readRootField(e, getSelectionSet(n), ensureData(v));\n    } else {\n      d = v;\n    }\n    o = o || d !== v;\n    if (void 0 !== d) {\n      s[l] = d;\n    }\n    e.__internal.path.pop();\n  }\n  return o ? s : a;\n};\n\nvar readRootField = (e, r, t) => {\n  if (Array.isArray(t)) {\n    var a = new Array(t.length);\n    var i = V;\n    for (var n = 0, o = t.length; n < o; n++) {\n      e.__internal.path.push(n);\n      a[n] = readRootField(e, r, t[n]);\n      i = i || a[n] !== t[n];\n      e.__internal.path.pop();\n    }\n    return i ? a : t;\n  } else if (null === t) {\n    return null;\n  }\n  var s = e.store.keyOfEntity(t);\n  if (null !== s) {\n    return readSelection(e, s, r, t) || null;\n  } else {\n    return readRoot(e, t.__typename, r, t);\n  }\n};\n\nfunction getFieldResolver(e, r, t, a) {\n  var i = a.store.resolvers[r];\n  var n = i && i[t];\n  var o;\n  for (var s in e) {\n    var l = e[s];\n    if (l && \"include\" !== s && \"skip\" !== s && a.store.directives[s]) {\n      o = a.store.directives[s](getFieldArguments(l, a.variables));\n      if (false) {}\n      break;\n    }\n  }\n  if (true) {\n    if (n && o) {\n      warn(`A resolver and directive is being used at \"${r}.${t}\" simultaneously. Only the directive will apply.`, 28, a.store.logger);\n    }\n  }\n  return o || n;\n}\n\nvar readSelection = (e, r, t, a, i) => {\n  var {store: n} = e;\n  var o = r === n.rootFields.query;\n  var s = i && n.keyOfEntity(i) || r;\n  if (true) {\n    if (!o && e.store.rootNames[s]) {\n      warn(\"Invalid root traversal: A selection was being read on `\" + s + \"` which is an uncached root type.\\nThe `\" + e.store.rootFields.mutation + \"` and `\" + e.store.rootFields.subscription + \"` types are special Operation Root Types and cannot be read back from the cache.\", 25, n.logger);\n    }\n  }\n  var l = !o ? readRecord(s, \"__typename\") || i && i.__typename : r;\n  if (\"string\" != typeof l) {\n    return;\n  } else if (i && l !== i.__typename) {\n     true && warn(\"Invalid resolver data: The resolver at `\" + s + \"` returned an invalid typename that could not be reconciled with the cache.\", 8, n.logger);\n    return;\n  }\n  var v = makeSelectionIterator(l, s, !1, void 0, t, e);\n  var d = !1;\n  var u = !1;\n  var c = V;\n  var p;\n  var f = e.partial;\n  var y = makeData(a);\n  while (void 0 !== (p = v())) {\n    var h = getName(p);\n    var m = getFieldArguments(p, e.variables);\n    var g = getFieldAlias(p);\n    var _ = getDirectives(p);\n    var N = getFieldResolver(_, l, h, e);\n    var k = keyOfField(h, m);\n    var E = joinKeys(s, k);\n    var O = readRecord(s, k);\n    var w = i ? i[h] : void 0;\n    if ( true && n.schema && l) {\n      isFieldAvailableOnType(n.schema, l, h, e.store.logger);\n    }\n    e.__internal.path.push(g);\n    var b = void 0;\n    if (\"__typename\" === h) {\n      b = l;\n    } else if (void 0 !== w && void 0 === p.selectionSet) {\n      b = w;\n    } else if (\"read\" === D && N) {\n      var x = y;\n      if (void 0 === p.selectionSet && void 0 !== O) {\n        x = {\n          ...y,\n          [g]: O,\n          [h]: O\n        };\n      }\n      updateContext(e, x, l, s, k, h);\n      b = N(x, m || {}, n, e);\n      if (p.selectionSet) {\n        b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], b, ownsData(a));\n      }\n      if (n.schema && null === b && !isFieldNullable(n.schema, l, h, e.store.logger)) {\n        return;\n      }\n    } else if (!p.selectionSet) {\n      b = O;\n    } else if (void 0 !== w) {\n      b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], w, ownsData(a));\n    } else {\n      var I = readLink(s, k);\n      if (void 0 !== I) {\n        b = resolveLink(e, I, l, h, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], ownsData(a));\n      } else if (\"object\" == typeof O && null !== O) {\n        b = O;\n      }\n    }\n    if (!T && void 0 === b && (_.optional || A && !_.required || getFieldError(e) || n.schema && isFieldNullable(n.schema, l, h, e.store.logger))) {\n      e.partial = !0;\n      b = null;\n    } else if (null === b && (_.required || !1 === A)) {\n      if (e.store.logger && \"production\" !== \"development\" && \"read\" === D) {\n        e.store.logger(\"debug\", `Got value \"null\" for required field \"${h}\"${m ? ` with args ${JSON.stringify(m)}` : \"\"} on entity \"${s}\"`);\n      }\n      b = void 0;\n    } else {\n      d = d || \"__typename\" !== h;\n    }\n    e.__internal.path.pop();\n    c = c || b !== a[g];\n    if (void 0 !== b) {\n      y[g] = b;\n    } else if (T) {\n      u = !0;\n    } else {\n      if (e.store.logger && \"production\" !== \"development\" && \"read\" === D) {\n        e.store.logger(\"debug\", `No value for field \"${h}\"${m ? ` with args ${JSON.stringify(m)}` : \"\"} on entity \"${s}\"`);\n      }\n      e.partial = f;\n      return;\n    }\n  }\n  e.partial = e.partial || f;\n  e.hasNext = e.hasNext || u;\n  return o && e.partial && !d ? void 0 : c ? y : a;\n};\n\nvar resolveResolverResult = (e, r, t, a, i, n, o, s) => {\n  if (Array.isArray(o)) {\n    var {store: l} = e;\n    var v = l.schema ? isListNullable(l.schema, r, t, e.store.logger) : !1;\n    var d = e.partial;\n    var u = makeData(n, !0);\n    var c = V || !Array.isArray(n) || o.length !== n.length;\n    for (var p = 0, f = o.length; p < f; p++) {\n      e.__internal.path.push(p);\n      var y = resolveResolverResult(e, r, t, joinKeys(a, `${p}`), i, null != n ? n[p] : void 0, o[p], s);\n      e.__internal.path.pop();\n      if (void 0 === y && !v) {\n        e.partial = d;\n        return;\n      } else {\n        e.partial = e.partial || void 0 === y && v;\n        u[p] = null != y ? y : null;\n        c = c || u[p] !== n[p];\n      }\n    }\n    return c ? u : n;\n  } else if (null == o) {\n    return o;\n  } else if (s && null === n) {\n    return null;\n  } else if (isDataOrKey(o)) {\n    var h = n || makeData(n);\n    return \"string\" == typeof o ? readSelection(e, o, i, h) : readSelection(e, a, i, h, o);\n  } else {\n     true && warn(\"Invalid resolver value: The field at `\" + a + \"` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.\", 9, e.store.logger);\n    return;\n  }\n};\n\nvar resolveLink = (e, r, t, a, i, n, o) => {\n  if (Array.isArray(r)) {\n    var {store: s} = e;\n    var l = s.schema ? isListNullable(s.schema, t, a, e.store.logger) : !1;\n    var v = makeData(n, !0);\n    var d = e.partial;\n    var u = V || !Array.isArray(n) || r.length !== n.length;\n    for (var c = 0, p = r.length; c < p; c++) {\n      e.__internal.path.push(c);\n      var f = resolveLink(e, r[c], t, a, i, null != n ? n[c] : void 0, o);\n      e.__internal.path.pop();\n      if (void 0 === f && !l) {\n        e.partial = d;\n        return;\n      } else {\n        e.partial = e.partial || void 0 === f && l;\n        v[c] = f || null;\n        u = u || v[c] !== n[c];\n      }\n    }\n    return u ? v : n;\n  } else if (null === r || null === n && o) {\n    return null;\n  }\n  return readSelection(e, r, i, n || makeData(n));\n};\n\nvar isDataOrKey = e => \"string\" == typeof e || \"object\" == typeof e && \"string\" == typeof e.__typename;\n\nvar _write = (e, t, a, i) => {\n  if (true) {\n    getCurrentDependencies();\n  }\n  var n = (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.formatDocument)(t.query);\n  var o = getMainOperation(n);\n  var s = {\n    data: a || makeData(),\n    dependencies: x\n  };\n  var l = e.rootFields[o.operation];\n  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), l, l, i);\n  if (true) {\n    pushDebugNode(l, o);\n  }\n  writeSelection(v, l, getSelectionSet(o), s.data);\n  if (true) {\n    popDebugNode();\n  }\n  return s;\n};\n\nvar writeSelection = (e, r, t, a) => {\n  var i = e.store.rootNames[r] || \"query\";\n  var n = !!e.store.rootNames[r];\n  var o = n ? r : a.__typename;\n  if (!o && r && e.optimistic) {\n    o = readRecord(r, \"__typename\");\n  }\n  if (!o) {\n     true && warn(\"Couldn't find __typename when writing.\\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.\", 14, e.store.logger);\n    return;\n  } else if (!n && r) {\n    writeRecord(r, \"__typename\", o);\n    ((e, r) => {\n      var t = w.types.get(e);\n      if (!t) {\n        var a = new Set;\n        a.add(r);\n        w.types.set(e, a);\n      } else {\n        t.add(r);\n      }\n    })(o, r);\n  }\n  var s = e.store.updates[o];\n  var l = makeSelectionIterator(o, r || o, !1, void 0, t, e);\n  var v;\n  while (v = l()) {\n    var d = getName(v);\n    var u = getFieldArguments(v, e.variables);\n    var c = keyOfField(d, u);\n    var p = getFieldAlias(v);\n    var f = a[e.optimistic ? d : p];\n    if (\"__typename\" === d || void 0 === f && (T || e.optimistic && \"query\" === i)) {\n      continue;\n    }\n    if (true) {\n      if (e.store.schema && o && \"__typename\" !== d) {\n        isFieldAvailableOnType(e.store.schema, o, d, e.store.logger);\n      }\n    }\n    e.__internal.path.push(p);\n    var y = void 0;\n    if (e.optimistic && \"mutation\" === i) {\n      if (!(y = e.store.optimisticMutations[d])) {\n        continue;\n      }\n    } else if (e.optimistic && \"function\" == typeof f) {\n      y = f;\n    }\n    if (y) {\n      updateContext(e, a, o, r || o, c, d);\n      f = ensureData(y(u || {}, e.store, e));\n    }\n    if (void 0 === f) {\n      if (true) {\n        if (!r || !hasField(r, c) || e.optimistic && !readRecord(r, \"__typename\")) {\n           true && warn(\"Invalid undefined: The field at `\" + c + \"` is `undefined`, but the GraphQL query expects a \" + (void 0 === v.selectionSet ? \"scalar (number, boolean, etc)\" : \"selection set\") + \" for this field.\", 13, e.store.logger);\n        }\n      }\n      continue;\n    }\n    if (v.selectionSet) {\n      if (r && \"query\" === i) {\n        var h = joinKeys(r, c);\n        var m = writeField(e, getSelectionSet(v), ensureData(f), h, e.optimistic ? readLink(r || o, c) : void 0);\n        writeLink(r || o, c, m);\n      } else {\n        writeField(e, getSelectionSet(v), ensureData(f));\n      }\n    } else if (r && \"query\" === i) {\n      writeRecord(r || o, c, null !== f || !getFieldError(e) ? f : void 0);\n    }\n    var g = s && s[d];\n    if (g) {\n      updateContext(e, a, o, r || o, c, d);\n      a[d] = f;\n      g(a, u || {}, e.store, e);\n    }\n    e.__internal.path.pop();\n  }\n};\n\nvar K = /^__|PageInfo|(Connection|Edge)$/;\n\nvar writeField = (e, r, t, a, i) => {\n  if (Array.isArray(t)) {\n    var n = new Array(t.length);\n    for (var o = 0, s = t.length; o < s; o++) {\n      e.__internal.path.push(o);\n      var l = a ? joinKeys(a, `${o}`) : void 0;\n      var v = writeField(e, r, t[o], l, null != i ? i[o] : void 0);\n      n[o] = v;\n      e.__internal.path.pop();\n    }\n    return n;\n  } else if (null === t) {\n    return getFieldError(e) ? void 0 : null;\n  }\n  var d = e.store.keyOfEntity(t) || (\"string\" == typeof i ? i : null);\n  var u = t.__typename;\n  if (true) {\n    if (a && !e.store.keys[t.__typename] && null === d && \"string\" == typeof u && !K.test(u)) {\n      warn(\"Invalid key: The GraphQL query at the field at `\" + a + \"` has a selection set, but no key could be generated for the data at this field.\\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `\" + u + \"`.\\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `\" + u + \"` that always returns null.\", 15, e.store.logger);\n    }\n  }\n  var c = d || a;\n  writeSelection(e, c, r, t);\n  return c || null;\n};\n\nvar invalidateEntity = (e, r, t) => {\n  var a = r ? [ {\n    fieldKey: keyOfField(r, t)\n  } ] : inspectFields(e);\n  for (var i = 0, n = a.length; i < n; i++) {\n    var {fieldKey: o} = a[i];\n    if (void 0 !== readLink(e, o)) {\n      writeLink(e, o, void 0);\n    } else {\n      writeRecord(e, o, void 0);\n    }\n  }\n};\n\nvar invalidateType = e => {\n  var r = (e => w.types.get(e) || q)(e);\n  for (var t of r) {\n    invalidateEntity(t);\n  }\n};\n\nclass Store {\n  constructor(e) {\n    if (!e) {\n      e = {};\n    }\n    this.logger = e.logger;\n    this.resolvers = e.resolvers || {};\n    this.directives = e.directives || {};\n    this.optimisticMutations = e.optimistic || {};\n    this.keys = e.keys || {};\n    this.globalIDs = Array.isArray(e.globalIDs) ? new Set(e.globalIDs) : !!e.globalIDs;\n    var r = \"Query\";\n    var t = \"Mutation\";\n    var a = \"Subscription\";\n    if (e.schema) {\n      var i = (({__schema: e}) => {\n        var r = new Map;\n        var buildNameMap = e => {\n          var r;\n          return () => {\n            if (!r) {\n              r = {};\n              for (var t = 0; t < e.length; t++) {\n                r[e[t].name] = e[t];\n              }\n            }\n            return r;\n          };\n        };\n        var buildType = e => {\n          switch (e.kind) {\n           case \"OBJECT\":\n           case \"INTERFACE\":\n            return {\n              name: e.name,\n              kind: e.kind,\n              interfaces: buildNameMap(e.interfaces || []),\n              fields: buildNameMap(e.fields.map((e => ({\n                name: e.name,\n                type: e.type,\n                args: buildNameMap(e.args)\n              }))))\n            };\n\n           case \"UNION\":\n            return {\n              name: e.name,\n              kind: e.kind,\n              types: buildNameMap(e.possibleTypes || [])\n            };\n          }\n        };\n        var t = {\n          query: e.queryType ? e.queryType.name : null,\n          mutation: e.mutationType ? e.mutationType.name : null,\n          subscription: e.subscriptionType ? e.subscriptionType.name : null,\n          types: void 0,\n          isSubType(e, t) {\n            var a = r.get(e);\n            var i = r.get(t);\n            if (!a || !i) {\n              return !1;\n            } else if (\"UNION\" === a.kind) {\n              return !!a.types()[t];\n            } else if (\"OBJECT\" !== a.kind && \"OBJECT\" === i.kind) {\n              return !!i.interfaces()[e];\n            } else {\n              return e === t;\n            }\n          }\n        };\n        if (e.types) {\n          t.types = r;\n          for (var a = 0; a < e.types.length; a++) {\n            var i = e.types[a];\n            if (i && i.name) {\n              var n = buildType(i);\n              if (n) {\n                r.set(i.name, n);\n              }\n            }\n          }\n        }\n        return t;\n      })(e.schema);\n      r = i.query || r;\n      t = i.mutation || t;\n      a = i.subscription || a;\n      if (i.types) {\n        this.schema = i;\n      }\n    }\n    this.updates = e.updates || {};\n    this.rootFields = {\n      query: r,\n      mutation: t,\n      subscription: a\n    };\n    this.rootNames = {\n      [r]: \"query\",\n      [t]: \"mutation\",\n      [a]: \"subscription\"\n    };\n    this.data = (n = r, {\n      hydrating: !1,\n      defer: !1,\n      gc: new Set,\n      types: new Map,\n      persist: new Set,\n      queryRootKey: n,\n      refCount: new Map,\n      links: {\n        optimistic: new Map,\n        base: new Map\n      },\n      records: {\n        optimistic: new Map,\n        base: new Map\n      },\n      deferredKeys: new Set,\n      commutativeKeys: new Set,\n      dirtyKeys: new Set,\n      optimisticOrder: [],\n      storage: null\n    });\n    var n;\n    if (this.schema && \"production\" !== \"development\") {\n      !function expectValidKeyingConfig(e, r, t) {\n        if (true) {\n          for (var a in r) {\n            if (true) {\n              if (!e.types.has(a)) {\n                warn(\"Invalid Object type: The type `\" + a + \"` is not an object in the defined schema, but the `keys` option is referencing it.\", 20, t);\n              }\n            }\n          }\n        }\n      }(this.schema, this.keys, this.logger);\n      !function expectValidUpdatesConfig(e, r, t) {\n        if (false) {}\n        for (var a in r) {\n          if (!r[a]) {\n            continue;\n          } else if (!e.types.has(a)) {\n            var i = \"\";\n            if (\"Mutation\" === a && e.mutation && \"Mutation\" !== e.mutation) {\n              i += \"\\nMaybe your config should reference `\" + e.mutation + \"`?\";\n            } else if (\"Subscription\" === a && e.subscription && \"Subscription\" !== e.subscription) {\n              i += \"\\nMaybe your config should reference `\" + e.subscription + \"`?\";\n            }\n            return  true ? warn(\"Invalid updates type: The type `\" + a + \"` is not an object in the defined schema, but the `updates` config is referencing it.\" + i, 21, t) : 0;\n          }\n          var n = e.types.get(a).fields();\n          for (var o in r[a]) {\n            if (true) {\n              if (!n[o]) {\n                warn(\"Invalid updates field: `\" + o + \"` on `\" + a + \"` is not in the defined schema, but the `updates` config is referencing it.\", 22, t);\n              }\n            }\n          }\n        }\n      }(this.schema, this.updates, this.logger);\n      !function expectValidResolversConfig(e, r, t) {\n        if (false) {}\n        for (var a in r) {\n          if (\"Query\" === a) {\n            if (e.query) {\n              var i = e.types.get(e.query).fields();\n              for (var n in r.Query || {}) {\n                if (!i[n]) {\n                  warnAboutResolver(\"Query.\" + n, t);\n                }\n              }\n            } else {\n              warnAboutResolver(\"Query\", t);\n            }\n          } else if (!e.types.has(a)) {\n            warnAboutResolver(a, t);\n          } else if (\"INTERFACE\" === e.types.get(a).kind || \"UNION\" === e.types.get(a).kind) {\n            warnAboutAbstractResolver(a, e.types.get(a).kind, t);\n          } else {\n            var o = e.types.get(a).fields();\n            for (var s in r[a] || {}) {\n              if (!o[s]) {\n                warnAboutResolver(a + \".\" + s, t);\n              }\n            }\n          }\n        }\n      }(this.schema, this.resolvers, this.logger);\n      !function expectValidOptimisticMutationsConfig(e, r, t) {\n        if (false) {}\n        if (e.mutation) {\n          var a = e.types.get(e.mutation).fields();\n          for (var i in r) {\n            if (true) {\n              if (!a[i]) {\n                warn(`Invalid optimistic mutation field: \\`${i}\\` is not a mutation field in the defined schema, but the \\`optimistic\\` option is referencing it.`, 24, t);\n              }\n            }\n          }\n        }\n      }(this.schema, this.optimisticMutations, this.logger);\n    }\n  }\n  keyOfField(e, r) {\n    return keyOfField(e, r);\n  }\n  keyOfEntity(e) {\n    if (S && e === S.parent) {\n      return S.parentKey;\n    } else if (null == e || \"string\" == typeof e) {\n      return e || null;\n    } else if (!e.__typename) {\n      return null;\n    } else if (this.rootNames[e.__typename]) {\n      return e.__typename;\n    }\n    var r = null;\n    if (this.keys[e.__typename]) {\n      r = this.keys[e.__typename](e) || null;\n    } else if (null != e.id) {\n      r = `${e.id}`;\n    } else if (null != e._id) {\n      r = `${e._id}`;\n    }\n    var t = e.__typename;\n    return !0 === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r ? r : `${t}:${r}`;\n  }\n  resolve(e, r, t) {\n    var a = this.keyOfEntity(e);\n    if (a) {\n      var i = keyOfField(r, t);\n      var n = readRecord(a, i);\n      if (void 0 !== n) {\n        return n;\n      }\n      var o = readLink(a, i);\n      if (void 0 !== o) {\n        o = ensureLink(this, o);\n      }\n      return o;\n    }\n  }\n  resolveFieldByKey(e, r, t) {\n    return this.resolve(e, r, t);\n  }\n  invalidate(e, r, t) {\n    var a = this.keyOfEntity(e);\n    if (e && \"string\" == typeof e && !r && !t && !this.resolve(e, \"__typename\")) {\n      invalidateType(e);\n    } else {\n      invariant(a,  true ? \"Can't generate a key for invalidate(...).\\nYou have to pass an id or _id field or create a custom `keys` field for `\" + (\"object\" == typeof e ? e.__typename : e + \"`.\") : 0, 19);\n      invalidateEntity(a, r, t);\n    }\n  }\n  inspectFields(e) {\n    var r = this.keyOfEntity(e);\n    return r ? inspectFields(r) : [];\n  }\n  updateQuery(e, r) {\n    var a = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.h)(e.query, e.variables);\n    var i = r(this.readQuery(a));\n    if (null !== i) {\n      _write(this, a, i, void 0);\n    }\n  }\n  readQuery(e) {\n    var r = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.h)(e.query, e.variables);\n    return _query(this, r, void 0, void 0).data;\n  }\n  readFragment(e, t, a, i) {\n    return ((e, r, t, a, i) => {\n      var n = getFragments(r);\n      var o;\n      if (i) {\n        if (!(o = n[i])) {\n           true && warn(\"readFragment(...) was called with a fragment name that does not exist.\\nYou provided \" + i + \" but could only find \" + Object.keys(n).join(\", \") + \".\", 6, e.logger);\n          return null;\n        }\n      } else if (!(o = n[Object.keys(n)[0]])) {\n         true && warn(\"readFragment(...) was called with an empty fragment.\\nYou have to call it with at least one fragment in your GraphQL document.\", 6, e.logger);\n        return null;\n      }\n      var s = getFragmentTypeName(o);\n      if (\"string\" != typeof t && !t.__typename) {\n        t.__typename = s;\n      }\n      var l = e.keyOfEntity(t);\n      if (!l) {\n         true && warn(\"Can't generate a key for readFragment(...).\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + s + \"`.\", 7, e.logger);\n        return null;\n      }\n      if (true) {\n        pushDebugNode(s, o);\n      }\n      var v = makeContext(e, a || {}, n, s, l, void 0);\n      var d = readSelection(v, l, getSelectionSet(o), makeData()) || null;\n      if (true) {\n        popDebugNode();\n      }\n      return d;\n    })(this, (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.formatDocument)(e), t, a, i);\n  }\n  writeFragment(e, t, a, i) {\n    ((e, r, t, a, i) => {\n      var n = getFragments(r);\n      var o;\n      if (i) {\n        if (!(o = n[i])) {\n           true && warn(\"writeFragment(...) was called with a fragment name that does not exist.\\nYou provided \" + i + \" but could only find \" + Object.keys(n).join(\", \") + \".\", 11, e.logger);\n          return null;\n        }\n      } else if (!(o = n[Object.keys(n)[0]])) {\n         true && warn(\"writeFragment(...) was called with an empty fragment.\\nYou have to call it with at least one fragment in your GraphQL document.\", 11, e.logger);\n        return null;\n      }\n      var s = getFragmentTypeName(o);\n      var l = {\n        __typename: s,\n        ...t\n      };\n      var v = e.keyOfEntity(l);\n      if (!v) {\n        return  true ? warn(\"Can't generate a key for writeFragment(...) data.\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + s + \"`.\", 12, e.logger) : 0;\n      }\n      if (true) {\n        pushDebugNode(s, o);\n      }\n      var d = makeContext(e, a || {}, n, s, v, void 0);\n      writeSelection(d, v, getSelectionSet(o), l);\n      if (true) {\n        popDebugNode();\n      }\n    })(this, (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.formatDocument)(e), t, a, i);\n  }\n  link(e, r, ...t) {\n    var a = 2 === t.length ? t[0] : null;\n    var i = 2 === t.length ? t[1] : t[0];\n    var n = this.keyOfEntity(e);\n    if (n) {\n      writeLink(n, keyOfField(r, a), ensureLink(this, i));\n    }\n  }\n}\n\nvar addMetadata = (e, r) => (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.makeOperation)(e.kind, e, {\n  ...e.context,\n  meta: {\n    ...e.context.meta,\n    ...r\n  }\n});\n\nvar toRequestPolicy = (e, r) => (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.makeOperation)(e.kind, e, {\n  ...e.context,\n  requestPolicy: r\n});\n\nvar cacheExchange = e => ({forward: t, client: i, dispatchDebug: n}) => {\n  var o = new Store(e);\n  if (e && e.storage) {\n    o.data.hydrating = !0;\n    e.storage.readData().then((r => {\n      ((e, r, t) => {\n        initDataState(\"write\", e, null);\n        for (var a in t) {\n          var i = t[a];\n          if (void 0 !== i) {\n            var {entityKey: n, fieldKey: o} = deserializeKeyInfo(a);\n            if (\":\" === i[0]) {\n              if (void 0 === readLink(n, o)) {\n                writeLink(n, o, JSON.parse(i.slice(1)));\n              }\n            } else if (void 0 === readRecord(n, o)) {\n              writeRecord(n, o, JSON.parse(i));\n            }\n          }\n        }\n        e.storage = r;\n        e.hydrating = !1;\n        clearDataState();\n      })(o.data, e.storage, r);\n      if (e.storage.onCacheHydrated) {\n        e.storage.onCacheHydrated();\n      }\n    }));\n  }\n  var f = new Map;\n  var y = [];\n  var h = new Map;\n  var m = new Map;\n  var g = new Set;\n  var _ = new Set;\n  var N = new Map;\n  var k = new Set;\n  var E = new Set;\n  var isBlockedByOptimisticUpdate = e => {\n    for (var r of e.values()) {\n      if (g.has(r)) {\n        return !0;\n      }\n    }\n    return !1;\n  };\n  var collectPendingOperations = (e, r) => {\n    if (r) {\n      for (var t of r.values()) {\n        var a = N.get(t);\n        if (a) {\n          for (var i of a.values()) {\n            e.add(i);\n          }\n        }\n      }\n    }\n  };\n  var executePendingOperations = (e, r, t) => {\n    for (var a of r.values()) {\n      if (a !== e.key) {\n        var n = h.get(a);\n        if (n) {\n          if (\"query\" === e.kind) {\n            E.add(a);\n          }\n          var o = \"cache-first\";\n          if (_.has(a)) {\n            _.delete(a);\n            o = \"cache-and-network\";\n          }\n          i.reexecuteOperation(toRequestPolicy(n, o));\n        }\n      }\n    }\n    if (!t) {\n      var s = k;\n      if (\"query\" === e.kind) {\n        (k = E).add(e.key);\n      }\n      (E = s).clear();\n    }\n  };\n  var prepareForwardedOperation = e => {\n    var t = !1;\n    if (\"query\" === e.kind) {\n      reserveLayer(o.data, e.key);\n      h.set(e.key, e);\n    } else if (\"teardown\" === e.kind) {\n      h.delete(e.key);\n      m.delete(e.key);\n      k.delete(e.key);\n      noopDataState(o.data, e.key);\n      return e;\n    } else if (\"mutation\" === e.kind && \"network-only\" !== e.context.requestPolicy) {\n      h.set(e.key, e);\n      initDataState(\"write\", o.data, e.key, !0, !1);\n      var {dependencies: i} = _write(o, e, void 0, void 0);\n      clearDataState();\n      if (i.size) {\n        for (var n of i.values()) {\n          g.add(n);\n        }\n        f.set(e.key, i);\n        var s = new Set;\n        collectPendingOperations(s, i);\n        executePendingOperations(e, s, !0);\n        t = !0;\n      }\n    }\n    return (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.makeOperation)(e.kind, {\n      key: e.key,\n      query: (0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.formatDocument)(e.query),\n      variables: e.variables ? filterVariables(getMainOperation(e.query), e.variables) : e.variables\n    }, {\n      ...e.context,\n      optimistic: t\n    });\n  };\n  var updateDependencies = (e, r) => {\n    for (var t of r.values()) {\n      var a = N.get(t);\n      if (!a) {\n        N.set(t, a = new Set);\n      }\n      a.add(e.key);\n    }\n  };\n  var operationResultFromCache = e => {\n    initDataState(\"read\", o.data, void 0, !1, !1);\n    var r = _query(o, e, m.get(e.key), void 0);\n    clearDataState();\n    var t = r.data ? !r.partial && !r.hasNext ? \"hit\" : \"partial\" : \"miss\";\n    m.set(e.key, r.data);\n    h.set(e.key, e);\n    updateDependencies(e, r.dependencies);\n    return {\n      outcome: t,\n      operation: e,\n      data: r.data,\n      dependencies: r.dependencies,\n      hasNext: r.hasNext\n    };\n  };\n  var updateCacheWithResult = (e, r) => {\n    var t = h.get(e.operation.key) || e.operation;\n    if (\"mutation\" === t.kind) {\n      var a = f.get(t.key);\n      collectPendingOperations(r, a);\n      f.delete(t.key);\n    }\n    if (\"subscription\" === t.kind || e.hasNext) {\n      reserveLayer(o.data, t.key, !0);\n    }\n    var i;\n    var n = e.data;\n    if (n) {\n      initDataState(\"write\", o.data, t.key, !1, !1);\n      var s = _write(o, t, n, e.error).dependencies;\n      clearDataState();\n      collectPendingOperations(r, s);\n      var l = \"query\" === t.kind ? m.get(t.key) : null;\n      initDataState(\"read\", o.data, t.key, !1, l !== n);\n      var v = _query(o, t, l || n, e.error);\n      clearDataState();\n      n = v.data;\n      if (\"query\" === t.kind) {\n        collectPendingOperations(r, i = v.dependencies);\n        m.set(t.key, n);\n      }\n    } else {\n      noopDataState(o.data, t.key);\n    }\n    if (i) {\n      updateDependencies(e.operation, i);\n    }\n    return {\n      operation: t,\n      data: n,\n      error: e.error,\n      extensions: e.extensions,\n      hasNext: e.hasNext,\n      stale: e.stale\n    };\n  };\n  return e => {\n    var r = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.share)((0,wonka__WEBPACK_IMPORTED_MODULE_3__.map)(operationResultFromCache)((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => \"query\" === e.kind && \"network-only\" !== e.context.requestPolicy))(e)));\n    var a = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => \"query\" !== e.kind || \"network-only\" === e.context.requestPolicy))(e);\n    var m = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.map)((e => {\n       true && n({\n        type: \"cacheMiss\",\n        message: \"The result could not be retrieved from the cache\",\n        operation: e.operation,\n        source: \"cacheExchange\"\n      });\n      return  true ? addMetadata(e.operation, {\n        cacheOutcome: \"miss\"\n      }) : 0;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => \"miss\" === e.outcome && \"cache-only\" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies) && !k.has(e.operation.key)))(r));\n    var N = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.map)((e => {\n      var {requestPolicy: r} = e.operation.context;\n      var t = \"cache-only\" !== r && (e.hasNext || \"cache-and-network\" === r || \"cache-first\" === r && \"partial\" === e.outcome && !k.has(e.operation.key));\n      var a = \"cache-only\" !== r && (t || \"partial\" === e.outcome && k.has(e.operation.key) && ((s = o.data).commutativeKeys.has(l = e.operation.key) || s.optimisticOrder.indexOf(l) > -1));\n      var s, l;\n      var v = {\n        operation:  true ? addMetadata(e.operation, {\n          cacheOutcome: e.outcome\n        }) : 0,\n        data: e.data,\n        error: e.error,\n        extensions: e.extensions,\n        stale: a && !e.hasNext,\n        hasNext: t && e.hasNext\n      };\n      if (!t) {} else if (!isBlockedByOptimisticUpdate(e.dependencies)) {\n        i.reexecuteOperation(toRequestPolicy(h.get(e.operation.key) || e.operation, \"network-only\"));\n      } else if (\"cache-and-network\" === r) {\n        _.add(e.operation.key);\n      }\n       true && n({\n        type: \"cacheHit\",\n        message: \"A requested operation was found and returned from the cache.\",\n        operation: e.operation,\n        data: {\n          value: v\n        },\n        source: \"cacheExchange\"\n      });\n      return v;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => \"miss\" !== e.outcome || \"cache-only\" === e.operation.context.requestPolicy))(r));\n    var E = t((0,wonka__WEBPACK_IMPORTED_MODULE_3__.map)(prepareForwardedOperation)((0,wonka__WEBPACK_IMPORTED_MODULE_3__.merge)([ a, m ])));\n    var O = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.map)((e => {\n      var r = new Set;\n      var t = updateCacheWithResult(e, r);\n      executePendingOperations(e.operation, r, !1);\n      return t;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => !f.has(e.operation.key)))(E));\n    var w = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.mergeMap)((e => {\n      if (y.push(e) < f.size) {\n        return wonka__WEBPACK_IMPORTED_MODULE_3__.empty;\n      }\n      for (var r = 0; r < y.length; r++) {\n        reserveLayer(o.data, y[r].operation.key);\n      }\n      g.clear();\n      var t = [];\n      var a = new Set;\n      var i;\n      while (i = y.shift()) {\n        t.push(updateCacheWithResult(i, a));\n      }\n      executePendingOperations(e.operation, a, !1);\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_3__.fromArray)(t);\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => f.has(e.operation.key)))(E));\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_3__.merge)([ O, w, N ]);\n  };\n};\n\nvar M = {\n  \"cache-only\": 0,\n  \"cache-first\": 1,\n  \"network-only\": 2,\n  \"cache-and-network\": 3\n};\n\nvar offlineExchange = e => r => {\n  var {storage: n} = e;\n  var o = e.isOfflineError || (e => e && e.networkError && !e.response && (\"undefined\" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\\s?error/i.test(e.networkError.message)));\n  if (n && n.onOnline && n.readMetadata && n.writeMetadata) {\n    var {forward: l, client: u, dispatchDebug: c} = r;\n    var {source: p, next: h} = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.makeSubject)();\n    var m = [];\n    var g = !1;\n    var _ = !1;\n    var updateMetadata = () => {\n      if (g) {\n        var e = [];\n        for (var r = 0; r < m.length; r++) {\n          var t = m[r];\n          if (\"mutation\" === t.kind) {\n            e.push({\n              query: (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.s)(t.query),\n              variables: t.variables,\n              extensions: t.extensions\n            });\n          }\n        }\n        n.writeMetadata(e);\n      }\n    };\n    var filterQueue = e => {\n      for (var r = m.length - 1; r >= 0; r--) {\n        if (m[r].key === e) {\n          m.splice(r, 1);\n        }\n      }\n    };\n    var flushQueue = () => {\n      if (!_) {\n        var e = new Set;\n        _ = !0;\n        for (var r = 0; r < m.length; r++) {\n          var t = m[r];\n          if (\"mutation\" === t.kind || !e.has(t.key)) {\n            e.add(t.key);\n            if (\"subscription\" !== t.kind) {\n              h((0,_urql_core__WEBPACK_IMPORTED_MODULE_2__.makeOperation)(\"teardown\", t));\n              var i = \"cache-first\";\n              for (var n = 0; n < m.length; n++) {\n                var {requestPolicy: o} = m[n].context;\n                if (M[o] > M[i]) {\n                  i = o;\n                }\n              }\n              h(toRequestPolicy(t, i));\n            } else {\n              h(toRequestPolicy(t, \"cache-first\"));\n            }\n          }\n        }\n        _ = !1;\n        m.length = 0;\n        updateMetadata();\n      }\n    };\n    var N = cacheExchange({\n      ...e,\n      storage: {\n        ...n,\n        readData() {\n          var e = n.readData();\n          return {\n            async then(r) {\n              var a = await n.readMetadata();\n              for (var i = 0; a && i < a.length; i++) {\n                m.push(u.createRequestOperation(\"mutation\", (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.h)(a[i].query, a[i].variables), a[i].extensions));\n              }\n              r(await e);\n              n.onOnline(flushQueue);\n              g = !0;\n              flushQueue();\n            }\n          };\n        }\n      }\n    })({\n      client: u,\n      dispatchDebug: c,\n      forward: e => (0,wonka__WEBPACK_IMPORTED_MODULE_3__.share)((0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => {\n        if (g && \"mutation\" === e.operation.kind && e.operation.context.optimistic && o(e.error, e)) {\n          m.push(e.operation);\n          updateMetadata();\n          return !1;\n        }\n        return !0;\n      }))(l(e)))\n    });\n    return e => {\n      var r = (0,wonka__WEBPACK_IMPORTED_MODULE_3__.merge)([ p, (0,wonka__WEBPACK_IMPORTED_MODULE_3__.onPush)((e => {\n        if (\"query\" === e.kind && !g) {\n          m.push(e);\n        } else if (\"teardown\" === e.kind) {\n          filterQueue(e.key);\n        }\n      }))(e) ]);\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_3__.filter)((e => {\n        if (\"query\" === e.operation.kind) {\n          if (o(e.error, e)) {\n            h(toRequestPolicy(e.operation, \"cache-only\"));\n            m.push(e.operation);\n            return !1;\n          } else if (!g) {\n            filterQueue(e.operation.key);\n          }\n        }\n        return !0;\n      }))(N(r));\n    };\n  }\n  return cacheExchange(e)(r);\n};\n\n\n//# sourceMappingURL=urql-exchange-graphcache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrZXhjaGFuZ2UtZ3JhcGhjYWNoZUA2LjUuMV9ncmFwaHFsQDE2LjguMS9ub2RlX21vZHVsZXMvQHVycWwvZXhjaGFuZ2UtZ3JhcGhjYWNoZS9kaXN0L3VycWwtZXhjaGFuZ2UtZ3JhcGhjYWNoZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwSTs7QUFFaEU7O0FBRXNFOztBQUVoSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFDO0FBQ2xCLG1DQUFtQyxFQUFFO0FBQ3JDLElBQUksb0JBQW9CLHFEQUFDO0FBQ3pCLFdBQVcsYUFBYSxhQUFhLGdCQUFnQixFQUFFLFlBQVk7QUFDbkUsSUFBSSxvQkFBb0IscURBQUM7QUFDekIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0EsY0FBYyx3RUFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQSxpREFBaUQsd0VBQUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JB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LGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQUM7QUFDWjtBQUNBLGFBQWEsMERBQUM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQUMsQ0FBQywwQ0FBQywyQkFBMkIsNkNBQUM7QUFDM0MsWUFBWSw2Q0FBQztBQUNiLFlBQVksMENBQUM7QUFDYixNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQSxPQUFPLElBQUksQ0FBVztBQUN0QixLQUFLLEdBQUcsNkNBQUM7QUFDVCxZQUFZLDBDQUFDO0FBQ2IsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUM7QUFDeEQ7QUFDQSxTQUFTLElBQUksQ0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssR0FBRyw2Q0FBQztBQUNULGNBQWMsMENBQUMsNEJBQTRCLDRDQUFDO0FBQzVDLFlBQVksMENBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRyw2Q0FBQztBQUNULFlBQVksK0NBQUM7QUFDYjtBQUNBLGVBQWUsd0NBQUM7QUFDaEI7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQUM7QUFDZCxLQUFLLEdBQUcsNkNBQUM7QUFDVCxXQUFXLDRDQUFDO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLFlBQVk7QUFDbkI7QUFDQTtBQUNBLFNBQVMseUNBQXlDO0FBQ2xELFNBQVMsb0JBQW9CLEVBQUUsa0RBQUM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZDQUFDO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQUM7QUFDakI7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRCw0REFBNEQsNkNBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUMsQ0FBQyw2Q0FBQztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsY0FBYyw0Q0FBQyxNQUFNLDZDQUFDO0FBQ3RCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhLDZDQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7QUFDakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrZXhjaGFuZ2UtZ3JhcGhjYWNoZUA2LjUuMV9ncmFwaHFsQDE2LjguMS9ub2RlX21vZHVsZXMvQHVycWwvZXhjaGFuZ2UtZ3JhcGhjYWNoZS9kaXN0L3VycWwtZXhjaGFuZ2UtZ3JhcGhjYWNoZS5tanM/OTY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJpbmdpZnlWYXJpYWJsZXMgYXMgZSwgZm9ybWF0RG9jdW1lbnQgYXMgciwgY3JlYXRlUmVxdWVzdCBhcyB0LCBtYWtlT3BlcmF0aW9uIGFzIGEsIHN0cmluZ2lmeURvY3VtZW50IGFzIGkgfSBmcm9tIFwiQHVycWwvY29yZVwiO1xuXG5pbXBvcnQgeyBLaW5kIGFzIG4sIHZhbHVlRnJvbUFTVFVudHlwZWQgYXMgbyB9IGZyb20gXCJAMG5vLWNvL2dyYXBocWwud2ViXCI7XG5cbmltcG9ydCB7IHNoYXJlIGFzIHMsIG1hcCBhcyBsLCBmaWx0ZXIgYXMgdiwgbWVyZ2UgYXMgZCwgbWVyZ2VNYXAgYXMgdSwgZW1wdHkgYXMgYywgZnJvbUFycmF5IGFzIHAsIG1ha2VTdWJqZWN0IGFzIGYsIG9uUHVzaCBhcyB5IH0gZnJvbSBcIndvbmthXCI7XG5cbnZhciBoID0gXCJcXG5odHRwczovL2JpdC5seS8yWGJWcnBSI1wiO1xuXG52YXIgbSA9IG5ldyBTZXQ7XG5cbnZhciBnID0gW107XG5cbnZhciBwb3BEZWJ1Z05vZGUgPSAoKSA9PiBnLnBvcCgpO1xuXG52YXIgcHVzaERlYnVnTm9kZSA9IChlLCByKSA9PiB7XG4gIHZhciB0ID0gXCJcIjtcbiAgaWYgKHIua2luZCA9PT0gbi5JTkxJTkVfRlJBR01FTlQpIHtcbiAgICB0ID0gZSA/IGBJbmxpbmUgRnJhZ21lbnQgb24gXCIke2V9XCJgIDogXCJJbmxpbmUgRnJhZ21lbnRcIjtcbiAgfSBlbHNlIGlmIChyLmtpbmQgPT09IG4uT1BFUkFUSU9OX0RFRklOSVRJT04pIHtcbiAgICB0ID0gYCR7ci5uYW1lID8gYFwiJHtyLm5hbWUudmFsdWV9XCJgIDogXCJVbm5hbWVkXCJ9ICR7ci5vcGVyYXRpb259YDtcbiAgfSBlbHNlIGlmIChyLmtpbmQgPT09IG4uRlJBR01FTlRfREVGSU5JVElPTikge1xuICAgIHQgPSBgXCIke3IubmFtZS52YWx1ZX1cIiBGcmFnbWVudGA7XG4gIH1cbiAgaWYgKHQpIHtcbiAgICBnLnB1c2godCk7XG4gIH1cbn07XG5cbnZhciBnZXREZWJ1Z091dHB1dCA9ICgpID0+IGcubGVuZ3RoID8gXCJcXG4oQ2F1c2VkIEF0OiBcIiArIGcuam9pbihcIiwgXCIpICsgXCIpXCIgOiBcIlwiO1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoZSwgciwgdCkge1xuICBpZiAoIWUpIHtcbiAgICB2YXIgYSA9IHIgfHwgXCJNaW5maWVkIEVycm9yICNcIiArIHQgKyBcIlxcblwiO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGEgKz0gZ2V0RGVidWdPdXRwdXQoKTtcbiAgICB9XG4gICAgdmFyIGkgPSBuZXcgRXJyb3IoYSArIGggKyB0KTtcbiAgICBpLm5hbWUgPSBcIkdyYXBoY2FjaGUgRXJyb3JcIjtcbiAgICB0aHJvdyBpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4oZSwgciwgdCkge1xuICBpZiAoIW0uaGFzKGUpKSB7XG4gICAgaWYgKHQpIHtcbiAgICAgIHQoXCJ3YXJuXCIsIGUgKyBnZXREZWJ1Z091dHB1dCgpICsgaCArIHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oZSArIGdldERlYnVnT3V0cHV0KCkgKyBoICsgcik7XG4gICAgfVxuICAgIG0uYWRkKGUpO1xuICB9XG59XG5cbnZhciBfID0ge307XG5cbnZhciBnZXREaXJlY3RpdmVzID0gZSA9PiBlLl9kaXJlY3RpdmVzIHx8IF87XG5cbnZhciBnZXROYW1lID0gZSA9PiBlLm5hbWUudmFsdWU7XG5cbnZhciBnZXRGcmFnbWVudFR5cGVOYW1lID0gZSA9PiBlLnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcblxudmFyIGdldEZpZWxkQWxpYXMgPSBlID0+IGUuYWxpYXMgPyBlLmFsaWFzLnZhbHVlIDogZS5uYW1lLnZhbHVlO1xuXG52YXIgTiA9IFtdO1xuXG52YXIgZ2V0U2VsZWN0aW9uU2V0ID0gZSA9PiBlLnNlbGVjdGlvblNldCA/IGUuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMgOiBOO1xuXG52YXIgZ2V0VHlwZUNvbmRpdGlvbiA9IGUgPT4gZS50eXBlQ29uZGl0aW9uID8gZS50eXBlQ29uZGl0aW9uLm5hbWUudmFsdWUgOiBudWxsO1xuXG52YXIgZ2V0RmllbGRBcmd1bWVudHMgPSAoZSwgcikgPT4ge1xuICB2YXIgdCA9IG51bGw7XG4gIGlmIChlLmFyZ3VtZW50cykge1xuICAgIGZvciAodmFyIGEgPSAwLCBpID0gZS5hcmd1bWVudHMubGVuZ3RoOyBhIDwgaTsgYSsrKSB7XG4gICAgICB2YXIgbiA9IGUuYXJndW1lbnRzW2FdO1xuICAgICAgdmFyIHMgPSBvKG4udmFsdWUsIHIpO1xuICAgICAgaWYgKG51bGwgIT0gcykge1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICB0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdFtnZXROYW1lKG4pXSA9IHM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufTtcblxudmFyIGZpbHRlclZhcmlhYmxlcyA9IChlLCByKSA9PiB7XG4gIGlmICghciB8fCAhZS52YXJpYWJsZURlZmluaXRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIGEgPSAwLCBpID0gZS52YXJpYWJsZURlZmluaXRpb25zLmxlbmd0aDsgYSA8IGk7IGErKykge1xuICAgIHZhciBuID0gZ2V0TmFtZShlLnZhcmlhYmxlRGVmaW5pdGlvbnNbYV0udmFyaWFibGUpO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufTtcblxudmFyIG5vcm1hbGl6ZVZhcmlhYmxlcyA9IChlLCByKSA9PiB7XG4gIHZhciB0ID0ge307XG4gIGlmICghcikge1xuICAgIHJldHVybiB0O1xuICB9XG4gIGlmIChlLnZhcmlhYmxlRGVmaW5pdGlvbnMpIHtcbiAgICBmb3IgKHZhciBhID0gMCwgaSA9IGUudmFyaWFibGVEZWZpbml0aW9ucy5sZW5ndGg7IGEgPCBpOyBhKyspIHtcbiAgICAgIHZhciBuID0gZS52YXJpYWJsZURlZmluaXRpb25zW2FdO1xuICAgICAgdmFyIHMgPSBnZXROYW1lKG4udmFyaWFibGUpO1xuICAgICAgdFtzXSA9IHZvaWQgMCA9PT0gcltzXSAmJiBuLmRlZmF1bHRWYWx1ZSA/IG8obi5kZWZhdWx0VmFsdWUsIHIpIDogcltzXTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgbCBpbiByKSB7XG4gICAgaWYgKCEobCBpbiB0KSkge1xuICAgICAgdFtsXSA9IHJbbF07XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gZ2V0TWFpbk9wZXJhdGlvbihlKSB7XG4gIGZvciAodmFyIHIgPSAwOyByIDwgZS5kZWZpbml0aW9ucy5sZW5ndGg7IHIrKykge1xuICAgIGlmIChlLmRlZmluaXRpb25zW3JdLmtpbmQgPT09IG4uT1BFUkFUSU9OX0RFRklOSVRJT04pIHtcbiAgICAgIHJldHVybiBlLmRlZmluaXRpb25zW3JdO1xuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQoITEsIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IFwiSW52YWxpZCBHcmFwaFFMIGRvY3VtZW50OiBBbGwgR3JhcGhRTCBkb2N1bWVudHMgbXVzdCBjb250YWluIGFuIE9wZXJhdGlvbkRlZmluaXRpb25ub2RlIGZvciBhIHF1ZXJ5LCBzdWJzY3JpcHRpb24sIG9yIG11dGF0aW9uLlwiIDogXCJcIiwgMSk7XG59XG5cbnZhciBnZXRGcmFnbWVudHMgPSBlID0+IHtcbiAgdmFyIHIgPSB7fTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmRlZmluaXRpb25zLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIGEgPSBlLmRlZmluaXRpb25zW3RdO1xuICAgIGlmIChhLmtpbmQgPT09IG4uRlJBR01FTlRfREVGSU5JVElPTikge1xuICAgICAgcltnZXROYW1lKGEpXSA9IGE7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxudmFyIHNob3VsZEluY2x1ZGUgPSAoZSwgcikgPT4ge1xuICB2YXIgdCA9IGdldERpcmVjdGl2ZXMoZSk7XG4gIGlmICh0LmluY2x1ZGUgfHwgdC5za2lwKSB7XG4gICAgZm9yICh2YXIgYSBpbiB0KSB7XG4gICAgICB2YXIgaSA9IHRbYV07XG4gICAgICBpZiAoaSAmJiAoXCJpbmNsdWRlXCIgPT09IGEgfHwgXCJza2lwXCIgPT09IGEpICYmIGkuYXJndW1lbnRzICYmIGkuYXJndW1lbnRzWzBdICYmIFwiaWZcIiA9PT0gZ2V0TmFtZShpLmFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgdmFyIG4gPSBvKGkuYXJndW1lbnRzWzBdLnZhbHVlLCByKTtcbiAgICAgICAgcmV0dXJuIFwiaW5jbHVkZVwiID09PSBhID8gISFuIDogIW47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAhMDtcbn07XG5cbnZhciBpc0RlZmVycmVkID0gKGUsIHIpID0+IHtcbiAgdmFyIHtkZWZlcjogdH0gPSBnZXREaXJlY3RpdmVzKGUpO1xuICBpZiAodCkge1xuICAgIGZvciAodmFyIGEgb2YgdC5hcmd1bWVudHMgfHwgW10pIHtcbiAgICAgIGlmIChcImlmXCIgPT09IGdldE5hbWUoYSkpIHtcbiAgICAgICAgcmV0dXJuICEhbyhhLnZhbHVlLCByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn07XG5cbnZhciBpc09wdGlvbmFsID0gZSA9PiB7XG4gIHZhciB7b3B0aW9uYWw6IHIsIHJlcXVpcmVkOiB0fSA9IGdldERpcmVjdGl2ZXMoZSk7XG4gIGlmICh0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChyKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybjtcbn07XG5cbnZhciBrID0gXCJfX1wiO1xuXG52YXIgaXNGaWVsZE51bGxhYmxlID0gKGUsIHIsIHQsIGEpID0+IHtcbiAgdmFyIGkgPSBnZXRGaWVsZChlLCByLCB0LCBhKTtcbiAgcmV0dXJuICEhaSAmJiBcIk5PTl9OVUxMXCIgIT09IGkudHlwZS5raW5kO1xufTtcblxudmFyIGlzTGlzdE51bGxhYmxlID0gKGUsIHIsIHQsIGEpID0+IHtcbiAgdmFyIGkgPSBnZXRGaWVsZChlLCByLCB0LCBhKTtcbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBuID0gXCJOT05fTlVMTFwiID09PSBpLnR5cGUua2luZCA/IGkudHlwZS5vZlR5cGUgOiBpLnR5cGU7XG4gIHJldHVybiBcIkxJU1RcIiA9PT0gbi5raW5kICYmIFwiTk9OX05VTExcIiAhPT0gbi5vZlR5cGUua2luZDtcbn07XG5cbnZhciBpc0ZpZWxkQXZhaWxhYmxlT25UeXBlID0gKGUsIHIsIHQsIGEpID0+IDAgPT09IHQuaW5kZXhPZihrKSB8fCAwID09PSByLmluZGV4T2YoaykgfHwgISFnZXRGaWVsZChlLCByLCB0LCBhKTtcblxudmFyIGlzSW50ZXJmYWNlT2ZUeXBlID0gKGUsIHIsIHQpID0+IHtcbiAgaWYgKCF0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBhID0gZ2V0VHlwZUNvbmRpdGlvbihyKTtcbiAgaWYgKCFhIHx8IHQgPT09IGEpIHtcbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAoZS50eXBlcy5oYXMoYSkgJiYgXCJPQkpFQ1RcIiA9PT0gZS50eXBlcy5nZXQoYSkua2luZCkge1xuICAgIHJldHVybiBhID09PSB0O1xuICB9XG4gICFmdW5jdGlvbiBleHBlY3RBYnN0cmFjdFR5cGUoZSwgcikge1xuICAgIGludmFyaWFudChlLnR5cGVzLmhhcyhyKSAmJiAoXCJJTlRFUkZBQ0VcIiA9PT0gZS50eXBlcy5nZXQocikua2luZCB8fCBcIlVOSU9OXCIgPT09IGUudHlwZXMuZ2V0KHIpLmtpbmQpLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkludmFsaWQgQWJzdHJhY3QgdHlwZTogVGhlIHR5cGUgYFwiICsgciArIFwiYCBpcyBub3QgYW4gSW50ZXJmYWNlIG9yIFVuaW9uIHR5cGUgaW4gdGhlIGRlZmluZWQgc2NoZW1hLCBidXQgYSBmcmFnbWVudCBpbiB0aGUgR3JhcGhRTCBkb2N1bWVudCBpcyB1c2luZyBpdCBhcyBhIHR5cGUgY29uZGl0aW9uLlwiIDogXCJcIiwgNSk7XG4gIH0oZSwgYSk7XG4gIGV4cGVjdE9iamVjdFR5cGUoZSwgdCk7XG4gIHJldHVybiBlLmlzU3ViVHlwZShhLCB0KTtcbn07XG5cbnZhciBnZXRGaWVsZCA9IChlLCByLCB0LCBhKSA9PiB7XG4gIGlmICgwID09PSB0LmluZGV4T2YoaykgfHwgMCA9PT0gci5pbmRleE9mKGspKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV4cGVjdE9iamVjdFR5cGUoZSwgcik7XG4gIHZhciBpID0gZS50eXBlcy5nZXQocikuZmllbGRzKClbdF07XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZpZWxkOiBUaGUgZmllbGQgYFwiICsgdCArIFwiYCBkb2VzIG5vdCBleGlzdCBvbiBgXCIgKyByICsgXCJgLCBidXQgdGhlIEdyYXBoUUwgZG9jdW1lbnQgZXhwZWN0cyBpdCB0byBleGlzdC5cXG5UcmF2ZXJzYWwgd2lsbCBjb250aW51ZSwgaG93ZXZlciB0aGlzIG1heSBsZWFkIHRvIHVuZGVmaW5lZCBiZWhhdmlvciFcIiwgNCwgYSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gZXhwZWN0T2JqZWN0VHlwZShlLCByKSB7XG4gIGludmFyaWFudChlLnR5cGVzLmhhcyhyKSAmJiBcIk9CSkVDVFwiID09PSBlLnR5cGVzLmdldChyKS5raW5kLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkludmFsaWQgT2JqZWN0IHR5cGU6IFRoZSB0eXBlIGBcIiArIHIgKyBcImAgaXMgbm90IGFuIG9iamVjdCBpbiB0aGUgZGVmaW5lZCBzY2hlbWEsIGJ1dCB0aGUgR3JhcGhRTCBkb2N1bWVudCBpcyB0cmF2ZXJzaW5nIGl0LlwiIDogXCJcIiwgMyk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFJlc29sdmVyKGUsIHIpIHtcbiAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oYEludmFsaWQgcmVzb2x2ZXI6IFxcYCR7ZX1cXGAgaXMgbm90IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBcXGByZXNvbHZlcnNcXGAgb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LmAsIDIzLCByKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0QWJzdHJhY3RSZXNvbHZlcihlLCByLCB0KSB7XG4gIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKGBJbnZhbGlkIHJlc29sdmVyOiBcXGAke2V9XFxgIGRvZXMgbm90IG1hdGNoIHRvIGEgY29uY3JldGUgdHlwZSBpbiB0aGUgc2NoZW1hLCBidXQgdGhlIFxcYHJlc29sdmVyc1xcYCBvcHRpb24gaXMgcmVmZXJlbmNpbmcgaXQuIEltcGxlbWVudCB0aGUgcmVzb2x2ZXIgZm9yIHRoZSB0eXBlcyB0aGF0ICR7XCJVTklPTlwiID09PSByID8gXCJtYWtlIHVwIHRoZSB1bmlvblwiIDogXCJpbXBsZW1lbnQgdGhlIGludGVyZmFjZVwifSBpbnN0ZWFkLmAsIDI2LCB0KTtcbn1cblxudmFyIGtleU9mRmllbGQgPSAociwgdCkgPT4gdCA/IGAke3J9KCR7ZSh0KX0pYCA6IHI7XG5cbnZhciBqb2luS2V5cyA9IChlLCByKSA9PiBgJHtlfS4ke3J9YDtcblxudmFyIGZpZWxkSW5mb09mS2V5ID0gZSA9PiB7XG4gIHZhciByID0gZS5pbmRleE9mKFwiKFwiKTtcbiAgaWYgKHIgPiAtMSkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWVsZEtleTogZSxcbiAgICAgIGZpZWxkTmFtZTogZS5zbGljZSgwLCByKSxcbiAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZShlLnNsaWNlKHIgKyAxLCAtMSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmllbGRLZXk6IGUsXG4gICAgICBmaWVsZE5hbWU6IGUsXG4gICAgICBhcmd1bWVudHM6IG51bGxcbiAgICB9O1xuICB9XG59O1xuXG52YXIgZGVzZXJpYWxpemVLZXlJbmZvID0gZSA9PiB7XG4gIHZhciByID0gZS5pbmRleE9mKFwiLlwiKTtcbiAgcmV0dXJuIHtcbiAgICBlbnRpdHlLZXk6IGUuc2xpY2UoMCwgcikucmVwbGFjZSgvJTJlL2csIFwiLlwiKSxcbiAgICBmaWVsZEtleTogZS5zbGljZShyICsgMSlcbiAgfTtcbn07XG5cbnZhciBFID0gbnVsbDtcblxudmFyIE8gPSBudWxsO1xuXG52YXIgdyA9IG51bGw7XG5cbnZhciBiID0gbnVsbDtcblxudmFyIEQgPSBudWxsO1xuXG52YXIgeCA9IG51bGw7XG5cbnZhciBWID0gITE7XG5cbnZhciBJID0gITE7XG5cbmZ1bmN0aW9uIG1ha2VEYXRhKGUsIHIpIHtcbiAgdmFyIHQ7XG4gIGlmIChlKSB7XG4gICAgaWYgKEUuaGFzKGUpKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgdCA9IE8uZ2V0KGUpO1xuICB9XG4gIGlmIChudWxsID09IHQpIHtcbiAgICB0ID0gciA/IFtdIDoge307XG4gIH1cbiAgaWYgKGUpIHtcbiAgICBPLnNldChlLCB0KTtcbiAgfVxuICBFLmFkZCh0KTtcbiAgcmV0dXJuIHQ7XG59XG5cbnZhciBvd25zRGF0YSA9IGUgPT4gISFlICYmIEUuaGFzKGUpO1xuXG52YXIgaW5pdERhdGFTdGF0ZSA9IChlLCByLCB0LCBhLCBpKSA9PiB7XG4gIEUgPSBuZXcgV2Vha1NldDtcbiAgTyA9IG5ldyBXZWFrTWFwO1xuICBEID0gZTtcbiAgdyA9IHI7XG4gIHggPSBuZXcgU2V0O1xuICBJID0gISFhO1xuICBWID0gISFpO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgZy5sZW5ndGggPSAwO1xuICB9XG4gIGlmICghdCkge1xuICAgIGIgPSBudWxsO1xuICB9IGVsc2UgaWYgKFwicmVhZFwiID09PSBEKSB7XG4gICAgYiA9IHQ7XG4gIH0gZWxzZSBpZiAoYSB8fCByLmh5ZHJhdGluZyB8fCByLm9wdGltaXN0aWNPcmRlci5sZW5ndGggPiAxKSB7XG4gICAgaWYgKCFhICYmICFyLmNvbW11dGF0aXZlS2V5cy5oYXModCkpIHtcbiAgICAgIHJlc2VydmVMYXllcihyLCB0KTtcbiAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgIGlmICgtMSAhPT0gci5vcHRpbWlzdGljT3JkZXIuaW5kZXhPZih0KSAmJiAhci5jb21tdXRhdGl2ZUtleXMuaGFzKHQpKSB7XG4gICAgICAgIHIub3B0aW1pc3RpY09yZGVyLnNwbGljZShyLm9wdGltaXN0aWNPcmRlci5pbmRleE9mKHQpLCAxKTtcbiAgICAgIH1cbiAgICAgIHIuY29tbXV0YXRpdmVLZXlzLmRlbGV0ZSh0KTtcbiAgICB9XG4gICAgYiA9IHQ7XG4gICAgY3JlYXRlTGF5ZXIociwgdCk7XG4gIH0gZWxzZSB7XG4gICAgYiA9IG51bGw7XG4gICAgZGVsZXRlTGF5ZXIociwgdCk7XG4gIH1cbn07XG5cbnZhciBjbGVhckRhdGFTdGF0ZSA9ICgpID0+IHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGdldEN1cnJlbnREZXBlbmRlbmNpZXMoKTtcbiAgfVxuICB2YXIgZSA9IHc7XG4gIHZhciByID0gYjtcbiAgSSA9ICExO1xuICBiID0gbnVsbDtcbiAgaWYgKCFlLmh5ZHJhdGluZyAmJiByICYmIGUub3B0aW1pc3RpY09yZGVyLmluZGV4T2YocikgPiAtMSkge1xuICAgIHZhciB0ID0gZS5vcHRpbWlzdGljT3JkZXIubGVuZ3RoO1xuICAgIHdoaWxlICgtLXQgPj0gMCAmJiBlLmRpcnR5S2V5cy5oYXMoZS5vcHRpbWlzdGljT3JkZXJbdF0pICYmIGUuY29tbXV0YXRpdmVLZXlzLmhhcyhlLm9wdGltaXN0aWNPcmRlclt0XSkpIHtcbiAgICAgIHNxdWFzaExheWVyKGUub3B0aW1pc3RpY09yZGVyW3RdKTtcbiAgICB9XG4gIH1cbiAgRSA9IG51bGw7XG4gIE8gPSBudWxsO1xuICBEID0gbnVsbDtcbiAgdyA9IG51bGw7XG4gIHggPSBudWxsO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgZy5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChcInRlc3RcIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoIWUuZGVmZXIgJiYgKGUuc3RvcmFnZSB8fCAhZS5vcHRpbWlzdGljT3JkZXIubGVuZ3RoKSkge1xuICAgICAgZS5kZWZlciA9ICEwO1xuICAgICAgc2V0VGltZW91dCgoKCkgPT4ge1xuICAgICAgICBpbml0RGF0YVN0YXRlKFwicmVhZFwiLCBlLCBudWxsKTtcbiAgICAgICAgZ2MoKTtcbiAgICAgICAgcGVyc2lzdERhdGEoKTtcbiAgICAgICAgY2xlYXJEYXRhU3RhdGUoKTtcbiAgICAgICAgZS5kZWZlciA9ICExO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG5vb3BEYXRhU3RhdGUgPSAoZSwgciwgdCkgPT4ge1xuICBpZiAociAmJiAhdCkge1xuICAgIGUuZGVmZXJyZWRLZXlzLmRlbGV0ZShyKTtcbiAgfVxuICBpbml0RGF0YVN0YXRlKFwid3JpdGVcIiwgZSwgciwgdCk7XG4gIGNsZWFyRGF0YVN0YXRlKCk7XG59O1xuXG52YXIgZ2V0Q3VycmVudERlcGVuZGVuY2llcyA9ICgpID0+IHtcbiAgaW52YXJpYW50KG51bGwgIT09IHgsIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IFwiSW52YWxpZCBDYWNoZSBjYWxsOiBUaGUgY2FjaGUgbWF5IG9ubHkgYmUgYWNjZXNzZWQgb3IgbXV0YXRlZCBkdXJpbmdvcGVyYXRpb25zIGxpa2Ugd3JpdGUgb3IgcXVlcnksIG9yIGFzIHBhcnQgb2YgaXRzIHJlc29sdmVycywgdXBkYXRlcnMsIG9yIG9wdGltaXN0aWMgY29uZmlncy5cIiA6IFwiXCIsIDIpO1xuICByZXR1cm4geDtcbn07XG5cbnZhciBxID0gbmV3IFNldDtcblxudmFyIHNldE5vZGUgPSAoZSwgciwgdCwgYSkgPT4ge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaW52YXJpYW50KFwicmVhZFwiICE9PSBELCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkludmFsaWQgQ2FjaGUgd3JpdGU6IFlvdSBtYXkgbm90IHdyaXRlIHRvIHRoZSBjYWNoZSBkdXJpbmcgY2FjaGUgcmVhZHMuICBBY2Nlc3NlcyB0byBgY2FjaGUud3JpdGVGcmFnbWVudGAsIGBjYWNoZS51cGRhdGVRdWVyeWAsIGFuZCBgY2FjaGUubGlua2AgbWF5ICBub3QgYmUgbWFkZSBpbnNpZGUgYHJlc29sdmVyc2AgZm9yIGluc3RhbmNlLlwiIDogXCJcIiwgMjcpO1xuICB9XG4gIHZhciBpID0gYiA/IGUub3B0aW1pc3RpYy5nZXQoYikgOiBlLmJhc2U7XG4gIHZhciBuID0gaS5nZXQocik7XG4gIGlmICh2b2lkIDAgPT09IG4pIHtcbiAgICBpLnNldChyLCBuID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgaWYgKHZvaWQgMCA9PT0gYSAmJiAhYikge1xuICAgIGRlbGV0ZSBuW3RdO1xuICB9IGVsc2Uge1xuICAgIG5bdF0gPSBhO1xuICB9XG59O1xuXG52YXIgZ2V0Tm9kZSA9IChlLCByLCB0KSA9PiB7XG4gIHZhciBhO1xuICB2YXIgaSA9ICFJICYmIFwicmVhZFwiID09PSBEICYmIGIgJiYgdy5jb21tdXRhdGl2ZUtleXMuaGFzKGIpO1xuICBmb3IgKHZhciBuID0gMCwgbyA9IHcub3B0aW1pc3RpY09yZGVyLmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgIHZhciBzID0gdy5vcHRpbWlzdGljT3JkZXJbbl07XG4gICAgdmFyIGwgPSBlLm9wdGltaXN0aWMuZ2V0KHMpO1xuICAgIGkgPSBpICYmIHMgIT09IGI7XG4gICAgaWYgKGwgJiYgKCFpIHx8ICF3LmNvbW11dGF0aXZlS2V5cy5oYXMocykpICYmICghSSB8fCBcIndyaXRlXCIgPT09IEQgfHwgdy5jb21tdXRhdGl2ZUtleXMuaGFzKHMpKSAmJiB2b2lkIDAgIT09IChhID0gbC5nZXQocikpICYmIHQgaW4gYSkge1xuICAgICAgcmV0dXJuIGFbdF07XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDAgIT09IChhID0gZS5iYXNlLmdldChyKSkgPyBhW3RdIDogdm9pZCAwO1xufTtcblxudmFyIHVwZGF0ZVJDRm9yTGluayA9IChlLCByKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgZm9yICh2YXIgdCA9IDAsIGEgPSBlLmxlbmd0aDsgdCA8IGE7IHQrKykge1xuICAgICAgdXBkYXRlUkNGb3JMaW5rKGVbdF0sIHIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgKChlLCByKSA9PiB7XG4gICAgICB2YXIgdCA9IHcucmVmQ291bnQuZ2V0KGUpIHx8IDA7XG4gICAgICB2YXIgYSA9IHQgKyByID4gMCA/IHQgKyByIDogMDtcbiAgICAgIHcucmVmQ291bnQuc2V0KGUsIGEpO1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIHcuZ2MuYWRkKGUpO1xuICAgICAgfSBlbHNlIGlmICghdCAmJiBhKSB7XG4gICAgICAgIHcuZ2MuZGVsZXRlKGUpO1xuICAgICAgfVxuICAgIH0pKGUsIHIpO1xuICB9XG59O1xuXG52YXIgZXh0cmFjdE5vZGVGaWVsZHMgPSAoZSwgciwgdCkgPT4ge1xuICBpZiAodm9pZCAwICE9PSB0KSB7XG4gICAgZm9yICh2YXIgYSBpbiB0KSB7XG4gICAgICBpZiAoIXIuaGFzKGEpKSB7XG4gICAgICAgIGUucHVzaChmaWVsZEluZm9PZktleShhKSk7XG4gICAgICAgIHIuYWRkKGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGV4dHJhY3ROb2RlTWFwRmllbGRzID0gKGUsIHIsIHQsIGEpID0+IHtcbiAgZXh0cmFjdE5vZGVGaWVsZHMoZSwgciwgYS5iYXNlLmdldCh0KSk7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdy5vcHRpbWlzdGljT3JkZXIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIG8gPSBhLm9wdGltaXN0aWMuZ2V0KHcub3B0aW1pc3RpY09yZGVyW2ldKTtcbiAgICBpZiAodm9pZCAwICE9PSBvKSB7XG4gICAgICBleHRyYWN0Tm9kZUZpZWxkcyhlLCByLCBvLmdldCh0KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZ2MgPSAoKSA9PiB7XG4gIGlmICh3Lm9wdGltaXN0aWNPcmRlci5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgZSBvZiB3LmdjLmtleXMoKSkge1xuICAgIHcuZ2MuZGVsZXRlKGUpO1xuICAgIGlmICgody5yZWZDb3VudC5nZXQoZSkgfHwgMCkgPiAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHIgPSB3LnJlY29yZHMuYmFzZS5nZXQoZSk7XG4gICAgdy5yZWZDb3VudC5kZWxldGUoZSk7XG4gICAgdy5yZWNvcmRzLmJhc2UuZGVsZXRlKGUpO1xuICAgIHZhciB0ID0gciAmJiByLl9fdHlwZW5hbWU7XG4gICAgaWYgKHQpIHtcbiAgICAgIHZhciBhID0gdy50eXBlcy5nZXQodCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBhLmRlbGV0ZShlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGkgPSB3LmxpbmtzLmJhc2UuZ2V0KGUpO1xuICAgIGlmIChpKSB7XG4gICAgICB3LmxpbmtzLmJhc2UuZGVsZXRlKGUpO1xuICAgICAgZm9yICh2YXIgbiBpbiBpKSB7XG4gICAgICAgIHVwZGF0ZVJDRm9yTGluayhpW25dLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgdXBkYXRlRGVwZW5kZW5jaWVzID0gKGUsIHIpID0+IHtcbiAgaWYgKGUgIT09IHcucXVlcnlSb290S2V5KSB7XG4gICAgeC5hZGQoZSk7XG4gIH0gZWxzZSBpZiAodm9pZCAwICE9PSByICYmIFwiX190eXBlbmFtZVwiICE9PSByKSB7XG4gICAgeC5hZGQoam9pbktleXMoZSwgcikpO1xuICB9XG59O1xuXG52YXIgdXBkYXRlUGVyc2lzdCA9IChlLCByKSA9PiB7XG4gIGlmICghSSAmJiB3LnN0b3JhZ2UpIHtcbiAgICB3LnBlcnNpc3QuYWRkKCgoZSwgcikgPT4gYCR7ZS5yZXBsYWNlKC9cXC4vZywgXCIlMmVcIil9LiR7cn1gKShlLCByKSk7XG4gIH1cbn07XG5cbnZhciByZWFkUmVjb3JkID0gKGUsIHIpID0+IHtcbiAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIpO1xuICByZXR1cm4gZ2V0Tm9kZSh3LnJlY29yZHMsIGUsIHIpO1xufTtcblxudmFyIHJlYWRMaW5rID0gKGUsIHIpID0+IHtcbiAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIpO1xuICByZXR1cm4gZ2V0Tm9kZSh3LmxpbmtzLCBlLCByKTtcbn07XG5cbnZhciB3cml0ZVJlY29yZCA9IChlLCByLCB0KSA9PiB7XG4gIHVwZGF0ZURlcGVuZGVuY2llcyhlLCByKTtcbiAgdXBkYXRlUGVyc2lzdChlLCByKTtcbiAgc2V0Tm9kZSh3LnJlY29yZHMsIGUsIHIsIHQpO1xufTtcblxudmFyIGhhc0ZpZWxkID0gKGUsIHIpID0+IHZvaWQgMCAhPT0gcmVhZFJlY29yZChlLCByKSB8fCB2b2lkIDAgIT09IHJlYWRMaW5rKGUsIHIpO1xuXG52YXIgd3JpdGVMaW5rID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGEgPSBiID8gdy5saW5rcy5vcHRpbWlzdGljLmdldChiKSA6IHcubGlua3MuYmFzZTtcbiAgaWYgKCFiKSB7XG4gICAgdmFyIGkgPSBhICYmIGEuZ2V0KGUpO1xuICAgIHVwZGF0ZVJDRm9yTGluayhpICYmIGlbcl0sIC0xKTtcbiAgICB1cGRhdGVSQ0ZvckxpbmsodCwgMSk7XG4gIH1cbiAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIpO1xuICB1cGRhdGVQZXJzaXN0KGUsIHIpO1xuICBzZXROb2RlKHcubGlua3MsIGUsIHIsIHQpO1xufTtcblxudmFyIHJlc2VydmVMYXllciA9IChlLCByLCB0KSA9PiB7XG4gIHZhciBhID0gZS5vcHRpbWlzdGljT3JkZXIuaW5kZXhPZihyKTtcbiAgaWYgKGEgPiAtMSkge1xuICAgIGUub3B0aW1pc3RpY09yZGVyLnNwbGljZShhLCAxKTtcbiAgfVxuICBpZiAodCkge1xuICAgIGUuZGVmZXJyZWRLZXlzLmFkZChyKTtcbiAgICBmb3IgKGEgPSBhID4gLTEgPyBhIDogMDsgYSA8IGUub3B0aW1pc3RpY09yZGVyLmxlbmd0aCAmJiAhZS5kZWZlcnJlZEtleXMuaGFzKGUub3B0aW1pc3RpY09yZGVyW2FdKSAmJiAoIWUuZGlydHlLZXlzLmhhcyhlLm9wdGltaXN0aWNPcmRlclthXSkgfHwgIWUuY29tbXV0YXRpdmVLZXlzLmhhcyhlLm9wdGltaXN0aWNPcmRlclthXSkpOyBhKyspIHt9XG4gIH0gZWxzZSB7XG4gICAgZS5kZWZlcnJlZEtleXMuZGVsZXRlKHIpO1xuICAgIGlmIChhID4gLTEgJiYgIWUuY29tbXV0YXRpdmVLZXlzLmhhcyhyKSkge1xuICAgICAgY2xlYXJMYXllcihlLCByKTtcbiAgICB9XG4gICAgYSA9IDA7XG4gIH1cbiAgZS5vcHRpbWlzdGljT3JkZXIuc3BsaWNlKGEsIDAsIHIpO1xuICBlLmNvbW11dGF0aXZlS2V5cy5hZGQocik7XG59O1xuXG52YXIgY3JlYXRlTGF5ZXIgPSAoZSwgcikgPT4ge1xuICBpZiAoLTEgPT09IGUub3B0aW1pc3RpY09yZGVyLmluZGV4T2YocikpIHtcbiAgICBlLm9wdGltaXN0aWNPcmRlci51bnNoaWZ0KHIpO1xuICB9XG4gIGlmICghZS5kaXJ0eUtleXMuaGFzKHIpKSB7XG4gICAgZS5kaXJ0eUtleXMuYWRkKHIpO1xuICAgIGUubGlua3Mub3B0aW1pc3RpYy5zZXQociwgbmV3IE1hcCk7XG4gICAgZS5yZWNvcmRzLm9wdGltaXN0aWMuc2V0KHIsIG5ldyBNYXApO1xuICB9XG59O1xuXG52YXIgY2xlYXJMYXllciA9IChlLCByKSA9PiB7XG4gIGlmIChlLmRpcnR5S2V5cy5oYXMocikpIHtcbiAgICBlLmRpcnR5S2V5cy5kZWxldGUocik7XG4gICAgZS5yZWNvcmRzLm9wdGltaXN0aWMuZGVsZXRlKHIpO1xuICAgIGUubGlua3Mub3B0aW1pc3RpYy5kZWxldGUocik7XG4gICAgZS5kZWZlcnJlZEtleXMuZGVsZXRlKHIpO1xuICB9XG59O1xuXG52YXIgZGVsZXRlTGF5ZXIgPSAoZSwgcikgPT4ge1xuICB2YXIgdCA9IGUub3B0aW1pc3RpY09yZGVyLmluZGV4T2Yocik7XG4gIGlmICh0ID4gLTEpIHtcbiAgICBlLm9wdGltaXN0aWNPcmRlci5zcGxpY2UodCwgMSk7XG4gICAgZS5jb21tdXRhdGl2ZUtleXMuZGVsZXRlKHIpO1xuICB9XG4gIGNsZWFyTGF5ZXIoZSwgcik7XG59O1xuXG52YXIgc3F1YXNoTGF5ZXIgPSBlID0+IHtcbiAgdmFyIHIgPSB4O1xuICB4ID0gbmV3IFNldDtcbiAgRCA9IFwid3JpdGVcIjtcbiAgdmFyIHQgPSB3LmxpbmtzLm9wdGltaXN0aWMuZ2V0KGUpO1xuICBpZiAodCkge1xuICAgIGZvciAodmFyIGEgb2YgdC5lbnRyaWVzKCkpIHtcbiAgICAgIHZhciBpID0gYVswXTtcbiAgICAgIHZhciBuID0gYVsxXTtcbiAgICAgIGZvciAodmFyIG8gaW4gbikge1xuICAgICAgICB3cml0ZUxpbmsoaSwgbywgbltvXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBzID0gdy5yZWNvcmRzLm9wdGltaXN0aWMuZ2V0KGUpO1xuICBpZiAocykge1xuICAgIGZvciAodmFyIGwgb2Ygcy5lbnRyaWVzKCkpIHtcbiAgICAgIHZhciB2ID0gbFswXTtcbiAgICAgIHZhciBkID0gbFsxXTtcbiAgICAgIGZvciAodmFyIHUgaW4gZCkge1xuICAgICAgICB3cml0ZVJlY29yZCh2LCB1LCBkW3VdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeCA9IHI7XG4gIGRlbGV0ZUxheWVyKHcsIGUpO1xufTtcblxudmFyIGluc3BlY3RGaWVsZHMgPSBlID0+IHtcbiAgdmFyIHtsaW5rczogciwgcmVjb3JkczogdH0gPSB3O1xuICB2YXIgYSA9IFtdO1xuICB2YXIgaSA9IG5ldyBTZXQ7XG4gIHVwZGF0ZURlcGVuZGVuY2llcyhlKTtcbiAgZXh0cmFjdE5vZGVNYXBGaWVsZHMoYSwgaSwgZSwgcik7XG4gIGV4dHJhY3ROb2RlTWFwRmllbGRzKGEsIGksIGUsIHQpO1xuICByZXR1cm4gYTtcbn07XG5cbnZhciBwZXJzaXN0RGF0YSA9ICgpID0+IHtcbiAgaWYgKHcuc3RvcmFnZSkge1xuICAgIEkgPSAhMDtcbiAgICBEID0gXCJyZWFkXCI7XG4gICAgdmFyIHIgPSB7fTtcbiAgICBmb3IgKHZhciB0IG9mIHcucGVyc2lzdC5rZXlzKCkpIHtcbiAgICAgIHZhciB7ZW50aXR5S2V5OiBhLCBmaWVsZEtleTogaX0gPSBkZXNlcmlhbGl6ZUtleUluZm8odCk7XG4gICAgICB2YXIgbiA9IHZvaWQgMDtcbiAgICAgIGlmICh2b2lkIDAgIT09IChuID0gcmVhZExpbmsoYSwgaSkpKSB7XG4gICAgICAgIHJbdF0gPSBgOiR7ZShuKX1gO1xuICAgICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IChuID0gcmVhZFJlY29yZChhLCBpKSkpIHtcbiAgICAgICAgclt0XSA9IGUobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByW3RdID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBJID0gITE7XG4gICAgdy5zdG9yYWdlLndyaXRlRGF0YShyKTtcbiAgICB3LnBlcnNpc3QuY2xlYXIoKTtcbiAgfVxufTtcblxudmFyIFMgPSBudWxsO1xuXG52YXIgVCA9ICExO1xuXG52YXIgQSA9IHZvaWQgMDtcblxudmFyIGdldEZpZWxkRXJyb3IgPSBlID0+IGUuX19pbnRlcm5hbC5wYXRoLmxlbmd0aCA+IDAgJiYgZS5fX2ludGVybmFsLmVycm9yTWFwID8gZS5fX2ludGVybmFsLmVycm9yTWFwW2UuX19pbnRlcm5hbC5wYXRoLmpvaW4oXCIuXCIpXSA6IHZvaWQgMDtcblxudmFyIG1ha2VDb250ZXh0ID0gKGUsIHIsIHQsIGEsIGksIG4pID0+IHtcbiAgdmFyIG8gPSB7XG4gICAgc3RvcmU6IGUsXG4gICAgdmFyaWFibGVzOiByLFxuICAgIGZyYWdtZW50czogdCxcbiAgICBwYXJlbnQ6IHtcbiAgICAgIF9fdHlwZW5hbWU6IGFcbiAgICB9LFxuICAgIHBhcmVudFR5cGVOYW1lOiBhLFxuICAgIHBhcmVudEtleTogaSxcbiAgICBwYXJlbnRGaWVsZEtleTogXCJcIixcbiAgICBmaWVsZE5hbWU6IFwiXCIsXG4gICAgZXJyb3I6IHZvaWQgMCxcbiAgICBwYXJ0aWFsOiAhMSxcbiAgICBoYXNOZXh0OiAhMSxcbiAgICBvcHRpbWlzdGljOiBJLFxuICAgIF9faW50ZXJuYWw6IHtcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgZXJyb3JNYXA6IHZvaWQgMFxuICAgIH1cbiAgfTtcbiAgaWYgKG4gJiYgbi5ncmFwaFFMRXJyb3JzKSB7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBuLmdyYXBoUUxFcnJvcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgIHZhciBsID0gbi5ncmFwaFFMRXJyb3JzW3NdO1xuICAgICAgaWYgKGwucGF0aCAmJiBsLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGlmICghby5fX2ludGVybmFsLmVycm9yTWFwKSB7XG4gICAgICAgICAgby5fX2ludGVybmFsLmVycm9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBvLl9faW50ZXJuYWwuZXJyb3JNYXBbbC5wYXRoLmpvaW4oXCIuXCIpXSA9IGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufTtcblxudmFyIHVwZGF0ZUNvbnRleHQgPSAoZSwgciwgdCwgYSwgaSwgbikgPT4ge1xuICBTID0gZTtcbiAgZS5wYXJlbnQgPSByO1xuICBlLnBhcmVudFR5cGVOYW1lID0gdDtcbiAgZS5wYXJlbnRLZXkgPSBhO1xuICBlLnBhcmVudEZpZWxkS2V5ID0gaTtcbiAgZS5maWVsZE5hbWUgPSBuO1xuICBlLmVycm9yID0gZ2V0RmllbGRFcnJvcihlKTtcbn07XG5cbnZhciBpc0ZyYWdtZW50SGV1cmlzdGljYWxseU1hdGNoaW5nID0gKGUsIHIsIHQsIGEsIGkpID0+IHtcbiAgaWYgKCFyKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBvID0gZ2V0VHlwZUNvbmRpdGlvbihlKTtcbiAgaWYgKCFvIHx8IHIgPT09IG8pIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJIZXVyaXN0aWMgRnJhZ21lbnQgTWF0Y2hpbmc6IEEgZnJhZ21lbnQgaXMgdHJ5aW5nIHRvIG1hdGNoIGFnYWluc3QgdGhlIGBcIiArIHIgKyBcImAgdHlwZSwgYnV0IHRoZSB0eXBlIGNvbmRpdGlvbiBpcyBgXCIgKyBvICsgXCJgLiBTaW5jZSBHcmFwaFFMIGFsbG93cyBmb3IgaW50ZXJmYWNlcyBgXCIgKyBvICsgXCJgIG1heSBiZSBhbiBpbnRlcmZhY2UuXFxuQSBzY2hlbWEgbmVlZHMgdG8gYmUgZGVmaW5lZCBmb3IgdGhpcyBtYXRjaCB0byBiZSBkZXRlcm1pbmlzdGljLCBvdGhlcndpc2UgdGhlIGZyYWdtZW50IHdpbGwgYmUgbWF0Y2hlZCBoZXVyaXN0aWNhbGx5IVwiLCAxNiwgaSk7XG4gIHJldHVybiBcIndyaXRlXCIgPT09IEQgfHwgIWdldFNlbGVjdGlvblNldChlKS5zb21lKChlID0+IHtcbiAgICBpZiAoZS5raW5kICE9PSBuLkZJRUxEKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHZhciByID0ga2V5T2ZGaWVsZChnZXROYW1lKGUpLCBnZXRGaWVsZEFyZ3VtZW50cyhlLCBhKSk7XG4gICAgcmV0dXJuICFoYXNGaWVsZCh0LCByKTtcbiAgfSkpO1xufTtcblxuZnVuY3Rpb24gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKGUsIHIsIHQsIGEsIGksIG8pIHtcbiAgdmFyIHM7XG4gIHZhciBsID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIHY7XG4gICAgd2hpbGUgKHMgfHwgbCA8IGkubGVuZ3RoKSB7XG4gICAgICB2ID0gdm9pZCAwO1xuICAgICAgVCA9IHQ7XG4gICAgICBBID0gYTtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGlmICh2ID0gcygpKSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICBwb3BEZWJ1Z05vZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gaVtsKytdO1xuICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUoZCwgby52YXJpYWJsZXMpKSB7fSBlbHNlIGlmIChkLmtpbmQgIT09IG4uRklFTEQpIHtcbiAgICAgICAgICB2YXIgdSA9IGQua2luZCAhPT0gbi5JTkxJTkVfRlJBR01FTlQgPyBvLmZyYWdtZW50c1tnZXROYW1lKGQpXSA6IGQ7XG4gICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgIGlmICghdS50eXBlQ29uZGl0aW9uIHx8IChvLnN0b3JlLnNjaGVtYSA/IGlzSW50ZXJmYWNlT2ZUeXBlKG8uc3RvcmUuc2NoZW1hLCB1LCBlKSA6IGlzRnJhZ21lbnRIZXVyaXN0aWNhbGx5TWF0Y2hpbmcodSwgZSwgciwgby52YXJpYWJsZXMsIG8uc3RvcmUubG9nZ2VyKSkpIHtcbiAgICAgICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgICAgIHB1c2hEZWJ1Z05vZGUoZSwgdSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGMgPSBpc09wdGlvbmFsKGQpO1xuICAgICAgICAgICAgICBzID0gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKGUsIHIsIHQgfHwgaXNEZWZlcnJlZChkLCBvLnZhcmlhYmxlcyksIHZvaWQgMCAhPT0gYyA/IGMgOiBhLCBnZXRTZWxlY3Rpb25TZXQodSksIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcIndyaXRlXCIgPT09IEQgfHwgIWQuX2dlbmVyYXRlZCkge1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZW5zdXJlRGF0YSA9IGUgPT4gbnVsbCA9PSBlID8gbnVsbCA6IGU7XG5cbnZhciBlbnN1cmVMaW5rID0gKGUsIHIpID0+IHtcbiAgaWYgKCFyKSB7XG4gICAgcmV0dXJuIHIgfHwgbnVsbDtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHIpKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGEgPSAwLCBpID0gdC5sZW5ndGg7IGEgPCBpOyBhKyspIHtcbiAgICAgIHRbYV0gPSBlbnN1cmVMaW5rKGUsIHJbYV0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICB2YXIgbiA9IGUua2V5T2ZFbnRpdHkocik7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoIW4gJiYgciAmJiBcIm9iamVjdFwiID09IHR5cGVvZiByKSB7XG4gICAgICB3YXJuKFwiQ2FuJ3QgZ2VuZXJhdGUgYSBrZXkgZm9yIGxpbmsoLi4uKSBpdGVtLlxcbllvdSBoYXZlIHRvIHBhc3MgYW4gYGlkYCBvciBgX2lkYCBmaWVsZCBvciBjcmVhdGUgYSBjdXN0b20gYGtleXNgIGNvbmZpZyBmb3IgYFwiICsgci5fX3R5cGVuYW1lICsgXCJgLlwiLCAxMiwgZS5sb2dnZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbnZhciBfcXVlcnkgPSAoZSwgdCwgYSwgaSkgPT4ge1xuICB2YXIgbiA9IHIodC5xdWVyeSk7XG4gIHZhciBvID0gZ2V0TWFpbk9wZXJhdGlvbihuKTtcbiAgdmFyIHMgPSBlLnJvb3RGaWVsZHNbby5vcGVyYXRpb25dO1xuICB2YXIgbCA9IGdldFNlbGVjdGlvblNldChvKTtcbiAgdmFyIHYgPSBtYWtlQ29udGV4dChlLCBub3JtYWxpemVWYXJpYWJsZXMobywgdC52YXJpYWJsZXMpLCBnZXRGcmFnbWVudHMobiksIHMsIHMsIGkpO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcHVzaERlYnVnTm9kZShzLCBvKTtcbiAgfVxuICB2YXIgZCA9IHMgIT09IHYuc3RvcmUucm9vdEZpZWxkcy5xdWVyeSA/IHJlYWRSb290KHYsIHMsIGwsIGEgfHwgbWFrZURhdGEoKSkgOiByZWFkU2VsZWN0aW9uKHYsIHMsIGwsIGEgfHwgbWFrZURhdGEoKSk7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBwb3BEZWJ1Z05vZGUoKTtcbiAgICBnZXRDdXJyZW50RGVwZW5kZW5jaWVzKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXBlbmRlbmNpZXM6IHgsXG4gICAgcGFydGlhbDogdi5wYXJ0aWFsIHx8ICFkLFxuICAgIGhhc05leHQ6IHYuaGFzTmV4dCxcbiAgICBkYXRhOiBkIHx8IG51bGxcbiAgfTtcbn07XG5cbnZhciByZWFkUm9vdCA9IChlLCByLCB0LCBhKSA9PiB7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiAoZS5zdG9yZS5yb290TmFtZXNbcl0gPyByIDogYS5fX3R5cGVuYW1lKSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBpID0gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKHIsIHIsICExLCB2b2lkIDAsIHQsIGUpO1xuICB2YXIgbjtcbiAgdmFyIG8gPSBWO1xuICB2YXIgcyA9IG1ha2VEYXRhKGEpO1xuICB3aGlsZSAobiA9IGkoKSkge1xuICAgIHZhciBsID0gZ2V0RmllbGRBbGlhcyhuKTtcbiAgICB2YXIgdiA9IGFbbF07XG4gICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChsKTtcbiAgICB2YXIgZCA9IHZvaWQgMDtcbiAgICBpZiAobi5zZWxlY3Rpb25TZXQgJiYgbnVsbCAhPT0gdikge1xuICAgICAgZCA9IHJlYWRSb290RmllbGQoZSwgZ2V0U2VsZWN0aW9uU2V0KG4pLCBlbnN1cmVEYXRhKHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHY7XG4gICAgfVxuICAgIG8gPSBvIHx8IGQgIT09IHY7XG4gICAgaWYgKHZvaWQgMCAhPT0gZCkge1xuICAgICAgc1tsXSA9IGQ7XG4gICAgfVxuICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICB9XG4gIHJldHVybiBvID8gcyA6IGE7XG59O1xuXG52YXIgcmVhZFJvb3RGaWVsZCA9IChlLCByLCB0KSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkodC5sZW5ndGgpO1xuICAgIHZhciBpID0gVjtcbiAgICBmb3IgKHZhciBuID0gMCwgbyA9IHQubGVuZ3RoOyBuIDwgbzsgbisrKSB7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wdXNoKG4pO1xuICAgICAgYVtuXSA9IHJlYWRSb290RmllbGQoZSwgciwgdFtuXSk7XG4gICAgICBpID0gaSB8fCBhW25dICE9PSB0W25dO1xuICAgICAgZS5fX2ludGVybmFsLnBhdGgucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBpID8gYSA6IHQ7XG4gIH0gZWxzZSBpZiAobnVsbCA9PT0gdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzID0gZS5zdG9yZS5rZXlPZkVudGl0eSh0KTtcbiAgaWYgKG51bGwgIT09IHMpIHtcbiAgICByZXR1cm4gcmVhZFNlbGVjdGlvbihlLCBzLCByLCB0KSB8fCBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWFkUm9vdChlLCB0Ll9fdHlwZW5hbWUsIHIsIHQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRGaWVsZFJlc29sdmVyKGUsIHIsIHQsIGEpIHtcbiAgdmFyIGkgPSBhLnN0b3JlLnJlc29sdmVyc1tyXTtcbiAgdmFyIG4gPSBpICYmIGlbdF07XG4gIHZhciBvO1xuICBmb3IgKHZhciBzIGluIGUpIHtcbiAgICB2YXIgbCA9IGVbc107XG4gICAgaWYgKGwgJiYgXCJpbmNsdWRlXCIgIT09IHMgJiYgXCJza2lwXCIgIT09IHMgJiYgYS5zdG9yZS5kaXJlY3RpdmVzW3NdKSB7XG4gICAgICBvID0gYS5zdG9yZS5kaXJlY3RpdmVzW3NdKGdldEZpZWxkQXJndW1lbnRzKGwsIGEudmFyaWFibGVzKSk7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgPT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAobiAmJiBvKSB7XG4gICAgICB3YXJuKGBBIHJlc29sdmVyIGFuZCBkaXJlY3RpdmUgaXMgYmVpbmcgdXNlZCBhdCBcIiR7cn0uJHt0fVwiIHNpbXVsdGFuZW91c2x5LiBPbmx5IHRoZSBkaXJlY3RpdmUgd2lsbCBhcHBseS5gLCAyOCwgYS5zdG9yZS5sb2dnZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbyB8fCBuO1xufVxuXG52YXIgcmVhZFNlbGVjdGlvbiA9IChlLCByLCB0LCBhLCBpKSA9PiB7XG4gIHZhciB7c3RvcmU6IG59ID0gZTtcbiAgdmFyIG8gPSByID09PSBuLnJvb3RGaWVsZHMucXVlcnk7XG4gIHZhciBzID0gaSAmJiBuLmtleU9mRW50aXR5KGkpIHx8IHI7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoIW8gJiYgZS5zdG9yZS5yb290TmFtZXNbc10pIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIHJvb3QgdHJhdmVyc2FsOiBBIHNlbGVjdGlvbiB3YXMgYmVpbmcgcmVhZCBvbiBgXCIgKyBzICsgXCJgIHdoaWNoIGlzIGFuIHVuY2FjaGVkIHJvb3QgdHlwZS5cXG5UaGUgYFwiICsgZS5zdG9yZS5yb290RmllbGRzLm11dGF0aW9uICsgXCJgIGFuZCBgXCIgKyBlLnN0b3JlLnJvb3RGaWVsZHMuc3Vic2NyaXB0aW9uICsgXCJgIHR5cGVzIGFyZSBzcGVjaWFsIE9wZXJhdGlvbiBSb290IFR5cGVzIGFuZCBjYW5ub3QgYmUgcmVhZCBiYWNrIGZyb20gdGhlIGNhY2hlLlwiLCAyNSwgbi5sb2dnZXIpO1xuICAgIH1cbiAgfVxuICB2YXIgbCA9ICFvID8gcmVhZFJlY29yZChzLCBcIl9fdHlwZW5hbWVcIikgfHwgaSAmJiBpLl9fdHlwZW5hbWUgOiByO1xuICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgbCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpICYmIGwgIT09IGkuX190eXBlbmFtZSkge1xuICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwiSW52YWxpZCByZXNvbHZlciBkYXRhOiBUaGUgcmVzb2x2ZXIgYXQgYFwiICsgcyArIFwiYCByZXR1cm5lZCBhbiBpbnZhbGlkIHR5cGVuYW1lIHRoYXQgY291bGQgbm90IGJlIHJlY29uY2lsZWQgd2l0aCB0aGUgY2FjaGUuXCIsIDgsIG4ubG9nZ2VyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHYgPSBtYWtlU2VsZWN0aW9uSXRlcmF0b3IobCwgcywgITEsIHZvaWQgMCwgdCwgZSk7XG4gIHZhciBkID0gITE7XG4gIHZhciB1ID0gITE7XG4gIHZhciBjID0gVjtcbiAgdmFyIHA7XG4gIHZhciBmID0gZS5wYXJ0aWFsO1xuICB2YXIgeSA9IG1ha2VEYXRhKGEpO1xuICB3aGlsZSAodm9pZCAwICE9PSAocCA9IHYoKSkpIHtcbiAgICB2YXIgaCA9IGdldE5hbWUocCk7XG4gICAgdmFyIG0gPSBnZXRGaWVsZEFyZ3VtZW50cyhwLCBlLnZhcmlhYmxlcyk7XG4gICAgdmFyIGcgPSBnZXRGaWVsZEFsaWFzKHApO1xuICAgIHZhciBfID0gZ2V0RGlyZWN0aXZlcyhwKTtcbiAgICB2YXIgTiA9IGdldEZpZWxkUmVzb2x2ZXIoXywgbCwgaCwgZSk7XG4gICAgdmFyIGsgPSBrZXlPZkZpZWxkKGgsIG0pO1xuICAgIHZhciBFID0gam9pbktleXMocywgayk7XG4gICAgdmFyIE8gPSByZWFkUmVjb3JkKHMsIGspO1xuICAgIHZhciB3ID0gaSA/IGlbaF0gOiB2b2lkIDA7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBuLnNjaGVtYSAmJiBsKSB7XG4gICAgICBpc0ZpZWxkQXZhaWxhYmxlT25UeXBlKG4uc2NoZW1hLCBsLCBoLCBlLnN0b3JlLmxvZ2dlcik7XG4gICAgfVxuICAgIGUuX19pbnRlcm5hbC5wYXRoLnB1c2goZyk7XG4gICAgdmFyIGIgPSB2b2lkIDA7XG4gICAgaWYgKFwiX190eXBlbmFtZVwiID09PSBoKSB7XG4gICAgICBiID0gbDtcbiAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gdyAmJiB2b2lkIDAgPT09IHAuc2VsZWN0aW9uU2V0KSB7XG4gICAgICBiID0gdztcbiAgICB9IGVsc2UgaWYgKFwicmVhZFwiID09PSBEICYmIE4pIHtcbiAgICAgIHZhciB4ID0geTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHAuc2VsZWN0aW9uU2V0ICYmIHZvaWQgMCAhPT0gTykge1xuICAgICAgICB4ID0ge1xuICAgICAgICAgIC4uLnksXG4gICAgICAgICAgW2ddOiBPLFxuICAgICAgICAgIFtoXTogT1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdXBkYXRlQ29udGV4dChlLCB4LCBsLCBzLCBrLCBoKTtcbiAgICAgIGIgPSBOKHgsIG0gfHwge30sIG4sIGUpO1xuICAgICAgaWYgKHAuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgIGIgPSByZXNvbHZlUmVzb2x2ZXJSZXN1bHQoZSwgbCwgaCwgRSwgZ2V0U2VsZWN0aW9uU2V0KHApLCB2b2lkIDAgIT09IHlbZ10gPyB5W2ddIDogYVtnXSwgYiwgb3duc0RhdGEoYSkpO1xuICAgICAgfVxuICAgICAgaWYgKG4uc2NoZW1hICYmIG51bGwgPT09IGIgJiYgIWlzRmllbGROdWxsYWJsZShuLnNjaGVtYSwgbCwgaCwgZS5zdG9yZS5sb2dnZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwLnNlbGVjdGlvblNldCkge1xuICAgICAgYiA9IE87XG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IHcpIHtcbiAgICAgIGIgPSByZXNvbHZlUmVzb2x2ZXJSZXN1bHQoZSwgbCwgaCwgRSwgZ2V0U2VsZWN0aW9uU2V0KHApLCB2b2lkIDAgIT09IHlbZ10gPyB5W2ddIDogYVtnXSwgdywgb3duc0RhdGEoYSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgSSA9IHJlYWRMaW5rKHMsIGspO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gSSkge1xuICAgICAgICBiID0gcmVzb2x2ZUxpbmsoZSwgSSwgbCwgaCwgZ2V0U2VsZWN0aW9uU2V0KHApLCB2b2lkIDAgIT09IHlbZ10gPyB5W2ddIDogYVtnXSwgb3duc0RhdGEoYSkpO1xuICAgICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBPICYmIG51bGwgIT09IE8pIHtcbiAgICAgICAgYiA9IE87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghVCAmJiB2b2lkIDAgPT09IGIgJiYgKF8ub3B0aW9uYWwgfHwgQSAmJiAhXy5yZXF1aXJlZCB8fCBnZXRGaWVsZEVycm9yKGUpIHx8IG4uc2NoZW1hICYmIGlzRmllbGROdWxsYWJsZShuLnNjaGVtYSwgbCwgaCwgZS5zdG9yZS5sb2dnZXIpKSkge1xuICAgICAgZS5wYXJ0aWFsID0gITA7XG4gICAgICBiID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG51bGwgPT09IGIgJiYgKF8ucmVxdWlyZWQgfHwgITEgPT09IEEpKSB7XG4gICAgICBpZiAoZS5zdG9yZS5sb2dnZXIgJiYgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIFwicmVhZFwiID09PSBEKSB7XG4gICAgICAgIGUuc3RvcmUubG9nZ2VyKFwiZGVidWdcIiwgYEdvdCB2YWx1ZSBcIm51bGxcIiBmb3IgcmVxdWlyZWQgZmllbGQgXCIke2h9XCIke20gPyBgIHdpdGggYXJncyAke0pTT04uc3RyaW5naWZ5KG0pfWAgOiBcIlwifSBvbiBlbnRpdHkgXCIke3N9XCJgKTtcbiAgICAgIH1cbiAgICAgIGIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBkIHx8IFwiX190eXBlbmFtZVwiICE9PSBoO1xuICAgIH1cbiAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgICBjID0gYyB8fCBiICE9PSBhW2ddO1xuICAgIGlmICh2b2lkIDAgIT09IGIpIHtcbiAgICAgIHlbZ10gPSBiO1xuICAgIH0gZWxzZSBpZiAoVCkge1xuICAgICAgdSA9ICEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZS5zdG9yZS5sb2dnZXIgJiYgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIFwicmVhZFwiID09PSBEKSB7XG4gICAgICAgIGUuc3RvcmUubG9nZ2VyKFwiZGVidWdcIiwgYE5vIHZhbHVlIGZvciBmaWVsZCBcIiR7aH1cIiR7bSA/IGAgd2l0aCBhcmdzICR7SlNPTi5zdHJpbmdpZnkobSl9YCA6IFwiXCJ9IG9uIGVudGl0eSBcIiR7c31cImApO1xuICAgICAgfVxuICAgICAgZS5wYXJ0aWFsID0gZjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZS5wYXJ0aWFsID0gZS5wYXJ0aWFsIHx8IGY7XG4gIGUuaGFzTmV4dCA9IGUuaGFzTmV4dCB8fCB1O1xuICByZXR1cm4gbyAmJiBlLnBhcnRpYWwgJiYgIWQgPyB2b2lkIDAgOiBjID8geSA6IGE7XG59O1xuXG52YXIgcmVzb2x2ZVJlc29sdmVyUmVzdWx0ID0gKGUsIHIsIHQsIGEsIGksIG4sIG8sIHMpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICB2YXIge3N0b3JlOiBsfSA9IGU7XG4gICAgdmFyIHYgPSBsLnNjaGVtYSA/IGlzTGlzdE51bGxhYmxlKGwuc2NoZW1hLCByLCB0LCBlLnN0b3JlLmxvZ2dlcikgOiAhMTtcbiAgICB2YXIgZCA9IGUucGFydGlhbDtcbiAgICB2YXIgdSA9IG1ha2VEYXRhKG4sICEwKTtcbiAgICB2YXIgYyA9IFYgfHwgIUFycmF5LmlzQXJyYXkobikgfHwgby5sZW5ndGggIT09IG4ubGVuZ3RoO1xuICAgIGZvciAodmFyIHAgPSAwLCBmID0gby5sZW5ndGg7IHAgPCBmOyBwKyspIHtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnB1c2gocCk7XG4gICAgICB2YXIgeSA9IHJlc29sdmVSZXNvbHZlclJlc3VsdChlLCByLCB0LCBqb2luS2V5cyhhLCBgJHtwfWApLCBpLCBudWxsICE9IG4gPyBuW3BdIDogdm9pZCAwLCBvW3BdLCBzKTtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0geSAmJiAhdikge1xuICAgICAgICBlLnBhcnRpYWwgPSBkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnBhcnRpYWwgPSBlLnBhcnRpYWwgfHwgdm9pZCAwID09PSB5ICYmIHY7XG4gICAgICAgIHVbcF0gPSBudWxsICE9IHkgPyB5IDogbnVsbDtcbiAgICAgICAgYyA9IGMgfHwgdVtwXSAhPT0gbltwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGMgPyB1IDogbjtcbiAgfSBlbHNlIGlmIChudWxsID09IG8pIHtcbiAgICByZXR1cm4gbztcbiAgfSBlbHNlIGlmIChzICYmIG51bGwgPT09IG4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChpc0RhdGFPcktleShvKSkge1xuICAgIHZhciBoID0gbiB8fCBtYWtlRGF0YShuKTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgbyA/IHJlYWRTZWxlY3Rpb24oZSwgbywgaSwgaCkgOiByZWFkU2VsZWN0aW9uKGUsIGEsIGksIGgsIG8pO1xuICB9IGVsc2Uge1xuICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwiSW52YWxpZCByZXNvbHZlciB2YWx1ZTogVGhlIGZpZWxkIGF0IGBcIiArIGEgKyBcImAgaXMgYSBzY2FsYXIgKG51bWJlciwgYm9vbGVhbiwgZXRjKSwgYnV0IHRoZSBHcmFwaFFMIHF1ZXJ5IGV4cGVjdHMgYSBzZWxlY3Rpb24gc2V0IGZvciB0aGlzIGZpZWxkLlwiLCA5LCBlLnN0b3JlLmxvZ2dlcik7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG52YXIgcmVzb2x2ZUxpbmsgPSAoZSwgciwgdCwgYSwgaSwgbiwgbykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkge1xuICAgIHZhciB7c3RvcmU6IHN9ID0gZTtcbiAgICB2YXIgbCA9IHMuc2NoZW1hID8gaXNMaXN0TnVsbGFibGUocy5zY2hlbWEsIHQsIGEsIGUuc3RvcmUubG9nZ2VyKSA6ICExO1xuICAgIHZhciB2ID0gbWFrZURhdGEobiwgITApO1xuICAgIHZhciBkID0gZS5wYXJ0aWFsO1xuICAgIHZhciB1ID0gViB8fCAhQXJyYXkuaXNBcnJheShuKSB8fCByLmxlbmd0aCAhPT0gbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgYyA9IDAsIHAgPSByLmxlbmd0aDsgYyA8IHA7IGMrKykge1xuICAgICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChjKTtcbiAgICAgIHZhciBmID0gcmVzb2x2ZUxpbmsoZSwgcltjXSwgdCwgYSwgaSwgbnVsbCAhPSBuID8gbltjXSA6IHZvaWQgMCwgbyk7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGYgJiYgIWwpIHtcbiAgICAgICAgZS5wYXJ0aWFsID0gZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5wYXJ0aWFsID0gZS5wYXJ0aWFsIHx8IHZvaWQgMCA9PT0gZiAmJiBsO1xuICAgICAgICB2W2NdID0gZiB8fCBudWxsO1xuICAgICAgICB1ID0gdSB8fCB2W2NdICE9PSBuW2NdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdSA/IHYgOiBuO1xuICB9IGVsc2UgaWYgKG51bGwgPT09IHIgfHwgbnVsbCA9PT0gbiAmJiBvKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlYWRTZWxlY3Rpb24oZSwgciwgaSwgbiB8fCBtYWtlRGF0YShuKSk7XG59O1xuXG52YXIgaXNEYXRhT3JLZXkgPSBlID0+IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgfHwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlLl9fdHlwZW5hbWU7XG5cbnZhciBfd3JpdGUgPSAoZSwgdCwgYSwgaSkgPT4ge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgZ2V0Q3VycmVudERlcGVuZGVuY2llcygpO1xuICB9XG4gIHZhciBuID0gcih0LnF1ZXJ5KTtcbiAgdmFyIG8gPSBnZXRNYWluT3BlcmF0aW9uKG4pO1xuICB2YXIgcyA9IHtcbiAgICBkYXRhOiBhIHx8IG1ha2VEYXRhKCksXG4gICAgZGVwZW5kZW5jaWVzOiB4XG4gIH07XG4gIHZhciBsID0gZS5yb290RmllbGRzW28ub3BlcmF0aW9uXTtcbiAgdmFyIHYgPSBtYWtlQ29udGV4dChlLCBub3JtYWxpemVWYXJpYWJsZXMobywgdC52YXJpYWJsZXMpLCBnZXRGcmFnbWVudHMobiksIGwsIGwsIGkpO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcHVzaERlYnVnTm9kZShsLCBvKTtcbiAgfVxuICB3cml0ZVNlbGVjdGlvbih2LCBsLCBnZXRTZWxlY3Rpb25TZXQobyksIHMuZGF0YSk7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBwb3BEZWJ1Z05vZGUoKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbnZhciB3cml0ZVNlbGVjdGlvbiA9IChlLCByLCB0LCBhKSA9PiB7XG4gIHZhciBpID0gZS5zdG9yZS5yb290TmFtZXNbcl0gfHwgXCJxdWVyeVwiO1xuICB2YXIgbiA9ICEhZS5zdG9yZS5yb290TmFtZXNbcl07XG4gIHZhciBvID0gbiA/IHIgOiBhLl9fdHlwZW5hbWU7XG4gIGlmICghbyAmJiByICYmIGUub3B0aW1pc3RpYykge1xuICAgIG8gPSByZWFkUmVjb3JkKHIsIFwiX190eXBlbmFtZVwiKTtcbiAgfVxuICBpZiAoIW8pIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihcIkNvdWxkbid0IGZpbmQgX190eXBlbmFtZSB3aGVuIHdyaXRpbmcuXFxuSWYgeW91J3JlIHdyaXRpbmcgdG8gdGhlIGNhY2hlIG1hbnVhbGx5IGhhdmUgdG8gcGFzcyBhIGBfX3R5cGVuYW1lYCBwcm9wZXJ0eSBvbiBlYWNoIGVudGl0eSBpbiB5b3VyIGRhdGEuXCIsIDE0LCBlLnN0b3JlLmxvZ2dlcik7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCFuICYmIHIpIHtcbiAgICB3cml0ZVJlY29yZChyLCBcIl9fdHlwZW5hbWVcIiwgbyk7XG4gICAgKChlLCByKSA9PiB7XG4gICAgICB2YXIgdCA9IHcudHlwZXMuZ2V0KGUpO1xuICAgICAgaWYgKCF0KSB7XG4gICAgICAgIHZhciBhID0gbmV3IFNldDtcbiAgICAgICAgYS5hZGQocik7XG4gICAgICAgIHcudHlwZXMuc2V0KGUsIGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdC5hZGQocik7XG4gICAgICB9XG4gICAgfSkobywgcik7XG4gIH1cbiAgdmFyIHMgPSBlLnN0b3JlLnVwZGF0ZXNbb107XG4gIHZhciBsID0gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKG8sIHIgfHwgbywgITEsIHZvaWQgMCwgdCwgZSk7XG4gIHZhciB2O1xuICB3aGlsZSAodiA9IGwoKSkge1xuICAgIHZhciBkID0gZ2V0TmFtZSh2KTtcbiAgICB2YXIgdSA9IGdldEZpZWxkQXJndW1lbnRzKHYsIGUudmFyaWFibGVzKTtcbiAgICB2YXIgYyA9IGtleU9mRmllbGQoZCwgdSk7XG4gICAgdmFyIHAgPSBnZXRGaWVsZEFsaWFzKHYpO1xuICAgIHZhciBmID0gYVtlLm9wdGltaXN0aWMgPyBkIDogcF07XG4gICAgaWYgKFwiX190eXBlbmFtZVwiID09PSBkIHx8IHZvaWQgMCA9PT0gZiAmJiAoVCB8fCBlLm9wdGltaXN0aWMgJiYgXCJxdWVyeVwiID09PSBpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmIChlLnN0b3JlLnNjaGVtYSAmJiBvICYmIFwiX190eXBlbmFtZVwiICE9PSBkKSB7XG4gICAgICAgIGlzRmllbGRBdmFpbGFibGVPblR5cGUoZS5zdG9yZS5zY2hlbWEsIG8sIGQsIGUuc3RvcmUubG9nZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChwKTtcbiAgICB2YXIgeSA9IHZvaWQgMDtcbiAgICBpZiAoZS5vcHRpbWlzdGljICYmIFwibXV0YXRpb25cIiA9PT0gaSkge1xuICAgICAgaWYgKCEoeSA9IGUuc3RvcmUub3B0aW1pc3RpY011dGF0aW9uc1tkXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLm9wdGltaXN0aWMgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBmKSB7XG4gICAgICB5ID0gZjtcbiAgICB9XG4gICAgaWYgKHkpIHtcbiAgICAgIHVwZGF0ZUNvbnRleHQoZSwgYSwgbywgciB8fCBvLCBjLCBkKTtcbiAgICAgIGYgPSBlbnN1cmVEYXRhKHkodSB8fCB7fSwgZS5zdG9yZSwgZSkpO1xuICAgIH1cbiAgICBpZiAodm9pZCAwID09PSBmKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGlmICghciB8fCAhaGFzRmllbGQociwgYykgfHwgZS5vcHRpbWlzdGljICYmICFyZWFkUmVjb3JkKHIsIFwiX190eXBlbmFtZVwiKSkge1xuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwiSW52YWxpZCB1bmRlZmluZWQ6IFRoZSBmaWVsZCBhdCBgXCIgKyBjICsgXCJgIGlzIGB1bmRlZmluZWRgLCBidXQgdGhlIEdyYXBoUUwgcXVlcnkgZXhwZWN0cyBhIFwiICsgKHZvaWQgMCA9PT0gdi5zZWxlY3Rpb25TZXQgPyBcInNjYWxhciAobnVtYmVyLCBib29sZWFuLCBldGMpXCIgOiBcInNlbGVjdGlvbiBzZXRcIikgKyBcIiBmb3IgdGhpcyBmaWVsZC5cIiwgMTMsIGUuc3RvcmUubG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2LnNlbGVjdGlvblNldCkge1xuICAgICAgaWYgKHIgJiYgXCJxdWVyeVwiID09PSBpKSB7XG4gICAgICAgIHZhciBoID0gam9pbktleXMociwgYyk7XG4gICAgICAgIHZhciBtID0gd3JpdGVGaWVsZChlLCBnZXRTZWxlY3Rpb25TZXQodiksIGVuc3VyZURhdGEoZiksIGgsIGUub3B0aW1pc3RpYyA/IHJlYWRMaW5rKHIgfHwgbywgYykgOiB2b2lkIDApO1xuICAgICAgICB3cml0ZUxpbmsociB8fCBvLCBjLCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmllbGQoZSwgZ2V0U2VsZWN0aW9uU2V0KHYpLCBlbnN1cmVEYXRhKGYpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHIgJiYgXCJxdWVyeVwiID09PSBpKSB7XG4gICAgICB3cml0ZVJlY29yZChyIHx8IG8sIGMsIG51bGwgIT09IGYgfHwgIWdldEZpZWxkRXJyb3IoZSkgPyBmIDogdm9pZCAwKTtcbiAgICB9XG4gICAgdmFyIGcgPSBzICYmIHNbZF07XG4gICAgaWYgKGcpIHtcbiAgICAgIHVwZGF0ZUNvbnRleHQoZSwgYSwgbywgciB8fCBvLCBjLCBkKTtcbiAgICAgIGFbZF0gPSBmO1xuICAgICAgZyhhLCB1IHx8IHt9LCBlLnN0b3JlLCBlKTtcbiAgICB9XG4gICAgZS5fX2ludGVybmFsLnBhdGgucG9wKCk7XG4gIH1cbn07XG5cbnZhciBLID0gL15fX3xQYWdlSW5mb3woQ29ubmVjdGlvbnxFZGdlKSQvO1xuXG52YXIgd3JpdGVGaWVsZCA9IChlLCByLCB0LCBhLCBpKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgdmFyIG4gPSBuZXcgQXJyYXkodC5sZW5ndGgpO1xuICAgIGZvciAodmFyIG8gPSAwLCBzID0gdC5sZW5ndGg7IG8gPCBzOyBvKyspIHtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnB1c2gobyk7XG4gICAgICB2YXIgbCA9IGEgPyBqb2luS2V5cyhhLCBgJHtvfWApIDogdm9pZCAwO1xuICAgICAgdmFyIHYgPSB3cml0ZUZpZWxkKGUsIHIsIHRbb10sIGwsIG51bGwgIT0gaSA/IGlbb10gOiB2b2lkIDApO1xuICAgICAgbltvXSA9IHY7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0gZWxzZSBpZiAobnVsbCA9PT0gdCkge1xuICAgIHJldHVybiBnZXRGaWVsZEVycm9yKGUpID8gdm9pZCAwIDogbnVsbDtcbiAgfVxuICB2YXIgZCA9IGUuc3RvcmUua2V5T2ZFbnRpdHkodCkgfHwgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGkgPyBpIDogbnVsbCk7XG4gIHZhciB1ID0gdC5fX3R5cGVuYW1lO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGEgJiYgIWUuc3RvcmUua2V5c1t0Ll9fdHlwZW5hbWVdICYmIG51bGwgPT09IGQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdSAmJiAhSy50ZXN0KHUpKSB7XG4gICAgICB3YXJuKFwiSW52YWxpZCBrZXk6IFRoZSBHcmFwaFFMIHF1ZXJ5IGF0IHRoZSBmaWVsZCBhdCBgXCIgKyBhICsgXCJgIGhhcyBhIHNlbGVjdGlvbiBzZXQsIGJ1dCBubyBrZXkgY291bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgZGF0YSBhdCB0aGlzIGZpZWxkLlxcbllvdSBoYXZlIHRvIHJlcXVlc3QgYGlkYCBvciBgX2lkYCBmaWVsZHMgZm9yIGFsbCBzZWxlY3Rpb24gc2V0cyBvciBjcmVhdGUgYSBjdXN0b20gYGtleXNgIGNvbmZpZyBmb3IgYFwiICsgdSArIFwiYC5cXG5FbnRpdGllcyB3aXRob3V0IGtleXMgd2lsbCBiZSBlbWJlZGRlZCBkaXJlY3RseSBvbiB0aGUgcGFyZW50IGVudGl0eS4gSWYgdGhpcyBpcyBpbnRlbnRpb25hbCwgY3JlYXRlIGEgYGtleXNgIGNvbmZpZyBmb3IgYFwiICsgdSArIFwiYCB0aGF0IGFsd2F5cyByZXR1cm5zIG51bGwuXCIsIDE1LCBlLnN0b3JlLmxvZ2dlcik7XG4gICAgfVxuICB9XG4gIHZhciBjID0gZCB8fCBhO1xuICB3cml0ZVNlbGVjdGlvbihlLCBjLCByLCB0KTtcbiAgcmV0dXJuIGMgfHwgbnVsbDtcbn07XG5cbnZhciBpbnZhbGlkYXRlRW50aXR5ID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGEgPSByID8gWyB7XG4gICAgZmllbGRLZXk6IGtleU9mRmllbGQociwgdClcbiAgfSBdIDogaW5zcGVjdEZpZWxkcyhlKTtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIHZhciB7ZmllbGRLZXk6IG99ID0gYVtpXTtcbiAgICBpZiAodm9pZCAwICE9PSByZWFkTGluayhlLCBvKSkge1xuICAgICAgd3JpdGVMaW5rKGUsIG8sIHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlUmVjb3JkKGUsIG8sIHZvaWQgMCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaW52YWxpZGF0ZVR5cGUgPSBlID0+IHtcbiAgdmFyIHIgPSAoZSA9PiB3LnR5cGVzLmdldChlKSB8fCBxKShlKTtcbiAgZm9yICh2YXIgdCBvZiByKSB7XG4gICAgaW52YWxpZGF0ZUVudGl0eSh0KTtcbiAgfVxufTtcblxuY2xhc3MgU3RvcmUge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBlID0ge307XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gZS5sb2dnZXI7XG4gICAgdGhpcy5yZXNvbHZlcnMgPSBlLnJlc29sdmVycyB8fCB7fTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBlLmRpcmVjdGl2ZXMgfHwge307XG4gICAgdGhpcy5vcHRpbWlzdGljTXV0YXRpb25zID0gZS5vcHRpbWlzdGljIHx8IHt9O1xuICAgIHRoaXMua2V5cyA9IGUua2V5cyB8fCB7fTtcbiAgICB0aGlzLmdsb2JhbElEcyA9IEFycmF5LmlzQXJyYXkoZS5nbG9iYWxJRHMpID8gbmV3IFNldChlLmdsb2JhbElEcykgOiAhIWUuZ2xvYmFsSURzO1xuICAgIHZhciByID0gXCJRdWVyeVwiO1xuICAgIHZhciB0ID0gXCJNdXRhdGlvblwiO1xuICAgIHZhciBhID0gXCJTdWJzY3JpcHRpb25cIjtcbiAgICBpZiAoZS5zY2hlbWEpIHtcbiAgICAgIHZhciBpID0gKCh7X19zY2hlbWE6IGV9KSA9PiB7XG4gICAgICAgIHZhciByID0gbmV3IE1hcDtcbiAgICAgICAgdmFyIGJ1aWxkTmFtZU1hcCA9IGUgPT4ge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgciA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICByW2VbdF0ubmFtZV0gPSBlW3RdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYnVpbGRUeXBlID0gZSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChlLmtpbmQpIHtcbiAgICAgICAgICAgY2FzZSBcIk9CSkVDVFwiOlxuICAgICAgICAgICBjYXNlIFwiSU5URVJGQUNFXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6IGUua2luZCxcbiAgICAgICAgICAgICAgaW50ZXJmYWNlczogYnVpbGROYW1lTWFwKGUuaW50ZXJmYWNlcyB8fCBbXSksXG4gICAgICAgICAgICAgIGZpZWxkczogYnVpbGROYW1lTWFwKGUuZmllbGRzLm1hcCgoZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgICAgICAgICAgYXJnczogYnVpbGROYW1lTWFwKGUuYXJncylcbiAgICAgICAgICAgICAgfSkpKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgY2FzZSBcIlVOSU9OXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6IGUua2luZCxcbiAgICAgICAgICAgICAgdHlwZXM6IGJ1aWxkTmFtZU1hcChlLnBvc3NpYmxlVHlwZXMgfHwgW10pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgcXVlcnk6IGUucXVlcnlUeXBlID8gZS5xdWVyeVR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgbXV0YXRpb246IGUubXV0YXRpb25UeXBlID8gZS5tdXRhdGlvblR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiBlLnN1YnNjcmlwdGlvblR5cGUgPyBlLnN1YnNjcmlwdGlvblR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgdHlwZXM6IHZvaWQgMCxcbiAgICAgICAgICBpc1N1YlR5cGUoZSwgdCkge1xuICAgICAgICAgICAgdmFyIGEgPSByLmdldChlKTtcbiAgICAgICAgICAgIHZhciBpID0gci5nZXQodCk7XG4gICAgICAgICAgICBpZiAoIWEgfHwgIWkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcIlVOSU9OXCIgPT09IGEua2luZCkge1xuICAgICAgICAgICAgICByZXR1cm4gISFhLnR5cGVzKClbdF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiT0JKRUNUXCIgIT09IGEua2luZCAmJiBcIk9CSkVDVFwiID09PSBpLmtpbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICEhaS5pbnRlcmZhY2VzKClbZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChlLnR5cGVzKSB7XG4gICAgICAgICAgdC50eXBlcyA9IHI7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlLnR5cGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGUudHlwZXNbYV07XG4gICAgICAgICAgICBpZiAoaSAmJiBpLm5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBidWlsZFR5cGUoaSk7XG4gICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgci5zZXQoaS5uYW1lLCBuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0pKGUuc2NoZW1hKTtcbiAgICAgIHIgPSBpLnF1ZXJ5IHx8IHI7XG4gICAgICB0ID0gaS5tdXRhdGlvbiB8fCB0O1xuICAgICAgYSA9IGkuc3Vic2NyaXB0aW9uIHx8IGE7XG4gICAgICBpZiAoaS50eXBlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlcyA9IGUudXBkYXRlcyB8fCB7fTtcbiAgICB0aGlzLnJvb3RGaWVsZHMgPSB7XG4gICAgICBxdWVyeTogcixcbiAgICAgIG11dGF0aW9uOiB0LFxuICAgICAgc3Vic2NyaXB0aW9uOiBhXG4gICAgfTtcbiAgICB0aGlzLnJvb3ROYW1lcyA9IHtcbiAgICAgIFtyXTogXCJxdWVyeVwiLFxuICAgICAgW3RdOiBcIm11dGF0aW9uXCIsXG4gICAgICBbYV06IFwic3Vic2NyaXB0aW9uXCJcbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IChuID0gciwge1xuICAgICAgaHlkcmF0aW5nOiAhMSxcbiAgICAgIGRlZmVyOiAhMSxcbiAgICAgIGdjOiBuZXcgU2V0LFxuICAgICAgdHlwZXM6IG5ldyBNYXAsXG4gICAgICBwZXJzaXN0OiBuZXcgU2V0LFxuICAgICAgcXVlcnlSb290S2V5OiBuLFxuICAgICAgcmVmQ291bnQ6IG5ldyBNYXAsXG4gICAgICBsaW5rczoge1xuICAgICAgICBvcHRpbWlzdGljOiBuZXcgTWFwLFxuICAgICAgICBiYXNlOiBuZXcgTWFwXG4gICAgICB9LFxuICAgICAgcmVjb3Jkczoge1xuICAgICAgICBvcHRpbWlzdGljOiBuZXcgTWFwLFxuICAgICAgICBiYXNlOiBuZXcgTWFwXG4gICAgICB9LFxuICAgICAgZGVmZXJyZWRLZXlzOiBuZXcgU2V0LFxuICAgICAgY29tbXV0YXRpdmVLZXlzOiBuZXcgU2V0LFxuICAgICAgZGlydHlLZXlzOiBuZXcgU2V0LFxuICAgICAgb3B0aW1pc3RpY09yZGVyOiBbXSxcbiAgICAgIHN0b3JhZ2U6IG51bGxcbiAgICB9KTtcbiAgICB2YXIgbjtcbiAgICBpZiAodGhpcy5zY2hlbWEgJiYgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRLZXlpbmdDb25maWcoZSwgciwgdCkge1xuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSBpbiByKSB7XG4gICAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAgIGlmICghZS50eXBlcy5oYXMoYSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiSW52YWxpZCBPYmplY3QgdHlwZTogVGhlIHR5cGUgYFwiICsgYSArIFwiYCBpcyBub3QgYW4gb2JqZWN0IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBga2V5c2Agb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LlwiLCAyMCwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5zY2hlbWEsIHRoaXMua2V5cywgdGhpcy5sb2dnZXIpO1xuICAgICAgIWZ1bmN0aW9uIGV4cGVjdFZhbGlkVXBkYXRlc0NvbmZpZyhlLCByLCB0KSB7XG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiA9PT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYSBpbiByKSB7XG4gICAgICAgICAgaWYgKCFyW2FdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFlLnR5cGVzLmhhcyhhKSkge1xuICAgICAgICAgICAgdmFyIGkgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKFwiTXV0YXRpb25cIiA9PT0gYSAmJiBlLm11dGF0aW9uICYmIFwiTXV0YXRpb25cIiAhPT0gZS5tdXRhdGlvbikge1xuICAgICAgICAgICAgICBpICs9IFwiXFxuTWF5YmUgeW91ciBjb25maWcgc2hvdWxkIHJlZmVyZW5jZSBgXCIgKyBlLm11dGF0aW9uICsgXCJgP1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcIlN1YnNjcmlwdGlvblwiID09PSBhICYmIGUuc3Vic2NyaXB0aW9uICYmIFwiU3Vic2NyaXB0aW9uXCIgIT09IGUuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIGkgKz0gXCJcXG5NYXliZSB5b3VyIGNvbmZpZyBzaG91bGQgcmVmZXJlbmNlIGBcIiArIGUuc3Vic2NyaXB0aW9uICsgXCJgP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm4oXCJJbnZhbGlkIHVwZGF0ZXMgdHlwZTogVGhlIHR5cGUgYFwiICsgYSArIFwiYCBpcyBub3QgYW4gb2JqZWN0IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBgdXBkYXRlc2AgY29uZmlnIGlzIHJlZmVyZW5jaW5nIGl0LlwiICsgaSwgMjEsIHQpIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbiA9IGUudHlwZXMuZ2V0KGEpLmZpZWxkcygpO1xuICAgICAgICAgIGZvciAodmFyIG8gaW4gclthXSkge1xuICAgICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgICBpZiAoIW5bb10pIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiSW52YWxpZCB1cGRhdGVzIGZpZWxkOiBgXCIgKyBvICsgXCJgIG9uIGBcIiArIGEgKyBcImAgaXMgbm90IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBgdXBkYXRlc2AgY29uZmlnIGlzIHJlZmVyZW5jaW5nIGl0LlwiLCAyMiwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5zY2hlbWEsIHRoaXMudXBkYXRlcywgdGhpcy5sb2dnZXIpO1xuICAgICAgIWZ1bmN0aW9uIGV4cGVjdFZhbGlkUmVzb2x2ZXJzQ29uZmlnKGUsIHIsIHQpIHtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBhIGluIHIpIHtcbiAgICAgICAgICBpZiAoXCJRdWVyeVwiID09PSBhKSB7XG4gICAgICAgICAgICBpZiAoZS5xdWVyeSkge1xuICAgICAgICAgICAgICB2YXIgaSA9IGUudHlwZXMuZ2V0KGUucXVlcnkpLmZpZWxkcygpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIHIuUXVlcnkgfHwge30pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlbbl0pIHtcbiAgICAgICAgICAgICAgICAgIHdhcm5BYm91dFJlc29sdmVyKFwiUXVlcnkuXCIgKyBuLCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5BYm91dFJlc29sdmVyKFwiUXVlcnlcIiwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghZS50eXBlcy5oYXMoYSkpIHtcbiAgICAgICAgICAgIHdhcm5BYm91dFJlc29sdmVyKGEsIHQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJJTlRFUkZBQ0VcIiA9PT0gZS50eXBlcy5nZXQoYSkua2luZCB8fCBcIlVOSU9OXCIgPT09IGUudHlwZXMuZ2V0KGEpLmtpbmQpIHtcbiAgICAgICAgICAgIHdhcm5BYm91dEFic3RyYWN0UmVzb2x2ZXIoYSwgZS50eXBlcy5nZXQoYSkua2luZCwgdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvID0gZS50eXBlcy5nZXQoYSkuZmllbGRzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHJbYV0gfHwge30pIHtcbiAgICAgICAgICAgICAgaWYgKCFvW3NdKSB7XG4gICAgICAgICAgICAgICAgd2FybkFib3V0UmVzb2x2ZXIoYSArIFwiLlwiICsgcywgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5zY2hlbWEsIHRoaXMucmVzb2x2ZXJzLCB0aGlzLmxvZ2dlcik7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRPcHRpbWlzdGljTXV0YXRpb25zQ29uZmlnKGUsIHIsIHQpIHtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5tdXRhdGlvbikge1xuICAgICAgICAgIHZhciBhID0gZS50eXBlcy5nZXQoZS5tdXRhdGlvbikuZmllbGRzKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiByKSB7XG4gICAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAgIGlmICghYVtpXSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgb3B0aW1pc3RpYyBtdXRhdGlvbiBmaWVsZDogXFxgJHtpfVxcYCBpcyBub3QgYSBtdXRhdGlvbiBmaWVsZCBpbiB0aGUgZGVmaW5lZCBzY2hlbWEsIGJ1dCB0aGUgXFxgb3B0aW1pc3RpY1xcYCBvcHRpb24gaXMgcmVmZXJlbmNpbmcgaXQuYCwgMjQsIHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KHRoaXMuc2NoZW1hLCB0aGlzLm9wdGltaXN0aWNNdXRhdGlvbnMsIHRoaXMubG9nZ2VyKTtcbiAgICB9XG4gIH1cbiAga2V5T2ZGaWVsZChlLCByKSB7XG4gICAgcmV0dXJuIGtleU9mRmllbGQoZSwgcik7XG4gIH1cbiAga2V5T2ZFbnRpdHkoZSkge1xuICAgIGlmIChTICYmIGUgPT09IFMucGFyZW50KSB7XG4gICAgICByZXR1cm4gUy5wYXJlbnRLZXk7XG4gICAgfSBlbHNlIGlmIChudWxsID09IGUgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgICAgcmV0dXJuIGUgfHwgbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFlLl9fdHlwZW5hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yb290TmFtZXNbZS5fX3R5cGVuYW1lXSkge1xuICAgICAgcmV0dXJuIGUuX190eXBlbmFtZTtcbiAgICB9XG4gICAgdmFyIHIgPSBudWxsO1xuICAgIGlmICh0aGlzLmtleXNbZS5fX3R5cGVuYW1lXSkge1xuICAgICAgciA9IHRoaXMua2V5c1tlLl9fdHlwZW5hbWVdKGUpIHx8IG51bGw7XG4gICAgfSBlbHNlIGlmIChudWxsICE9IGUuaWQpIHtcbiAgICAgIHIgPSBgJHtlLmlkfWA7XG4gICAgfSBlbHNlIGlmIChudWxsICE9IGUuX2lkKSB7XG4gICAgICByID0gYCR7ZS5faWR9YDtcbiAgICB9XG4gICAgdmFyIHQgPSBlLl9fdHlwZW5hbWU7XG4gICAgcmV0dXJuICEwID09PSB0aGlzLmdsb2JhbElEcyB8fCB0aGlzLmdsb2JhbElEcyAmJiB0aGlzLmdsb2JhbElEcy5oYXModCkgfHwgIXIgPyByIDogYCR7dH06JHtyfWA7XG4gIH1cbiAgcmVzb2x2ZShlLCByLCB0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmtleU9mRW50aXR5KGUpO1xuICAgIGlmIChhKSB7XG4gICAgICB2YXIgaSA9IGtleU9mRmllbGQociwgdCk7XG4gICAgICB2YXIgbiA9IHJlYWRSZWNvcmQoYSwgaSk7XG4gICAgICBpZiAodm9pZCAwICE9PSBuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgdmFyIG8gPSByZWFkTGluayhhLCBpKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IG8pIHtcbiAgICAgICAgbyA9IGVuc3VyZUxpbmsodGhpcywgbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUZpZWxkQnlLZXkoZSwgciwgdCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoZSwgciwgdCk7XG4gIH1cbiAgaW52YWxpZGF0ZShlLCByLCB0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmtleU9mRW50aXR5KGUpO1xuICAgIGlmIChlICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgIXIgJiYgIXQgJiYgIXRoaXMucmVzb2x2ZShlLCBcIl9fdHlwZW5hbWVcIikpIHtcbiAgICAgIGludmFsaWRhdGVUeXBlKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoYSwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gXCJDYW4ndCBnZW5lcmF0ZSBhIGtleSBmb3IgaW52YWxpZGF0ZSguLi4pLlxcbllvdSBoYXZlIHRvIHBhc3MgYW4gaWQgb3IgX2lkIGZpZWxkIG9yIGNyZWF0ZSBhIGN1c3RvbSBga2V5c2AgZmllbGQgZm9yIGBcIiArIChcIm9iamVjdFwiID09IHR5cGVvZiBlID8gZS5fX3R5cGVuYW1lIDogZSArIFwiYC5cIikgOiBcIlwiLCAxOSk7XG4gICAgICBpbnZhbGlkYXRlRW50aXR5KGEsIHIsIHQpO1xuICAgIH1cbiAgfVxuICBpbnNwZWN0RmllbGRzKGUpIHtcbiAgICB2YXIgciA9IHRoaXMua2V5T2ZFbnRpdHkoZSk7XG4gICAgcmV0dXJuIHIgPyBpbnNwZWN0RmllbGRzKHIpIDogW107XG4gIH1cbiAgdXBkYXRlUXVlcnkoZSwgcikge1xuICAgIHZhciBhID0gdChlLnF1ZXJ5LCBlLnZhcmlhYmxlcyk7XG4gICAgdmFyIGkgPSByKHRoaXMucmVhZFF1ZXJ5KGEpKTtcbiAgICBpZiAobnVsbCAhPT0gaSkge1xuICAgICAgX3dyaXRlKHRoaXMsIGEsIGksIHZvaWQgMCk7XG4gICAgfVxuICB9XG4gIHJlYWRRdWVyeShlKSB7XG4gICAgdmFyIHIgPSB0KGUucXVlcnksIGUudmFyaWFibGVzKTtcbiAgICByZXR1cm4gX3F1ZXJ5KHRoaXMsIHIsIHZvaWQgMCwgdm9pZCAwKS5kYXRhO1xuICB9XG4gIHJlYWRGcmFnbWVudChlLCB0LCBhLCBpKSB7XG4gICAgcmV0dXJuICgoZSwgciwgdCwgYSwgaSkgPT4ge1xuICAgICAgdmFyIG4gPSBnZXRGcmFnbWVudHMocik7XG4gICAgICB2YXIgbztcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGlmICghKG8gPSBuW2ldKSkge1xuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwicmVhZEZyYWdtZW50KC4uLikgd2FzIGNhbGxlZCB3aXRoIGEgZnJhZ21lbnQgbmFtZSB0aGF0IGRvZXMgbm90IGV4aXN0LlxcbllvdSBwcm92aWRlZCBcIiArIGkgKyBcIiBidXQgY291bGQgb25seSBmaW5kIFwiICsgT2JqZWN0LmtleXMobikuam9pbihcIiwgXCIpICsgXCIuXCIsIDYsIGUubG9nZ2VyKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKG8gPSBuW09iamVjdC5rZXlzKG4pWzBdXSkpIHtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJyZWFkRnJhZ21lbnQoLi4uKSB3YXMgY2FsbGVkIHdpdGggYW4gZW1wdHkgZnJhZ21lbnQuXFxuWW91IGhhdmUgdG8gY2FsbCBpdCB3aXRoIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBpbiB5b3VyIEdyYXBoUUwgZG9jdW1lbnQuXCIsIDYsIGUubG9nZ2VyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IGdldEZyYWdtZW50VHlwZU5hbWUobyk7XG4gICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCAmJiAhdC5fX3R5cGVuYW1lKSB7XG4gICAgICAgIHQuX190eXBlbmFtZSA9IHM7XG4gICAgICB9XG4gICAgICB2YXIgbCA9IGUua2V5T2ZFbnRpdHkodCk7XG4gICAgICBpZiAoIWwpIHtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJDYW4ndCBnZW5lcmF0ZSBhIGtleSBmb3IgcmVhZEZyYWdtZW50KC4uLikuXFxuWW91IGhhdmUgdG8gcGFzcyBhbiBgaWRgIG9yIGBfaWRgIGZpZWxkIG9yIGNyZWF0ZSBhIGN1c3RvbSBga2V5c2AgY29uZmlnIGZvciBgXCIgKyBzICsgXCJgLlwiLCA3LCBlLmxvZ2dlcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBwdXNoRGVidWdOb2RlKHMsIG8pO1xuICAgICAgfVxuICAgICAgdmFyIHYgPSBtYWtlQ29udGV4dChlLCBhIHx8IHt9LCBuLCBzLCBsLCB2b2lkIDApO1xuICAgICAgdmFyIGQgPSByZWFkU2VsZWN0aW9uKHYsIGwsIGdldFNlbGVjdGlvblNldChvKSwgbWFrZURhdGEoKSkgfHwgbnVsbDtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgcG9wRGVidWdOb2RlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgICB9KSh0aGlzLCByKGUpLCB0LCBhLCBpKTtcbiAgfVxuICB3cml0ZUZyYWdtZW50KGUsIHQsIGEsIGkpIHtcbiAgICAoKGUsIHIsIHQsIGEsIGkpID0+IHtcbiAgICAgIHZhciBuID0gZ2V0RnJhZ21lbnRzKHIpO1xuICAgICAgdmFyIG87XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAoIShvID0gbltpXSkpIHtcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihcIndyaXRlRnJhZ21lbnQoLi4uKSB3YXMgY2FsbGVkIHdpdGggYSBmcmFnbWVudCBuYW1lIHRoYXQgZG9lcyBub3QgZXhpc3QuXFxuWW91IHByb3ZpZGVkIFwiICsgaSArIFwiIGJ1dCBjb3VsZCBvbmx5IGZpbmQgXCIgKyBPYmplY3Qua2V5cyhuKS5qb2luKFwiLCBcIikgKyBcIi5cIiwgMTEsIGUubG9nZ2VyKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKG8gPSBuW09iamVjdC5rZXlzKG4pWzBdXSkpIHtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJ3cml0ZUZyYWdtZW50KC4uLikgd2FzIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGZyYWdtZW50LlxcbllvdSBoYXZlIHRvIGNhbGwgaXQgd2l0aCBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgaW4geW91ciBHcmFwaFFMIGRvY3VtZW50LlwiLCAxMSwgZS5sb2dnZXIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gZ2V0RnJhZ21lbnRUeXBlTmFtZShvKTtcbiAgICAgIHZhciBsID0ge1xuICAgICAgICBfX3R5cGVuYW1lOiBzLFxuICAgICAgICAuLi50XG4gICAgICB9O1xuICAgICAgdmFyIHYgPSBlLmtleU9mRW50aXR5KGwpO1xuICAgICAgaWYgKCF2KSB7XG4gICAgICAgIHJldHVybiBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuKFwiQ2FuJ3QgZ2VuZXJhdGUgYSBrZXkgZm9yIHdyaXRlRnJhZ21lbnQoLi4uKSBkYXRhLlxcbllvdSBoYXZlIHRvIHBhc3MgYW4gYGlkYCBvciBgX2lkYCBmaWVsZCBvciBjcmVhdGUgYSBjdXN0b20gYGtleXNgIGNvbmZpZyBmb3IgYFwiICsgcyArIFwiYC5cIiwgMTIsIGUubG9nZ2VyKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgcHVzaERlYnVnTm9kZShzLCBvKTtcbiAgICAgIH1cbiAgICAgIHZhciBkID0gbWFrZUNvbnRleHQoZSwgYSB8fCB7fSwgbiwgcywgdiwgdm9pZCAwKTtcbiAgICAgIHdyaXRlU2VsZWN0aW9uKGQsIHYsIGdldFNlbGVjdGlvblNldChvKSwgbCk7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHBvcERlYnVnTm9kZSgpO1xuICAgICAgfVxuICAgIH0pKHRoaXMsIHIoZSksIHQsIGEsIGkpO1xuICB9XG4gIGxpbmsoZSwgciwgLi4udCkge1xuICAgIHZhciBhID0gMiA9PT0gdC5sZW5ndGggPyB0WzBdIDogbnVsbDtcbiAgICB2YXIgaSA9IDIgPT09IHQubGVuZ3RoID8gdFsxXSA6IHRbMF07XG4gICAgdmFyIG4gPSB0aGlzLmtleU9mRW50aXR5KGUpO1xuICAgIGlmIChuKSB7XG4gICAgICB3cml0ZUxpbmsobiwga2V5T2ZGaWVsZChyLCBhKSwgZW5zdXJlTGluayh0aGlzLCBpKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhZGRNZXRhZGF0YSA9IChlLCByKSA9PiBhKGUua2luZCwgZSwge1xuICAuLi5lLmNvbnRleHQsXG4gIG1ldGE6IHtcbiAgICAuLi5lLmNvbnRleHQubWV0YSxcbiAgICAuLi5yXG4gIH1cbn0pO1xuXG52YXIgdG9SZXF1ZXN0UG9saWN5ID0gKGUsIHIpID0+IGEoZS5raW5kLCBlLCB7XG4gIC4uLmUuY29udGV4dCxcbiAgcmVxdWVzdFBvbGljeTogclxufSk7XG5cbnZhciBjYWNoZUV4Y2hhbmdlID0gZSA9PiAoe2ZvcndhcmQ6IHQsIGNsaWVudDogaSwgZGlzcGF0Y2hEZWJ1Zzogbn0pID0+IHtcbiAgdmFyIG8gPSBuZXcgU3RvcmUoZSk7XG4gIGlmIChlICYmIGUuc3RvcmFnZSkge1xuICAgIG8uZGF0YS5oeWRyYXRpbmcgPSAhMDtcbiAgICBlLnN0b3JhZ2UucmVhZERhdGEoKS50aGVuKChyID0+IHtcbiAgICAgICgoZSwgciwgdCkgPT4ge1xuICAgICAgICBpbml0RGF0YVN0YXRlKFwid3JpdGVcIiwgZSwgbnVsbCk7XG4gICAgICAgIGZvciAodmFyIGEgaW4gdCkge1xuICAgICAgICAgIHZhciBpID0gdFthXTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBpKSB7XG4gICAgICAgICAgICB2YXIge2VudGl0eUtleTogbiwgZmllbGRLZXk6IG99ID0gZGVzZXJpYWxpemVLZXlJbmZvKGEpO1xuICAgICAgICAgICAgaWYgKFwiOlwiID09PSBpWzBdKSB7XG4gICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHJlYWRMaW5rKG4sIG8pKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVMaW5rKG4sIG8sIEpTT04ucGFyc2UoaS5zbGljZSgxKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCA9PT0gcmVhZFJlY29yZChuLCBvKSkge1xuICAgICAgICAgICAgICB3cml0ZVJlY29yZChuLCBvLCBKU09OLnBhcnNlKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9yYWdlID0gcjtcbiAgICAgICAgZS5oeWRyYXRpbmcgPSAhMTtcbiAgICAgICAgY2xlYXJEYXRhU3RhdGUoKTtcbiAgICAgIH0pKG8uZGF0YSwgZS5zdG9yYWdlLCByKTtcbiAgICAgIGlmIChlLnN0b3JhZ2Uub25DYWNoZUh5ZHJhdGVkKSB7XG4gICAgICAgIGUuc3RvcmFnZS5vbkNhY2hlSHlkcmF0ZWQoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgdmFyIGYgPSBuZXcgTWFwO1xuICB2YXIgeSA9IFtdO1xuICB2YXIgaCA9IG5ldyBNYXA7XG4gIHZhciBtID0gbmV3IE1hcDtcbiAgdmFyIGcgPSBuZXcgU2V0O1xuICB2YXIgXyA9IG5ldyBTZXQ7XG4gIHZhciBOID0gbmV3IE1hcDtcbiAgdmFyIGsgPSBuZXcgU2V0O1xuICB2YXIgRSA9IG5ldyBTZXQ7XG4gIHZhciBpc0Jsb2NrZWRCeU9wdGltaXN0aWNVcGRhdGUgPSBlID0+IHtcbiAgICBmb3IgKHZhciByIG9mIGUudmFsdWVzKCkpIHtcbiAgICAgIGlmIChnLmhhcyhyKSkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfTtcbiAgdmFyIGNvbGxlY3RQZW5kaW5nT3BlcmF0aW9ucyA9IChlLCByKSA9PiB7XG4gICAgaWYgKHIpIHtcbiAgICAgIGZvciAodmFyIHQgb2Ygci52YWx1ZXMoKSkge1xuICAgICAgICB2YXIgYSA9IE4uZ2V0KHQpO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgIGZvciAodmFyIGkgb2YgYS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZS5hZGQoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZXhlY3V0ZVBlbmRpbmdPcGVyYXRpb25zID0gKGUsIHIsIHQpID0+IHtcbiAgICBmb3IgKHZhciBhIG9mIHIudmFsdWVzKCkpIHtcbiAgICAgIGlmIChhICE9PSBlLmtleSkge1xuICAgICAgICB2YXIgbiA9IGguZ2V0KGEpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIGlmIChcInF1ZXJ5XCIgPT09IGUua2luZCkge1xuICAgICAgICAgICAgRS5hZGQoYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvID0gXCJjYWNoZS1maXJzdFwiO1xuICAgICAgICAgIGlmIChfLmhhcyhhKSkge1xuICAgICAgICAgICAgXy5kZWxldGUoYSk7XG4gICAgICAgICAgICBvID0gXCJjYWNoZS1hbmQtbmV0d29ya1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpLnJlZXhlY3V0ZU9wZXJhdGlvbih0b1JlcXVlc3RQb2xpY3kobiwgbykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdCkge1xuICAgICAgdmFyIHMgPSBrO1xuICAgICAgaWYgKFwicXVlcnlcIiA9PT0gZS5raW5kKSB7XG4gICAgICAgIChrID0gRSkuYWRkKGUua2V5KTtcbiAgICAgIH1cbiAgICAgIChFID0gcykuY2xlYXIoKTtcbiAgICB9XG4gIH07XG4gIHZhciBwcmVwYXJlRm9yd2FyZGVkT3BlcmF0aW9uID0gZSA9PiB7XG4gICAgdmFyIHQgPSAhMTtcbiAgICBpZiAoXCJxdWVyeVwiID09PSBlLmtpbmQpIHtcbiAgICAgIHJlc2VydmVMYXllcihvLmRhdGEsIGUua2V5KTtcbiAgICAgIGguc2V0KGUua2V5LCBlKTtcbiAgICB9IGVsc2UgaWYgKFwidGVhcmRvd25cIiA9PT0gZS5raW5kKSB7XG4gICAgICBoLmRlbGV0ZShlLmtleSk7XG4gICAgICBtLmRlbGV0ZShlLmtleSk7XG4gICAgICBrLmRlbGV0ZShlLmtleSk7XG4gICAgICBub29wRGF0YVN0YXRlKG8uZGF0YSwgZS5rZXkpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSBlbHNlIGlmIChcIm11dGF0aW9uXCIgPT09IGUua2luZCAmJiBcIm5ldHdvcmstb25seVwiICE9PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSkge1xuICAgICAgaC5zZXQoZS5rZXksIGUpO1xuICAgICAgaW5pdERhdGFTdGF0ZShcIndyaXRlXCIsIG8uZGF0YSwgZS5rZXksICEwLCAhMSk7XG4gICAgICB2YXIge2RlcGVuZGVuY2llczogaX0gPSBfd3JpdGUobywgZSwgdm9pZCAwLCB2b2lkIDApO1xuICAgICAgY2xlYXJEYXRhU3RhdGUoKTtcbiAgICAgIGlmIChpLnNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgbiBvZiBpLnZhbHVlcygpKSB7XG4gICAgICAgICAgZy5hZGQobik7XG4gICAgICAgIH1cbiAgICAgICAgZi5zZXQoZS5rZXksIGkpO1xuICAgICAgICB2YXIgcyA9IG5ldyBTZXQ7XG4gICAgICAgIGNvbGxlY3RQZW5kaW5nT3BlcmF0aW9ucyhzLCBpKTtcbiAgICAgICAgZXhlY3V0ZVBlbmRpbmdPcGVyYXRpb25zKGUsIHMsICEwKTtcbiAgICAgICAgdCA9ICEwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYShlLmtpbmQsIHtcbiAgICAgIGtleTogZS5rZXksXG4gICAgICBxdWVyeTogcihlLnF1ZXJ5KSxcbiAgICAgIHZhcmlhYmxlczogZS52YXJpYWJsZXMgPyBmaWx0ZXJWYXJpYWJsZXMoZ2V0TWFpbk9wZXJhdGlvbihlLnF1ZXJ5KSwgZS52YXJpYWJsZXMpIDogZS52YXJpYWJsZXNcbiAgICB9LCB7XG4gICAgICAuLi5lLmNvbnRleHQsXG4gICAgICBvcHRpbWlzdGljOiB0XG4gICAgfSk7XG4gIH07XG4gIHZhciB1cGRhdGVEZXBlbmRlbmNpZXMgPSAoZSwgcikgPT4ge1xuICAgIGZvciAodmFyIHQgb2Ygci52YWx1ZXMoKSkge1xuICAgICAgdmFyIGEgPSBOLmdldCh0KTtcbiAgICAgIGlmICghYSkge1xuICAgICAgICBOLnNldCh0LCBhID0gbmV3IFNldCk7XG4gICAgICB9XG4gICAgICBhLmFkZChlLmtleSk7XG4gICAgfVxuICB9O1xuICB2YXIgb3BlcmF0aW9uUmVzdWx0RnJvbUNhY2hlID0gZSA9PiB7XG4gICAgaW5pdERhdGFTdGF0ZShcInJlYWRcIiwgby5kYXRhLCB2b2lkIDAsICExLCAhMSk7XG4gICAgdmFyIHIgPSBfcXVlcnkobywgZSwgbS5nZXQoZS5rZXkpLCB2b2lkIDApO1xuICAgIGNsZWFyRGF0YVN0YXRlKCk7XG4gICAgdmFyIHQgPSByLmRhdGEgPyAhci5wYXJ0aWFsICYmICFyLmhhc05leHQgPyBcImhpdFwiIDogXCJwYXJ0aWFsXCIgOiBcIm1pc3NcIjtcbiAgICBtLnNldChlLmtleSwgci5kYXRhKTtcbiAgICBoLnNldChlLmtleSwgZSk7XG4gICAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIuZGVwZW5kZW5jaWVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0Y29tZTogdCxcbiAgICAgIG9wZXJhdGlvbjogZSxcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIGRlcGVuZGVuY2llczogci5kZXBlbmRlbmNpZXMsXG4gICAgICBoYXNOZXh0OiByLmhhc05leHRcbiAgICB9O1xuICB9O1xuICB2YXIgdXBkYXRlQ2FjaGVXaXRoUmVzdWx0ID0gKGUsIHIpID0+IHtcbiAgICB2YXIgdCA9IGguZ2V0KGUub3BlcmF0aW9uLmtleSkgfHwgZS5vcGVyYXRpb247XG4gICAgaWYgKFwibXV0YXRpb25cIiA9PT0gdC5raW5kKSB7XG4gICAgICB2YXIgYSA9IGYuZ2V0KHQua2V5KTtcbiAgICAgIGNvbGxlY3RQZW5kaW5nT3BlcmF0aW9ucyhyLCBhKTtcbiAgICAgIGYuZGVsZXRlKHQua2V5KTtcbiAgICB9XG4gICAgaWYgKFwic3Vic2NyaXB0aW9uXCIgPT09IHQua2luZCB8fCBlLmhhc05leHQpIHtcbiAgICAgIHJlc2VydmVMYXllcihvLmRhdGEsIHQua2V5LCAhMCk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBuID0gZS5kYXRhO1xuICAgIGlmIChuKSB7XG4gICAgICBpbml0RGF0YVN0YXRlKFwid3JpdGVcIiwgby5kYXRhLCB0LmtleSwgITEsICExKTtcbiAgICAgIHZhciBzID0gX3dyaXRlKG8sIHQsIG4sIGUuZXJyb3IpLmRlcGVuZGVuY2llcztcbiAgICAgIGNsZWFyRGF0YVN0YXRlKCk7XG4gICAgICBjb2xsZWN0UGVuZGluZ09wZXJhdGlvbnMociwgcyk7XG4gICAgICB2YXIgbCA9IFwicXVlcnlcIiA9PT0gdC5raW5kID8gbS5nZXQodC5rZXkpIDogbnVsbDtcbiAgICAgIGluaXREYXRhU3RhdGUoXCJyZWFkXCIsIG8uZGF0YSwgdC5rZXksICExLCBsICE9PSBuKTtcbiAgICAgIHZhciB2ID0gX3F1ZXJ5KG8sIHQsIGwgfHwgbiwgZS5lcnJvcik7XG4gICAgICBjbGVhckRhdGFTdGF0ZSgpO1xuICAgICAgbiA9IHYuZGF0YTtcbiAgICAgIGlmIChcInF1ZXJ5XCIgPT09IHQua2luZCkge1xuICAgICAgICBjb2xsZWN0UGVuZGluZ09wZXJhdGlvbnMociwgaSA9IHYuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgbS5zZXQodC5rZXksIG4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub29wRGF0YVN0YXRlKG8uZGF0YSwgdC5rZXkpO1xuICAgIH1cbiAgICBpZiAoaSkge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKGUub3BlcmF0aW9uLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdGlvbjogdCxcbiAgICAgIGRhdGE6IG4sXG4gICAgICBlcnJvcjogZS5lcnJvcixcbiAgICAgIGV4dGVuc2lvbnM6IGUuZXh0ZW5zaW9ucyxcbiAgICAgIGhhc05leHQ6IGUuaGFzTmV4dCxcbiAgICAgIHN0YWxlOiBlLnN0YWxlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGUgPT4ge1xuICAgIHZhciByID0gcyhsKG9wZXJhdGlvblJlc3VsdEZyb21DYWNoZSkodigoZSA9PiBcInF1ZXJ5XCIgPT09IGUua2luZCAmJiBcIm5ldHdvcmstb25seVwiICE9PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSkpKGUpKSk7XG4gICAgdmFyIGEgPSB2KChlID0+IFwicXVlcnlcIiAhPT0gZS5raW5kIHx8IFwibmV0d29yay1vbmx5XCIgPT09IGUuY29udGV4dC5yZXF1ZXN0UG9saWN5KSkoZSk7XG4gICAgdmFyIG0gPSBsKChlID0+IHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBuKHtcbiAgICAgICAgdHlwZTogXCJjYWNoZU1pc3NcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGUgcmVzdWx0IGNvdWxkIG5vdCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGVcIixcbiAgICAgICAgb3BlcmF0aW9uOiBlLm9wZXJhdGlvbixcbiAgICAgICAgc291cmNlOiBcImNhY2hlRXhjaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gYWRkTWV0YWRhdGEoZS5vcGVyYXRpb24sIHtcbiAgICAgICAgY2FjaGVPdXRjb21lOiBcIm1pc3NcIlxuICAgICAgfSkgOiBlLm9wZXJhdGlvbjtcbiAgICB9KSkodigoZSA9PiBcIm1pc3NcIiA9PT0gZS5vdXRjb21lICYmIFwiY2FjaGUtb25seVwiICE9PSBlLm9wZXJhdGlvbi5jb250ZXh0LnJlcXVlc3RQb2xpY3kgJiYgIWlzQmxvY2tlZEJ5T3B0aW1pc3RpY1VwZGF0ZShlLmRlcGVuZGVuY2llcykgJiYgIWsuaGFzKGUub3BlcmF0aW9uLmtleSkpKShyKSk7XG4gICAgdmFyIE4gPSBsKChlID0+IHtcbiAgICAgIHZhciB7cmVxdWVzdFBvbGljeTogcn0gPSBlLm9wZXJhdGlvbi5jb250ZXh0O1xuICAgICAgdmFyIHQgPSBcImNhY2hlLW9ubHlcIiAhPT0gciAmJiAoZS5oYXNOZXh0IHx8IFwiY2FjaGUtYW5kLW5ldHdvcmtcIiA9PT0gciB8fCBcImNhY2hlLWZpcnN0XCIgPT09IHIgJiYgXCJwYXJ0aWFsXCIgPT09IGUub3V0Y29tZSAmJiAhay5oYXMoZS5vcGVyYXRpb24ua2V5KSk7XG4gICAgICB2YXIgYSA9IFwiY2FjaGUtb25seVwiICE9PSByICYmICh0IHx8IFwicGFydGlhbFwiID09PSBlLm91dGNvbWUgJiYgay5oYXMoZS5vcGVyYXRpb24ua2V5KSAmJiAoKHMgPSBvLmRhdGEpLmNvbW11dGF0aXZlS2V5cy5oYXMobCA9IGUub3BlcmF0aW9uLmtleSkgfHwgcy5vcHRpbWlzdGljT3JkZXIuaW5kZXhPZihsKSA+IC0xKSk7XG4gICAgICB2YXIgcywgbDtcbiAgICAgIHZhciB2ID0ge1xuICAgICAgICBvcGVyYXRpb246IFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGFkZE1ldGFkYXRhKGUub3BlcmF0aW9uLCB7XG4gICAgICAgICAgY2FjaGVPdXRjb21lOiBlLm91dGNvbWVcbiAgICAgICAgfSkgOiBlLm9wZXJhdGlvbixcbiAgICAgICAgZGF0YTogZS5kYXRhLFxuICAgICAgICBlcnJvcjogZS5lcnJvcixcbiAgICAgICAgZXh0ZW5zaW9uczogZS5leHRlbnNpb25zLFxuICAgICAgICBzdGFsZTogYSAmJiAhZS5oYXNOZXh0LFxuICAgICAgICBoYXNOZXh0OiB0ICYmIGUuaGFzTmV4dFxuICAgICAgfTtcbiAgICAgIGlmICghdCkge30gZWxzZSBpZiAoIWlzQmxvY2tlZEJ5T3B0aW1pc3RpY1VwZGF0ZShlLmRlcGVuZGVuY2llcykpIHtcbiAgICAgICAgaS5yZWV4ZWN1dGVPcGVyYXRpb24odG9SZXF1ZXN0UG9saWN5KGguZ2V0KGUub3BlcmF0aW9uLmtleSkgfHwgZS5vcGVyYXRpb24sIFwibmV0d29yay1vbmx5XCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoXCJjYWNoZS1hbmQtbmV0d29ya1wiID09PSByKSB7XG4gICAgICAgIF8uYWRkKGUub3BlcmF0aW9uLmtleSk7XG4gICAgICB9XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgbih7XG4gICAgICAgIHR5cGU6IFwiY2FjaGVIaXRcIixcbiAgICAgICAgbWVzc2FnZTogXCJBIHJlcXVlc3RlZCBvcGVyYXRpb24gd2FzIGZvdW5kIGFuZCByZXR1cm5lZCBmcm9tIHRoZSBjYWNoZS5cIixcbiAgICAgICAgb3BlcmF0aW9uOiBlLm9wZXJhdGlvbixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZTogXCJjYWNoZUV4Y2hhbmdlXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSkpKHYoKGUgPT4gXCJtaXNzXCIgIT09IGUub3V0Y29tZSB8fCBcImNhY2hlLW9ubHlcIiA9PT0gZS5vcGVyYXRpb24uY29udGV4dC5yZXF1ZXN0UG9saWN5KSkocikpO1xuICAgIHZhciBFID0gdChsKHByZXBhcmVGb3J3YXJkZWRPcGVyYXRpb24pKGQoWyBhLCBtIF0pKSk7XG4gICAgdmFyIE8gPSBsKChlID0+IHtcbiAgICAgIHZhciByID0gbmV3IFNldDtcbiAgICAgIHZhciB0ID0gdXBkYXRlQ2FjaGVXaXRoUmVzdWx0KGUsIHIpO1xuICAgICAgZXhlY3V0ZVBlbmRpbmdPcGVyYXRpb25zKGUub3BlcmF0aW9uLCByLCAhMSk7XG4gICAgICByZXR1cm4gdDtcbiAgICB9KSkodigoZSA9PiAhZi5oYXMoZS5vcGVyYXRpb24ua2V5KSkpKEUpKTtcbiAgICB2YXIgdyA9IHUoKGUgPT4ge1xuICAgICAgaWYgKHkucHVzaChlKSA8IGYuc2l6ZSkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgeS5sZW5ndGg7IHIrKykge1xuICAgICAgICByZXNlcnZlTGF5ZXIoby5kYXRhLCB5W3JdLm9wZXJhdGlvbi5rZXkpO1xuICAgICAgfVxuICAgICAgZy5jbGVhcigpO1xuICAgICAgdmFyIHQgPSBbXTtcbiAgICAgIHZhciBhID0gbmV3IFNldDtcbiAgICAgIHZhciBpO1xuICAgICAgd2hpbGUgKGkgPSB5LnNoaWZ0KCkpIHtcbiAgICAgICAgdC5wdXNoKHVwZGF0ZUNhY2hlV2l0aFJlc3VsdChpLCBhKSk7XG4gICAgICB9XG4gICAgICBleGVjdXRlUGVuZGluZ09wZXJhdGlvbnMoZS5vcGVyYXRpb24sIGEsICExKTtcbiAgICAgIHJldHVybiBwKHQpO1xuICAgIH0pKSh2KChlID0+IGYuaGFzKGUub3BlcmF0aW9uLmtleSkpKShFKSk7XG4gICAgcmV0dXJuIGQoWyBPLCB3LCBOIF0pO1xuICB9O1xufTtcblxudmFyIE0gPSB7XG4gIFwiY2FjaGUtb25seVwiOiAwLFxuICBcImNhY2hlLWZpcnN0XCI6IDEsXG4gIFwibmV0d29yay1vbmx5XCI6IDIsXG4gIFwiY2FjaGUtYW5kLW5ldHdvcmtcIjogM1xufTtcblxudmFyIG9mZmxpbmVFeGNoYW5nZSA9IGUgPT4gciA9PiB7XG4gIHZhciB7c3RvcmFnZTogbn0gPSBlO1xuICB2YXIgbyA9IGUuaXNPZmZsaW5lRXJyb3IgfHwgKGUgPT4gZSAmJiBlLm5ldHdvcmtFcnJvciAmJiAhZS5yZXNwb25zZSAmJiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbmF2aWdhdG9yICYmICExID09PSBuYXZpZ2F0b3Iub25MaW5lIHx8IC9yZXF1ZXN0IGZhaWxlZHxmYWlsZWQgdG8gZmV0Y2h8bmV0d29ya1xccz9lcnJvci9pLnRlc3QoZS5uZXR3b3JrRXJyb3IubWVzc2FnZSkpKTtcbiAgaWYgKG4gJiYgbi5vbk9ubGluZSAmJiBuLnJlYWRNZXRhZGF0YSAmJiBuLndyaXRlTWV0YWRhdGEpIHtcbiAgICB2YXIge2ZvcndhcmQ6IGwsIGNsaWVudDogdSwgZGlzcGF0Y2hEZWJ1ZzogY30gPSByO1xuICAgIHZhciB7c291cmNlOiBwLCBuZXh0OiBofSA9IGYoKTtcbiAgICB2YXIgbSA9IFtdO1xuICAgIHZhciBnID0gITE7XG4gICAgdmFyIF8gPSAhMTtcbiAgICB2YXIgdXBkYXRlTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBpZiAoZykge1xuICAgICAgICB2YXIgZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG0ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICB2YXIgdCA9IG1bcl07XG4gICAgICAgICAgaWYgKFwibXV0YXRpb25cIiA9PT0gdC5raW5kKSB7XG4gICAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgICBxdWVyeTogaSh0LnF1ZXJ5KSxcbiAgICAgICAgICAgICAgdmFyaWFibGVzOiB0LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uczogdC5leHRlbnNpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbi53cml0ZU1ldGFkYXRhKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGZpbHRlclF1ZXVlID0gZSA9PiB7XG4gICAgICBmb3IgKHZhciByID0gbS5sZW5ndGggLSAxOyByID49IDA7IHItLSkge1xuICAgICAgICBpZiAobVtyXS5rZXkgPT09IGUpIHtcbiAgICAgICAgICBtLnNwbGljZShyLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGZsdXNoUXVldWUgPSAoKSA9PiB7XG4gICAgICBpZiAoIV8pIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgU2V0O1xuICAgICAgICBfID0gITA7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgIHZhciB0ID0gbVtyXTtcbiAgICAgICAgICBpZiAoXCJtdXRhdGlvblwiID09PSB0LmtpbmQgfHwgIWUuaGFzKHQua2V5KSkge1xuICAgICAgICAgICAgZS5hZGQodC5rZXkpO1xuICAgICAgICAgICAgaWYgKFwic3Vic2NyaXB0aW9uXCIgIT09IHQua2luZCkge1xuICAgICAgICAgICAgICBoKGEoXCJ0ZWFyZG93blwiLCB0KSk7XG4gICAgICAgICAgICAgIHZhciBpID0gXCJjYWNoZS1maXJzdFwiO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG0ubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIge3JlcXVlc3RQb2xpY3k6IG99ID0gbVtuXS5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChNW29dID4gTVtpXSkge1xuICAgICAgICAgICAgICAgICAgaSA9IG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGgodG9SZXF1ZXN0UG9saWN5KHQsIGkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGgodG9SZXF1ZXN0UG9saWN5KHQsIFwiY2FjaGUtZmlyc3RcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfID0gITE7XG4gICAgICAgIG0ubGVuZ3RoID0gMDtcbiAgICAgICAgdXBkYXRlTWV0YWRhdGEoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBOID0gY2FjaGVFeGNoYW5nZSh7XG4gICAgICAuLi5lLFxuICAgICAgc3RvcmFnZToge1xuICAgICAgICAuLi5uLFxuICAgICAgICByZWFkRGF0YSgpIHtcbiAgICAgICAgICB2YXIgZSA9IG4ucmVhZERhdGEoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN5bmMgdGhlbihyKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gYXdhaXQgbi5yZWFkTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGEgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtLnB1c2godS5jcmVhdGVSZXF1ZXN0T3BlcmF0aW9uKFwibXV0YXRpb25cIiwgdChhW2ldLnF1ZXJ5LCBhW2ldLnZhcmlhYmxlcyksIGFbaV0uZXh0ZW5zaW9ucykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIoYXdhaXQgZSk7XG4gICAgICAgICAgICAgIG4ub25PbmxpbmUoZmx1c2hRdWV1ZSk7XG4gICAgICAgICAgICAgIGcgPSAhMDtcbiAgICAgICAgICAgICAgZmx1c2hRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSh7XG4gICAgICBjbGllbnQ6IHUsXG4gICAgICBkaXNwYXRjaERlYnVnOiBjLFxuICAgICAgZm9yd2FyZDogZSA9PiBzKHYoKGUgPT4ge1xuICAgICAgICBpZiAoZyAmJiBcIm11dGF0aW9uXCIgPT09IGUub3BlcmF0aW9uLmtpbmQgJiYgZS5vcGVyYXRpb24uY29udGV4dC5vcHRpbWlzdGljICYmIG8oZS5lcnJvciwgZSkpIHtcbiAgICAgICAgICBtLnB1c2goZS5vcGVyYXRpb24pO1xuICAgICAgICAgIHVwZGF0ZU1ldGFkYXRhKCk7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0pKShsKGUpKSlcbiAgICB9KTtcbiAgICByZXR1cm4gZSA9PiB7XG4gICAgICB2YXIgciA9IGQoWyBwLCB5KChlID0+IHtcbiAgICAgICAgaWYgKFwicXVlcnlcIiA9PT0gZS5raW5kICYmICFnKSB7XG4gICAgICAgICAgbS5wdXNoKGUpO1xuICAgICAgICB9IGVsc2UgaWYgKFwidGVhcmRvd25cIiA9PT0gZS5raW5kKSB7XG4gICAgICAgICAgZmlsdGVyUXVldWUoZS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9KSkoZSkgXSk7XG4gICAgICByZXR1cm4gdigoZSA9PiB7XG4gICAgICAgIGlmIChcInF1ZXJ5XCIgPT09IGUub3BlcmF0aW9uLmtpbmQpIHtcbiAgICAgICAgICBpZiAobyhlLmVycm9yLCBlKSkge1xuICAgICAgICAgICAgaCh0b1JlcXVlc3RQb2xpY3koZS5vcGVyYXRpb24sIFwiY2FjaGUtb25seVwiKSk7XG4gICAgICAgICAgICBtLnB1c2goZS5vcGVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWcpIHtcbiAgICAgICAgICAgIGZpbHRlclF1ZXVlKGUub3BlcmF0aW9uLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0pKShOKHIpKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjYWNoZUV4Y2hhbmdlKGUpKHIpO1xufTtcblxuZXhwb3J0IHsgU3RvcmUsIGNhY2hlRXhjaGFuZ2UsIG9mZmxpbmVFeGNoYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJxbC1leGNoYW5nZS1ncmFwaGNhY2hlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@urql+exchange-graphcache@6.5.1_graphql@16.8.1/node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs\n");

/***/ })

};
;