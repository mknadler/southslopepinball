"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately+layout@3.13.7_react@18.2.0";
exports.ids = ["vendor-chunks/@react-stately+layout@3.13.7_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-stately+layout@3.13.7_react@18.2.0/node_modules/@react-stately/layout/dist/import.mjs":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-stately+layout@3.13.7_react@18.2.0/node_modules/@react-stately/layout/dist/import.mjs ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListLayout: () => (/* binding */ $61ef60fc9b1041f4$export$cacbb3924155d68e),\n/* harmony export */   TableLayout: () => (/* binding */ $a152112e902709bf$export$62444c3c724b1b20)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/.pnpm/@react-stately+collections@3.10.5_react@18.2.0/node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/virtualizer */ \"(ssr)/./node_modules/.pnpm/@react-stately+virtualizer@3.6.8_react@18.2.0/node_modules/@react-stately/virtualizer/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Layout) {\n    getLayoutInfo(key) {\n        let res = this.layoutInfos.get(key);\n        // If the layout info wasn't found, it might be outside the bounds of the area that we've\n        // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n        // Compute the full layout and try again.\n        if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {\n            this.lastValidRect = this.validRect;\n            this.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, Infinity, Infinity);\n            this.rootNodes = this.buildCollection();\n            this.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, this.contentSize.width, this.contentSize.height);\n            res = this.layoutInfos.get(key);\n        }\n        return res;\n    }\n    getVisibleLayoutInfos(rect) {\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        if (!this.validRect.containsRect(rect) && this.lastCollection) {\n            this.lastValidRect = this.validRect;\n            this.validRect = this.validRect.union(rect);\n            this.rootNodes = this.buildCollection();\n        }\n        let res = [];\n        let addNodes = (nodes)=>{\n            for (let node of nodes)if (this.isVisible(node, rect)) {\n                res.push(node.layoutInfo);\n                if (node.header) res.push(node.header);\n                if (node.children) addNodes(node.children);\n            }\n        };\n        addNodes(this.rootNodes);\n        return res;\n    }\n    isVisible(node, rect) {\n        return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n    }\n    shouldInvalidateEverything(invalidationContext) {\n        // Invalidate cache if the size of the collection changed.\n        // In this case, we need to recalculate the entire layout.\n        return invalidationContext.sizeChanged;\n    }\n    validate(invalidationContext) {\n        this.collection = this.virtualizer.collection;\n        // Reset valid rect if we will have to invalidate everything.\n        // Otherwise we can reuse cached layout infos outside the current visible rect.\n        this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n        if (this.invalidateEverything) {\n            this.lastValidRect = this.validRect;\n            this.validRect = this.virtualizer.getVisibleRect();\n        }\n        this.rootNodes = this.buildCollection();\n        // Remove deleted layout nodes\n        if (this.lastCollection && this.collection !== this.lastCollection) {\n            for (let key of this.lastCollection.getKeys())if (!this.collection.getItem(key)) {\n                let layoutNode = this.layoutNodes.get(key);\n                if (layoutNode) {\n                    var _layoutNode_header;\n                    this.layoutInfos.delete(layoutNode.layoutInfo.key);\n                    this.layoutInfos.delete((_layoutNode_header = layoutNode.header) === null || _layoutNode_header === void 0 ? void 0 : _layoutNode_header.key);\n                    this.layoutNodes.delete(key);\n                }\n            }\n        }\n        this.lastWidth = this.virtualizer.visibleRect.width;\n        this.lastCollection = this.collection;\n        this.invalidateEverything = false;\n    }\n    buildCollection() {\n        let y = this.padding;\n        let skipped = 0;\n        let nodes = [];\n        for (let node of this.collection){\n            var _this_rowHeight;\n            let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (node.type === \"item\" && y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, 0, y);\n            y = layoutNode.layoutInfo.rect.maxY;\n            nodes.push(layoutNode);\n            if (node.type === \"item\" && y > this.validRect.maxY) {\n                y += (this.collection.size - (nodes.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        if (this.isLoading) {\n            var _this_loaderHeight;\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, this.virtualizer.visibleRect.width, (_this_loaderHeight = this.loaderHeight) !== null && _this_loaderHeight !== void 0 ? _this_loaderHeight : this.virtualizer.visibleRect.height);\n            let loader = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"loader\", \"loader\", rect);\n            this.layoutInfos.set(\"loader\", loader);\n            nodes.push({\n                layoutInfo: loader\n            });\n            y = loader.rect.maxY;\n        }\n        if (nodes.length === 0) {\n            var _this_placeholderHeight;\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, this.virtualizer.visibleRect.width, (_this_placeholderHeight = this.placeholderHeight) !== null && _this_placeholderHeight !== void 0 ? _this_placeholderHeight : this.virtualizer.visibleRect.height);\n            let placeholder = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"placeholder\", \"placeholder\", rect);\n            this.layoutInfos.set(\"placeholder\", placeholder);\n            nodes.push({\n                layoutInfo: placeholder\n            });\n            y = placeholder.rect.maxY;\n        }\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(this.virtualizer.visibleRect.width, y + this.padding);\n        return nodes;\n    }\n    isValid(node, y) {\n        let cached = this.layoutNodes.get(node.key);\n        return !this.invalidateEverything && cached && cached.node === node && y === (cached.header || cached.layoutInfo).rect.y && cached.layoutInfo.rect.intersects(this.lastValidRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect));\n    }\n    buildChild(node, x, y) {\n        if (this.isValid(node, y)) return this.layoutNodes.get(node.key);\n        let layoutNode = this.buildNode(node, x, y);\n        layoutNode.node = node;\n        var _node_parentKey;\n        layoutNode.layoutInfo.parentKey = (_node_parentKey = node.parentKey) !== null && _node_parentKey !== void 0 ? _node_parentKey : null;\n        this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n        if (layoutNode.header) this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n        this.layoutNodes.set(node.key, layoutNode);\n        return layoutNode;\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case \"section\":\n                return this.buildSection(node, x, y);\n            case \"item\":\n                return this.buildItem(node, x, y);\n        }\n    }\n    buildSection(node, x, y) {\n        let width = this.virtualizer.visibleRect.width;\n        let rectHeight = this.headingHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall collection view changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode && previousLayoutNode.header) {\n                let curNode = this.collection.getItem(node.key);\n                let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n                rectHeight = previousLayoutNode.header.rect.height;\n                isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n            } else {\n                rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        let headerRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, width, rectHeight);\n        let header = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"header\", node.key + \":header\", headerRect);\n        header.estimatedSize = isEstimated;\n        header.parentKey = node.key;\n        y += header.rect.height;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, width, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        let startY = y;\n        let skipped = 0;\n        let children = [];\n        for (let child of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, this.collection)){\n            var _this_rowHeight;\n            let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(child, x, y);\n            y = layoutNode.layoutInfo.rect.maxY;\n            children.push(layoutNode);\n            if (y > this.validRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += ([\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, this.collection)\n                ].length - (children.length + skipped)) * rowHeight;\n                break;\n            }\n        }\n        rect.height = y - startY;\n        return {\n            header: header,\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.validRect)\n        };\n    }\n    buildItem(node, x, y) {\n        let width = this.virtualizer.visibleRect.width;\n        let rectHeight = this.rowHeight;\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (rectHeight == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall collection view changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                rectHeight = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                rectHeight = this.estimatedRowHeight;\n                isEstimated = true;\n            }\n        }\n        if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n        if (typeof this.indentationForItem === \"function\") x += this.indentationForItem(this.collection, node.key) || 0;\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width - x, rectHeight);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        // allow overflow so the focus ring/selection ring can extend outside to overlap with the adjacent items borders\n        layoutInfo.allowOverflow = true;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            validRect: layoutInfo.rect\n        };\n    }\n    updateItemSize(key, size) {\n        let layoutInfo = this.layoutInfos.get(key);\n        // If no layoutInfo, item has been deleted/removed.\n        if (!layoutInfo) return false;\n        layoutInfo.estimatedSize = false;\n        if (layoutInfo.rect.height !== size.height) {\n            // Copy layout info rather than mutating so that later caches are invalidated.\n            let newLayoutInfo = layoutInfo.copy();\n            newLayoutInfo.rect.height = size.height;\n            this.layoutInfos.set(key, newLayoutInfo);\n            // Invalidate layout for this layout node and all parents\n            this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n            let node = this.collection.getItem(layoutInfo.parentKey);\n            while(node){\n                this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n                node = this.collection.getItem(node.parentKey);\n            }\n            return true;\n        }\n        return false;\n    }\n    updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n        let n = this.layoutNodes.get(key);\n        if (n) {\n            // Invalidate by reseting validRect.\n            n.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n            // Replace layout info in LayoutNode\n            if (n.header === oldLayoutInfo) n.header = newLayoutInfo;\n            else if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n        }\n    }\n    getContentSize() {\n        return this.contentSize;\n    }\n    getKeyAbove(key) {\n        let collection = this.collection;\n        key = collection.getKeyBefore(key);\n        while(key != null){\n            let item = collection.getItem(key);\n            if (item.type === \"item\" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n            key = collection.getKeyBefore(key);\n        }\n    }\n    getKeyBelow(key) {\n        let collection = this.collection;\n        key = collection.getKeyAfter(key);\n        while(key != null){\n            let item = collection.getItem(key);\n            if (item.type === \"item\" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n            key = collection.getKeyAfter(key);\n        }\n    }\n    getKeyPageAbove(key) {\n        let layoutInfo = this.getLayoutInfo(key);\n        if (layoutInfo) {\n            let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n            while(layoutInfo && layoutInfo.rect.y > pageY){\n                let keyAbove = this.getKeyAbove(layoutInfo.key);\n                layoutInfo = this.getLayoutInfo(keyAbove);\n            }\n            if (layoutInfo) return layoutInfo.key;\n        }\n        return this.getFirstKey();\n    }\n    getKeyPageBelow(key) {\n        let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n        if (layoutInfo) {\n            let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n            while(layoutInfo && layoutInfo.rect.y < pageY){\n                let keyBelow = this.getKeyBelow(layoutInfo.key);\n                layoutInfo = this.getLayoutInfo(keyBelow);\n            }\n            if (layoutInfo) return layoutInfo.key;\n        }\n        return this.getLastKey();\n    }\n    getFirstKey() {\n        let collection = this.collection;\n        let key = collection.getFirstKey();\n        while(key != null){\n            let item = collection.getItem(key);\n            if (item.type === \"item\" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n            key = collection.getKeyAfter(key);\n        }\n    }\n    getLastKey() {\n        let collection = this.collection;\n        let key = collection.getLastKey();\n        while(key != null){\n            let item = collection.getItem(key);\n            if (item.type === \"item\" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) return key;\n            key = collection.getKeyBefore(key);\n        }\n    }\n    getKeyForSearch(search, fromKey) {\n        if (!this.collator) return null;\n        let collection = this.collection;\n        let key = fromKey || this.getFirstKey();\n        while(key != null){\n            let item = collection.getItem(key);\n            let substring = item.textValue.slice(0, search.length);\n            if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n            key = this.getKeyBelow(key);\n        }\n        return null;\n    }\n    getInitialLayoutInfo(layoutInfo) {\n        layoutInfo.opacity = 0;\n        layoutInfo.transform = \"scale3d(0.8, 0.8, 0.8)\";\n        return layoutInfo;\n    }\n    getFinalLayoutInfo(layoutInfo) {\n        layoutInfo.opacity = 0;\n        layoutInfo.transform = \"scale3d(0.8, 0.8, 0.8)\";\n        return layoutInfo;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        let key = this.virtualizer.keyAtPoint(new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Point)(x, y));\n        if (key == null || this.collection.size === 0) return {\n            type: \"root\"\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        let rect = layoutInfo.rect;\n        let target = {\n            type: \"item\",\n            key: layoutInfo.key,\n            dropPosition: \"on\"\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: \"before\"\n            })) target.dropPosition = \"before\";\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: \"after\"\n            })) target.dropPosition = \"after\";\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: \"before\"\n        })) target.dropPosition = \"before\";\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: \"after\"\n        })) target.dropPosition = \"after\";\n        return target;\n    }\n    /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */ constructor(options = {}){\n        super();\n        this.disabledKeys = new Set();\n        this.allowDisabledKeyFocus = false;\n        this.rowHeight = options.rowHeight;\n        this.estimatedRowHeight = options.estimatedRowHeight;\n        this.headingHeight = options.headingHeight;\n        this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n        this.padding = options.padding || 0;\n        this.indentationForItem = options.indentationForItem;\n        this.collator = options.collator;\n        this.loaderHeight = options.loaderHeight;\n        this.placeholderHeight = options.placeholderHeight;\n        this.layoutInfos = new Map();\n        this.layoutNodes = new Map();\n        this.rootNodes = [];\n        this.lastWidth = 0;\n        this.lastCollection = null;\n        this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;\n        this.lastValidRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.validRect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)();\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)();\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nclass $a152112e902709bf$export$62444c3c724b1b20 extends (0, $61ef60fc9b1041f4$export$cacbb3924155d68e) {\n    shouldInvalidateEverything(invalidationContext) {\n        // If columns changed, clear layout cache.\n        return super.shouldInvalidateEverything(invalidationContext) || !this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c, i)=>c.key !== this.lastCollection.columns[i].key || c.props.width !== this.lastCollection.columns[i].props.width || c.props.minWidth !== this.lastCollection.columns[i].props.minWidth || c.props.maxWidth !== this.lastCollection.columns[i].props.maxWidth);\n    }\n    getResizerPosition() {\n        var _this_getLayoutInfo;\n        return (_this_getLayoutInfo = this.getLayoutInfo(this.resizingColumn)) === null || _this_getLayoutInfo === void 0 ? void 0 : _this_getLayoutInfo.rect.maxX;\n    }\n    getColumnWidth(key) {\n        var _this_columnLayout_getColumnWidth;\n        return (_this_columnLayout_getColumnWidth = this.columnLayout.getColumnWidth(key)) !== null && _this_columnLayout_getColumnWidth !== void 0 ? _this_columnLayout_getColumnWidth : 0;\n    }\n    getColumnMinWidth(key) {\n        let column = this.collection.columns.find((col)=>col.key === key);\n        if (!column) return 0;\n        return this.columnLayout.getColumnMinWidth(key);\n    }\n    getColumnMaxWidth(key) {\n        let column = this.collection.columns.find((col)=>col.key === key);\n        if (!column) return 0;\n        return this.columnLayout.getColumnMaxWidth(key);\n    }\n    // outside, where this is called, should call props.onColumnResizeStart...\n    startResize(key) {\n        this.resizingColumn = key;\n    }\n    // only way to call props.onColumnResize with the new size outside of Layout is to send the result back\n    updateResizedColumns(key, width) {\n        let newControlled = new Map(Array.from(this.controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = this.columnLayout.resizeColumnWidth(this.virtualizer.visibleRect.width, this.collection, newControlled, this.uncontrolledWidths, key, width);\n        let map = new Map(Array.from(this.uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        this.uncontrolledWidths = map;\n        // relayoutNow still uses setState, should happen at the same time the parent\n        // component's state is processed as a result of props.onColumnResize\n        if (this.uncontrolledWidths.size > 0) this.virtualizer.relayoutNow({\n            sizeChanged: true\n        });\n        return newSizes;\n    }\n    endResize() {\n        this.resizingColumn = null;\n    }\n    buildCollection() {\n        // Track whether we were previously loading. This is used to adjust the animations of async loading vs inserts.\n        let loadingState = this.collection.body.props.loadingState;\n        this.wasLoading = this.isLoading;\n        this.isLoading = loadingState === \"loading\" || loadingState === \"loadingMore\";\n        this.stickyColumnIndices = [];\n        for (let column of this.collection.columns)// The selection cell and any other sticky columns always need to be visible.\n        // In addition, row headers need to be in the DOM for accessibility labeling.\n        if (column.props.isDragButtonCell || column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);\n        let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);\n        this.controlledColumns = controlledColumns;\n        this.uncontrolledColumns = uncontrolledColumns;\n        let colWidths = this.columnLayout.recombineColumns(this.collection.columns, this.uncontrolledWidths, uncontrolledColumns, controlledColumns);\n        this.columnWidths = this.columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, this.collection, colWidths);\n        let header = this.buildHeader();\n        let body = this.buildBody(0);\n        this.lastPersistedKeys = null;\n        body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n        this.contentSize = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Size)(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n        return [\n            header,\n            body\n        ];\n    }\n    buildHeader() {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, 0, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"header\", \"header\", rect);\n        let y = 0;\n        let width = 0;\n        let children = [];\n        for (let headerRow of this.collection.headerRows){\n            let layoutNode = this.buildChild(headerRow, 0, y);\n            layoutNode.layoutInfo.parentKey = \"header\";\n            y = layoutNode.layoutInfo.rect.maxY;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            layoutNode.index = children.length;\n            children.push(layoutNode);\n        }\n        rect.width = width;\n        rect.height = y;\n        this.layoutInfos.set(\"header\", layoutInfo);\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect\n        };\n    }\n    buildHeaderRow(headerRow, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, 0, 0);\n        let row = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"headerrow\", headerRow.key, rect);\n        let height = 0;\n        let columns = [];\n        for (let cell of (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(headerRow, this.collection)){\n            let layoutNode = this.buildChild(cell, x, y);\n            layoutNode.layoutInfo.parentKey = row.key;\n            x = layoutNode.layoutInfo.rect.maxX;\n            height = Math.max(height, layoutNode.layoutInfo.rect.height);\n            layoutNode.index = columns.length;\n            columns.push(layoutNode);\n        }\n        for (let [i, layout] of columns.entries())layout.layoutInfo.zIndex = columns.length - i + 1;\n        this.setChildHeights(columns, height);\n        rect.height = height;\n        rect.width = x;\n        return {\n            layoutInfo: row,\n            children: columns,\n            validRect: rect\n        };\n    }\n    setChildHeights(children, height) {\n        for (let child of children)if (child.layoutInfo.rect.height !== height) {\n            // Need to copy the layout info before we mutate it.\n            child.layoutInfo = child.layoutInfo.copy();\n            this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n            child.layoutInfo.rect.height = height;\n        }\n    }\n    // used to get the column widths when rendering to the DOM\n    getRenderedColumnWidth(node) {\n        var _node_colspan;\n        let colspan = (_node_colspan = node.colspan) !== null && _node_colspan !== void 0 ? _node_colspan : 1;\n        var _node_colIndex;\n        let colIndex = (_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index;\n        let width = 0;\n        for(let i = colIndex; i < colIndex + colspan; i++){\n            let column = this.collection.columns[i];\n            if ((column === null || column === void 0 ? void 0 : column.key) != null) width += this.columnWidths.get(column.key);\n        }\n        return width;\n    }\n    getEstimatedHeight(node, width, height, estimatedHeight) {\n        let isEstimated = false;\n        // If no explicit height is available, use an estimated height.\n        if (height == null) {\n            // If a previous version of this layout info exists, reuse its height.\n            // Mark as estimated if the size of the overall collection view changed,\n            // or the content of the item changed.\n            let previousLayoutNode = this.layoutNodes.get(node.key);\n            if (previousLayoutNode) {\n                height = previousLayoutNode.layoutInfo.rect.height;\n                isEstimated = node !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n            } else {\n                height = estimatedHeight;\n                isEstimated = true;\n            }\n        }\n        return {\n            height: height,\n            isEstimated: isEstimated\n        };\n    }\n    buildColumn(node, x, y) {\n        var _node_props, _node_props1;\n        let width = this.getRenderedColumnWidth(node);\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = !this.disableSticky && (((_node_props = node.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            validRect: layoutInfo.rect\n        };\n    }\n    buildBody(y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(0, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"rowgroup\", \"body\", rect);\n        let startY = y;\n        let skipped = 0;\n        let width = 0;\n        let children = [];\n        for (let [i, node] of [\n            ...this.collection\n        ].entries()){\n            var _this_rowHeight;\n            let rowHeight = ((_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) + 1;\n            // Skip rows before the valid rectangle unless they are already cached.\n            if (y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n                y += rowHeight;\n                skipped++;\n                continue;\n            }\n            let layoutNode = this.buildChild(node, 0, y);\n            layoutNode.layoutInfo.parentKey = \"body\";\n            layoutNode.index = i;\n            y = layoutNode.layoutInfo.rect.maxY;\n            width = Math.max(width, layoutNode.layoutInfo.rect.width);\n            children.push(layoutNode);\n            if (y > this.validRect.maxY) {\n                // Estimate the remaining height for rows that we don't need to layout right now.\n                y += (this.collection.size - (skipped + children.length)) * rowHeight;\n                break;\n            }\n        }\n        if (this.isLoading) {\n            // Add some margin around the loader to ensure that scrollbars don't flicker in and out.\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(40, Math.max(y, 40), (width || this.virtualizer.visibleRect.width) - 80, children.length === 0 ? this.virtualizer.visibleRect.height - 80 : 60);\n            let loader = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"loader\", \"loader\", rect);\n            loader.parentKey = \"body\";\n            loader.isSticky = !this.disableSticky && children.length === 0;\n            this.layoutInfos.set(\"loader\", loader);\n            children.push({\n                layoutInfo: loader,\n                validRect: loader.rect\n            });\n            y = loader.rect.maxY;\n            width = Math.max(width, rect.width);\n        } else if (children.length === 0) {\n            let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(40, Math.max(y, 40), this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);\n            let empty = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"empty\", \"empty\", rect);\n            empty.parentKey = \"body\";\n            empty.isSticky = !this.disableSticky;\n            this.layoutInfos.set(\"empty\", empty);\n            children.push({\n                layoutInfo: empty,\n                validRect: empty.rect\n            });\n            y = empty.rect.maxY;\n            width = Math.max(width, rect.width);\n        }\n        rect.width = width;\n        rect.height = y - startY;\n        this.layoutInfos.set(\"body\", layoutInfo);\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: layoutInfo.rect.intersection(this.validRect)\n        };\n    }\n    buildNode(node, x, y) {\n        switch(node.type){\n            case \"headerrow\":\n                return this.buildHeaderRow(node, x, y);\n            case \"item\":\n                return this.buildRow(node, x, y);\n            case \"column\":\n            case \"placeholder\":\n                return this.buildColumn(node, x, y);\n            case \"cell\":\n                return this.buildCell(node, x, y);\n            default:\n                throw new Error(\"Unknown node type \" + node.type);\n        }\n    }\n    buildRow(node, x, y) {\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, 0, 0);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(\"row\", node.key, rect);\n        let children = [];\n        let height = 0;\n        for (let [i, child] of [\n            ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_1__.getChildNodes)(node, this.collection)\n        ].entries())if (child.type === \"cell\") {\n            if (x > this.validRect.maxX) {\n                // Adjust existing cached layoutInfo to ensure that it is out of view.\n                // This can happen due to column resizing.\n                let layoutNode = this.layoutNodes.get(child.key);\n                if (layoutNode) {\n                    layoutNode.layoutInfo.rect.x = x;\n                    x += layoutNode.layoutInfo.rect.width;\n                }\n            } else {\n                let layoutNode = this.buildChild(child, x, y);\n                x = layoutNode.layoutInfo.rect.maxX;\n                height = Math.max(height, layoutNode.layoutInfo.rect.height);\n                layoutNode.index = i;\n                children.push(layoutNode);\n            }\n        }\n        this.setChildHeights(children, height);\n        rect.width = this.layoutInfos.get(\"header\").rect.width;\n        rect.height = height + 1; // +1 for bottom border\n        return {\n            layoutInfo: layoutInfo,\n            children: children,\n            validRect: rect.intersection(this.validRect)\n        };\n    }\n    buildCell(node, x, y) {\n        var _node_props, _node_props1;\n        let width = this.getRenderedColumnWidth(node);\n        let { height: height, isEstimated: isEstimated } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n        let rect = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, width, height);\n        let layoutInfo = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.LayoutInfo)(node.type, node.key, rect);\n        layoutInfo.isSticky = !this.disableSticky && (((_node_props = node.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));\n        layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n        layoutInfo.estimatedSize = isEstimated;\n        return {\n            layoutInfo: layoutInfo,\n            validRect: rect\n        };\n    }\n    getVisibleLayoutInfos(rect) {\n        // If layout hasn't yet been done for the requested rect, union the\n        // new rect with the existing valid rect, and recompute.\n        if (!this.validRect.containsRect(rect) && this.lastCollection) {\n            this.lastValidRect = this.validRect;\n            this.validRect = this.validRect.union(rect);\n            this.rootNodes = this.buildCollection();\n        }\n        let res = [];\n        this.buildPersistedIndices();\n        for (let node of this.rootNodes){\n            res.push(node.layoutInfo);\n            this.addVisibleLayoutInfos(res, node, rect);\n        }\n        return res;\n    }\n    addVisibleLayoutInfos(res, node, rect) {\n        if (!node.children || node.children.length === 0) return;\n        switch(node.layoutInfo.type){\n            case \"header\":\n                for (let child of node.children){\n                    res.push(child.layoutInfo);\n                    this.addVisibleLayoutInfos(res, child, rect);\n                }\n                break;\n            case \"rowgroup\":\n                {\n                    let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, \"y\");\n                    let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, \"y\");\n                    // Add persisted rows before the visible rows.\n                    let persistedRowIndices = this.persistedIndices.get(node.layoutInfo.key);\n                    let persistIndex = 0;\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow){\n                        let idx = persistedRowIndices[persistIndex];\n                        if (idx < node.children.length) {\n                            res.push(node.children[idx].layoutInfo);\n                            this.addVisibleLayoutInfos(res, node.children[idx], rect);\n                        }\n                        persistIndex++;\n                    }\n                    for(let i = firstVisibleRow; i <= lastVisibleRow; i++){\n                        // Skip persisted rows that overlap with visible cells.\n                        while(persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i)persistIndex++;\n                        res.push(node.children[i].layoutInfo);\n                        this.addVisibleLayoutInfos(res, node.children[i], rect);\n                    }\n                    // Add persisted rows after the visible rows.\n                    while(persistedRowIndices && persistIndex < persistedRowIndices.length){\n                        let idx = persistedRowIndices[persistIndex++];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                    }\n                    break;\n                }\n            case \"headerrow\":\n            case \"row\":\n                {\n                    let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, \"x\");\n                    let lastVisibleCell = this.binarySearch(node.children, rect.topRight, \"x\");\n                    let stickyIndex = 0;\n                    // Add persisted/sticky cells before the visible cells.\n                    let persistedCellIndices = this.persistedIndices.get(node.layoutInfo.key) || this.stickyColumnIndices;\n                    while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell){\n                        let idx = persistedCellIndices[stickyIndex];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                        stickyIndex++;\n                    }\n                    for(let i = firstVisibleCell; i <= lastVisibleCell; i++){\n                        // Skip sticky cells that overlap with visible cells.\n                        while(stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i)stickyIndex++;\n                        res.push(node.children[i].layoutInfo);\n                    }\n                    // Add any remaining sticky cells after the visible cells.\n                    while(stickyIndex < persistedCellIndices.length){\n                        let idx = persistedCellIndices[stickyIndex++];\n                        if (idx < node.children.length) res.push(node.children[idx].layoutInfo);\n                    }\n                    break;\n                }\n            default:\n                throw new Error(\"Unknown node type \" + node.layoutInfo.type);\n        }\n    }\n    binarySearch(items, point, axis) {\n        let low = 0;\n        let high = items.length - 1;\n        while(low <= high){\n            let mid = low + high >> 1;\n            let item = items[mid];\n            if (axis === \"x\" && item.layoutInfo.rect.maxX < point.x || axis === \"y\" && item.layoutInfo.rect.maxY < point.y) low = mid + 1;\n            else if (axis === \"x\" && item.layoutInfo.rect.x > point.x || axis === \"y\" && item.layoutInfo.rect.y > point.y) high = mid - 1;\n            else return mid;\n        }\n        return Math.max(0, Math.min(items.length - 1, low));\n    }\n    buildPersistedIndices() {\n        if (this.virtualizer.persistedKeys === this.lastPersistedKeys) return;\n        this.lastPersistedKeys = this.virtualizer.persistedKeys;\n        this.persistedIndices.clear();\n        // Build a map of parentKey => indices of children to persist.\n        for (let key of this.virtualizer.persistedKeys){\n            let layoutInfo = this.layoutInfos.get(key);\n            // Walk up ancestors so parents are also persisted if children are.\n            while(layoutInfo && layoutInfo.parentKey){\n                let collectionNode = this.collection.getItem(layoutInfo.key);\n                let indices = this.persistedIndices.get(layoutInfo.parentKey);\n                if (!indices) {\n                    // stickyColumnIndices are always persisted along with any cells from persistedKeys.\n                    indices = collectionNode.type === \"cell\" || collectionNode.type === \"column\" ? [\n                        ...this.stickyColumnIndices\n                    ] : [];\n                    this.persistedIndices.set(layoutInfo.parentKey, indices);\n                }\n                let index = this.layoutNodes.get(layoutInfo.key).index;\n                if (!indices.includes(index)) indices.push(index);\n                layoutInfo = this.layoutInfos.get(layoutInfo.parentKey);\n            }\n        }\n        for (let indices of this.persistedIndices.values())indices.sort((a, b)=>a - b);\n    }\n    getInitialLayoutInfo(layoutInfo) {\n        let res = super.getInitialLayoutInfo(layoutInfo);\n        res.transform = null;\n        return res;\n    }\n    getFinalLayoutInfo(layoutInfo) {\n        let res = super.getFinalLayoutInfo(layoutInfo);\n        res.transform = null;\n        return res;\n    }\n    // Checks if Chrome version is 105 or greater\n    checkChrome105() {\n        var _window_navigator_userAgentData;\n        if (typeof window === \"undefined\" || window.navigator == null) return false;\n        let isChrome105;\n        if (window.navigator[\"userAgentData\"]) isChrome105 = (_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((b)=>b.brand === \"Chromium\" && Number(b.version) === 105);\n        else {\n            let regex = /Chrome\\/(\\d+)/;\n            let matches = regex.exec(window.navigator.userAgent);\n            isChrome105 = matches && matches.length >= 2 && Number(matches[1]) === 105;\n        }\n        return isChrome105;\n    }\n    getDropTargetFromPoint(x, y, isValidDropTarget) {\n        var _this_virtualizer_layout_getVisibleLayoutInfos_find;\n        x += this.virtualizer.visibleRect.x;\n        y += this.virtualizer.visibleRect.y;\n        // Offset for height of header row\n        y -= (_this_virtualizer_layout_getVisibleLayoutInfos_find = this.virtualizer.layout.getVisibleLayoutInfos(new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(x, y, 1, 1)).find((info)=>info.type === \"headerrow\")) === null || _this_virtualizer_layout_getVisibleLayoutInfos_find === void 0 ? void 0 : _this_virtualizer_layout_getVisibleLayoutInfos_find.rect.height;\n        // Custom variation of this.virtualizer.keyAtPoint that ignores body\n        let key;\n        let point = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Point)(x, y);\n        let rectAtPoint = new (0, _react_stately_virtualizer__WEBPACK_IMPORTED_MODULE_0__.Rect)(point.x, point.y, 1, 1);\n        let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter((info)=>info.type === \"row\");\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos)if (layoutInfo.rect.intersects(rectAtPoint)) key = layoutInfo.key;\n        if (key == null || this.collection.size === 0) return {\n            type: \"root\"\n        };\n        let layoutInfo = this.getLayoutInfo(key);\n        let rect = layoutInfo.rect;\n        let target = {\n            type: \"item\",\n            key: layoutInfo.key,\n            dropPosition: \"on\"\n        };\n        // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n        // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n        // of the top or bottom of the item.\n        if (!isValidDropTarget(target)) {\n            if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n                ...target,\n                dropPosition: \"before\"\n            })) target.dropPosition = \"before\";\n            else if (isValidDropTarget({\n                ...target,\n                dropPosition: \"after\"\n            })) target.dropPosition = \"after\";\n        } else if (y <= rect.y + 10 && isValidDropTarget({\n            ...target,\n            dropPosition: \"before\"\n        })) target.dropPosition = \"before\";\n        else if (y >= rect.maxY - 10 && isValidDropTarget({\n            ...target,\n            dropPosition: \"after\"\n        })) target.dropPosition = \"after\";\n        return target;\n    }\n    constructor(options){\n        super(options);\n        this.columnWidths = new Map();\n        this.wasLoading = false;\n        this.isLoading = false;\n        this.lastPersistedKeys = null;\n        this.persistedIndices = new Map();\n        this.collection = options.initialCollection;\n        this.stickyColumnIndices = [];\n        this.disableSticky = this.checkChrome105();\n        this.columnLayout = options.columnLayout;\n        let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);\n        this.controlledColumns = controlledColumns;\n        this.uncontrolledColumns = uncontrolledColumns;\n        this.uncontrolledWidths = this.columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXN0YXRlbHkrbGF5b3V0QDMuMTMuN19yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xheW91dC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRjtBQUNvRjs7QUFFcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELDhEQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDREQUFXO0FBQ2hEO0FBQ0EscUNBQXFDLDREQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQVc7QUFDMUMsaUNBQWlDLGtFQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQVc7QUFDMUMsc0NBQXNDLGtF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QyxrQ0FBa0MsNERBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSzJIO0FBQzNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1zdGF0ZWx5K2xheW91dEAzLjEzLjdfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9sYXlvdXQvZGlzdC9pbXBvcnQubWpzPzMwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRndFcxVCRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7UmVjdCBhcyAkZ3RXMVQkUmVjdCwgTGF5b3V0SW5mbyBhcyAkZ3RXMVQkTGF5b3V0SW5mbywgU2l6ZSBhcyAkZ3RXMVQkU2l6ZSwgUG9pbnQgYXMgJGd0VzFUJFBvaW50LCBMYXlvdXQgYXMgJGd0VzFUJExheW91dH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVCA9IDQ4O1xuY2xhc3MgJDYxZWY2MGZjOWIxMDQxZjQkZXhwb3J0JGNhY2JiMzkyNDE1NWQ2OGUgZXh0ZW5kcyAoMCwgJGd0VzFUJExheW91dCkge1xuICAgIGdldExheW91dEluZm8oa2V5KSB7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLmxheW91dEluZm9zLmdldChrZXkpO1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGluZm8gd2Fzbid0IGZvdW5kLCBpdCBtaWdodCBiZSBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGFyZWEgdGhhdCB3ZSd2ZVxuICAgICAgICAvLyBjb21wdXRlZCBsYXlvdXQgZm9yIHNvIGZhci4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYWNjZXNzaW5nIGEgcmFuZG9tIGtleSwgZS5nIHByZXNzaW5nIEhvbWUvRW5kLlxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmdWxsIGxheW91dCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICBpZiAoIXJlcyAmJiB0aGlzLnZhbGlkUmVjdC5hcmVhIDwgdGhpcy5jb250ZW50U2l6ZS5hcmVhICYmIHRoaXMubGFzdENvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbGlkUmVjdCA9IHRoaXMudmFsaWRSZWN0O1xuICAgICAgICAgICAgdGhpcy52YWxpZFJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgwLCAwLCBJbmZpbml0eSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXMgPSB0aGlzLmJ1aWxkQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy52YWxpZFJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgwLCAwLCB0aGlzLmNvbnRlbnRTaXplLndpZHRoLCB0aGlzLmNvbnRlbnRTaXplLmhlaWdodCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLmxheW91dEluZm9zLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KSB7XG4gICAgICAgIC8vIElmIGxheW91dCBoYXNuJ3QgeWV0IGJlZW4gZG9uZSBmb3IgdGhlIHJlcXVlc3RlZCByZWN0LCB1bmlvbiB0aGVcbiAgICAgICAgLy8gbmV3IHJlY3Qgd2l0aCB0aGUgZXhpc3RpbmcgdmFsaWQgcmVjdCwgYW5kIHJlY29tcHV0ZS5cbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkUmVjdC5jb250YWluc1JlY3QocmVjdCkgJiYgdGhpcy5sYXN0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsaWRSZWN0ID0gdGhpcy52YWxpZFJlY3Q7XG4gICAgICAgICAgICB0aGlzLnZhbGlkUmVjdCA9IHRoaXMudmFsaWRSZWN0LnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXMgPSB0aGlzLmJ1aWxkQ29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgbGV0IGFkZE5vZGVzID0gKG5vZGVzKT0+e1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylpZiAodGhpcy5pc1Zpc2libGUobm9kZSwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhlYWRlcikgcmVzLnB1c2gobm9kZS5oZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSBhZGROb2Rlcyhub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkTm9kZXModGhpcy5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpc1Zpc2libGUobm9kZSwgcmVjdCkge1xuICAgICAgICByZXR1cm4gbm9kZS5sYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0cyhyZWN0KSB8fCBub2RlLmxheW91dEluZm8uaXNTdGlja3kgfHwgdGhpcy52aXJ0dWFsaXplci5pc1BlcnNpc3RlZEtleShub2RlLmxheW91dEluZm8ua2V5KTtcbiAgICB9XG4gICAgc2hvdWxkSW52YWxpZGF0ZUV2ZXJ5dGhpbmcoaW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGlmIHRoZSBzaXplIG9mIHRoZSBjb2xsZWN0aW9uIGNoYW5nZWQuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgZW50aXJlIGxheW91dC5cbiAgICAgICAgcmV0dXJuIGludmFsaWRhdGlvbkNvbnRleHQuc2l6ZUNoYW5nZWQ7XG4gICAgfVxuICAgIHZhbGlkYXRlKGludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy52aXJ0dWFsaXplci5jb2xsZWN0aW9uO1xuICAgICAgICAvLyBSZXNldCB2YWxpZCByZWN0IGlmIHdlIHdpbGwgaGF2ZSB0byBpbnZhbGlkYXRlIGV2ZXJ5dGhpbmcuXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gcmV1c2UgY2FjaGVkIGxheW91dCBpbmZvcyBvdXRzaWRlIHRoZSBjdXJyZW50IHZpc2libGUgcmVjdC5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRXZlcnl0aGluZyA9IHRoaXMuc2hvdWxkSW52YWxpZGF0ZUV2ZXJ5dGhpbmcoaW52YWxpZGF0aW9uQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmludmFsaWRhdGVFdmVyeXRoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWxpZFJlY3QgPSB0aGlzLnZhbGlkUmVjdDtcbiAgICAgICAgICAgIHRoaXMudmFsaWRSZWN0ID0gdGhpcy52aXJ0dWFsaXplci5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gdGhpcy5idWlsZENvbGxlY3Rpb24oKTtcbiAgICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgbGF5b3V0IG5vZGVzXG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2xsZWN0aW9uICYmIHRoaXMuY29sbGVjdGlvbiAhPT0gdGhpcy5sYXN0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMubGFzdENvbGxlY3Rpb24uZ2V0S2V5cygpKWlmICghdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkge1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5sYXlvdXROb2Rlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xheW91dE5vZGVfaGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dEluZm9zLmRlbGV0ZShsYXlvdXROb2RlLmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5kZWxldGUoKF9sYXlvdXROb2RlX2hlYWRlciA9IGxheW91dE5vZGUuaGVhZGVyKSA9PT0gbnVsbCB8fCBfbGF5b3V0Tm9kZV9oZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXlvdXROb2RlX2hlYWRlci5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dE5vZGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdENvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUV2ZXJ5dGhpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYnVpbGRDb2xsZWN0aW9uKCkge1xuICAgICAgICBsZXQgeSA9IHRoaXMucGFkZGluZztcbiAgICAgICAgbGV0IHNraXBwZWQgPSAwO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLmNvbGxlY3Rpb24pe1xuICAgICAgICAgICAgdmFyIF90aGlzX3Jvd0hlaWdodDtcbiAgICAgICAgICAgIGxldCByb3dIZWlnaHQgPSAoX3RoaXNfcm93SGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX3RoaXNfcm93SGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQ7XG4gICAgICAgICAgICAvLyBTa2lwIHJvd3MgYmVmb3JlIHRoZSB2YWxpZCByZWN0YW5nbGUgdW5sZXNzIHRoZXkgYXJlIGFscmVhZHkgY2FjaGVkLlxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIgJiYgeSArIHJvd0hlaWdodCA8IHRoaXMudmFsaWRSZWN0LnkgJiYgIXRoaXMuaXNWYWxpZChub2RlLCB5KSkge1xuICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKG5vZGUsIDAsIHkpO1xuICAgICAgICAgICAgeSA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFk7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGxheW91dE5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIgJiYgeSA+IHRoaXMudmFsaWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICB5ICs9ICh0aGlzLmNvbGxlY3Rpb24uc2l6ZSAtIChub2Rlcy5sZW5ndGggKyBza2lwcGVkKSkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfbG9hZGVySGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgwLCB5LCB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoLCAoX3RoaXNfbG9hZGVySGVpZ2h0ID0gdGhpcy5sb2FkZXJIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX2xvYWRlckhlaWdodCAhPT0gdm9pZCAwID8gX3RoaXNfbG9hZGVySGVpZ2h0IDogdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgbGV0IGxvYWRlciA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwibG9hZGVyXCIsIFwibG9hZGVyXCIsIHJlY3QpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoXCJsb2FkZXJcIiwgbG9hZGVyKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxvYWRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5ID0gbG9hZGVyLnJlY3QubWF4WTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcGxhY2Vob2xkZXJIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKDAsIHksIHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGgsIChfdGhpc19wbGFjZWhvbGRlckhlaWdodCA9IHRoaXMucGxhY2Vob2xkZXJIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX3BsYWNlaG9sZGVySGVpZ2h0ICE9PSB2b2lkIDAgPyBfdGhpc19wbGFjZWhvbGRlckhlaWdodCA6IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwicGxhY2Vob2xkZXJcIiwgXCJwbGFjZWhvbGRlclwiLCByZWN0KTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0SW5mb3Muc2V0KFwicGxhY2Vob2xkZXJcIiwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeSA9IHBsYWNlaG9sZGVyLnJlY3QubWF4WTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkZ3RXMVQkU2l6ZSkodGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCwgeSArIHRoaXMucGFkZGluZyk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaXNWYWxpZChub2RlLCB5KSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgIHJldHVybiAhdGhpcy5pbnZhbGlkYXRlRXZlcnl0aGluZyAmJiBjYWNoZWQgJiYgY2FjaGVkLm5vZGUgPT09IG5vZGUgJiYgeSA9PT0gKGNhY2hlZC5oZWFkZXIgfHwgY2FjaGVkLmxheW91dEluZm8pLnJlY3QueSAmJiBjYWNoZWQubGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHModGhpcy5sYXN0VmFsaWRSZWN0KSAmJiBjYWNoZWQudmFsaWRSZWN0LmNvbnRhaW5zUmVjdChjYWNoZWQubGF5b3V0SW5mby5yZWN0LmludGVyc2VjdGlvbih0aGlzLnZhbGlkUmVjdCkpO1xuICAgIH1cbiAgICBidWlsZENoaWxkKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZChub2RlLCB5KSkgcmV0dXJuIHRoaXMubGF5b3V0Tm9kZXMuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmJ1aWxkTm9kZShub2RlLCB4LCB5KTtcbiAgICAgICAgbGF5b3V0Tm9kZS5ub2RlID0gbm9kZTtcbiAgICAgICAgdmFyIF9ub2RlX3BhcmVudEtleTtcbiAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnBhcmVudEtleSA9IChfbm9kZV9wYXJlbnRLZXkgPSBub2RlLnBhcmVudEtleSkgIT09IG51bGwgJiYgX25vZGVfcGFyZW50S2V5ICE9PSB2b2lkIDAgPyBfbm9kZV9wYXJlbnRLZXkgOiBudWxsO1xuICAgICAgICB0aGlzLmxheW91dEluZm9zLnNldChsYXlvdXROb2RlLmxheW91dEluZm8ua2V5LCBsYXlvdXROb2RlLmxheW91dEluZm8pO1xuICAgICAgICBpZiAobGF5b3V0Tm9kZS5oZWFkZXIpIHRoaXMubGF5b3V0SW5mb3Muc2V0KGxheW91dE5vZGUuaGVhZGVyLmtleSwgbGF5b3V0Tm9kZS5oZWFkZXIpO1xuICAgICAgICB0aGlzLmxheW91dE5vZGVzLnNldChub2RlLmtleSwgbGF5b3V0Tm9kZSk7XG4gICAgICAgIHJldHVybiBsYXlvdXROb2RlO1xuICAgIH1cbiAgICBidWlsZE5vZGUobm9kZSwgeCwgeSkge1xuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJzZWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTZWN0aW9uKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgY2FzZSBcIml0ZW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEl0ZW0obm9kZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRTZWN0aW9uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aDtcbiAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSB0aGlzLmhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIGxldCBpc0VzdGltYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBoZWlnaHQgaXMgYXZhaWxhYmxlLCB1c2UgYW4gZXN0aW1hdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKHJlY3RIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgYSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbGF5b3V0IGluZm8gZXhpc3RzLCByZXVzZSBpdHMgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gTWFyayBhcyBlc3RpbWF0ZWQgaWYgdGhlIHNpemUgb2YgdGhlIG92ZXJhbGwgY29sbGVjdGlvbiB2aWV3IGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBvciB0aGUgY29udGVudCBvZiB0aGUgaXRlbSBjaGFuZ2VkLlxuICAgICAgICAgICAgbGV0IHByZXZpb3VzTGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xheW91dE5vZGUgJiYgcHJldmlvdXNMYXlvdXROb2RlLmhlYWRlcikge1xuICAgICAgICAgICAgICAgIGxldCBjdXJOb2RlID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5rZXkpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0Tm9kZSA9IHRoaXMubGFzdENvbGxlY3Rpb24gPyB0aGlzLmxhc3RDb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5rZXkpIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gcHJldmlvdXNMYXlvdXROb2RlLmhlYWRlci5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpc0VzdGltYXRlZCA9IHdpZHRoICE9PSB0aGlzLmxhc3RXaWR0aCB8fCBjdXJOb2RlICE9PSBsYXN0Tm9kZSB8fCBwcmV2aW91c0xheW91dE5vZGUuaGVhZGVyLmVzdGltYXRlZFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY3RIZWlnaHQgPSBub2RlLnJlbmRlcmVkID8gdGhpcy5lc3RpbWF0ZWRIZWFkaW5nSGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpc0VzdGltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3RIZWlnaHQgPT0gbnVsbCkgcmVjdEhlaWdodCA9ICQ2MWVmNjBmYzliMTA0MWY0JHZhciRERUZBVUxUX0hFSUdIVDtcbiAgICAgICAgbGV0IGhlYWRlclJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgwLCB5LCB3aWR0aCwgcmVjdEhlaWdodCk7XG4gICAgICAgIGxldCBoZWFkZXIgPSBuZXcgKDAsICRndFcxVCRMYXlvdXRJbmZvKShcImhlYWRlclwiLCBub2RlLmtleSArIFwiOmhlYWRlclwiLCBoZWFkZXJSZWN0KTtcbiAgICAgICAgaGVhZGVyLmVzdGltYXRlZFNpemUgPSBpc0VzdGltYXRlZDtcbiAgICAgICAgaGVhZGVyLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICB5ICs9IGhlYWRlci5yZWN0LmhlaWdodDtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgwLCB5LCB3aWR0aCwgMCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkZ3RXMVQkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxldCBzdGFydFkgPSB5O1xuICAgICAgICBsZXQgc2tpcHBlZCA9IDA7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiAoMCwgJGd0VzFUJGdldENoaWxkTm9kZXMpKG5vZGUsIHRoaXMuY29sbGVjdGlvbikpe1xuICAgICAgICAgICAgdmFyIF90aGlzX3Jvd0hlaWdodDtcbiAgICAgICAgICAgIGxldCByb3dIZWlnaHQgPSAoX3RoaXNfcm93SGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX3RoaXNfcm93SGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQ7XG4gICAgICAgICAgICAvLyBTa2lwIHJvd3MgYmVmb3JlIHRoZSB2YWxpZCByZWN0YW5nbGUgdW5sZXNzIHRoZXkgYXJlIGFscmVhZHkgY2FjaGVkLlxuICAgICAgICAgICAgaWYgKHkgKyByb3dIZWlnaHQgPCB0aGlzLnZhbGlkUmVjdC55ICYmICF0aGlzLmlzVmFsaWQobm9kZSwgeSkpIHtcbiAgICAgICAgICAgICAgICB5ICs9IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICB5ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAoeSA+IHRoaXMudmFsaWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGUgcmVtYWluaW5nIGhlaWdodCBmb3Igcm93cyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbGF5b3V0IHJpZ2h0IG5vdy5cbiAgICAgICAgICAgICAgICB5ICs9IChbXG4gICAgICAgICAgICAgICAgICAgIC4uLigwLCAkZ3RXMVQkZ2V0Q2hpbGROb2Rlcykobm9kZSwgdGhpcy5jb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIF0ubGVuZ3RoIC0gKGNoaWxkcmVuLmxlbmd0aCArIHNraXBwZWQpKSAqIHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWN0LmhlaWdodCA9IHkgLSBzdGFydFk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdC5pbnRlcnNlY3Rpb24odGhpcy52YWxpZFJlY3QpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSXRlbShub2RlLCB4LCB5KSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIGxldCByZWN0SGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQ7XG4gICAgICAgIGxldCBpc0VzdGltYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBoZWlnaHQgaXMgYXZhaWxhYmxlLCB1c2UgYW4gZXN0aW1hdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKHJlY3RIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgYSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbGF5b3V0IGluZm8gZXhpc3RzLCByZXVzZSBpdHMgaGVpZ2h0LlxuICAgICAgICAgICAgLy8gTWFyayBhcyBlc3RpbWF0ZWQgaWYgdGhlIHNpemUgb2YgdGhlIG92ZXJhbGwgY29sbGVjdGlvbiB2aWV3IGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBvciB0aGUgY29udGVudCBvZiB0aGUgaXRlbSBjaGFuZ2VkLlxuICAgICAgICAgICAgbGV0IHByZXZpb3VzTGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xheW91dE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0ID0gcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB3aWR0aCAhPT0gdGhpcy5sYXN0V2lkdGggfHwgbm9kZSAhPT0gcHJldmlvdXNMYXlvdXROb2RlLm5vZGUgfHwgcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8uZXN0aW1hdGVkU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjdEhlaWdodCA9IHRoaXMuZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzRXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdEhlaWdodCA9PSBudWxsKSByZWN0SGVpZ2h0ID0gJDYxZWY2MGZjOWIxMDQxZjQkdmFyJERFRkFVTFRfSEVJR0hUO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5kZW50YXRpb25Gb3JJdGVtID09PSBcImZ1bmN0aW9uXCIpIHggKz0gdGhpcy5pbmRlbnRhdGlvbkZvckl0ZW0odGhpcy5jb2xsZWN0aW9uLCBub2RlLmtleSkgfHwgMDtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSh4LCB5LCB3aWR0aCAtIHgsIHJlY3RIZWlnaHQpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKG5vZGUudHlwZSwgbm9kZS5rZXksIHJlY3QpO1xuICAgICAgICAvLyBhbGxvdyBvdmVyZmxvdyBzbyB0aGUgZm9jdXMgcmluZy9zZWxlY3Rpb24gcmluZyBjYW4gZXh0ZW5kIG91dHNpZGUgdG8gb3ZlcmxhcCB3aXRoIHRoZSBhZGphY2VudCBpdGVtcyBib3JkZXJzXG4gICAgICAgIGxheW91dEluZm8uYWxsb3dPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIGxheW91dEluZm8uZXN0aW1hdGVkU2l6ZSA9IGlzRXN0aW1hdGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgIHZhbGlkUmVjdDogbGF5b3V0SW5mby5yZWN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgIC8vIElmIG5vIGxheW91dEluZm8sIGl0ZW0gaGFzIGJlZW4gZGVsZXRlZC9yZW1vdmVkLlxuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIGlmIChsYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gQ29weSBsYXlvdXQgaW5mbyByYXRoZXIgdGhhbiBtdXRhdGluZyBzbyB0aGF0IGxhdGVyIGNhY2hlcyBhcmUgaW52YWxpZGF0ZWQuXG4gICAgICAgICAgICBsZXQgbmV3TGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbmV3TGF5b3V0SW5mby5yZWN0LmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoa2V5LCBuZXdMYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgbGF5b3V0IGZvciB0aGlzIGxheW91dCBub2RlIGFuZCBhbGwgcGFyZW50c1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXlvdXROb2RlKGtleSwgbGF5b3V0SW5mbywgbmV3TGF5b3V0SW5mbyk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGxheW91dEluZm8ucGFyZW50S2V5KTtcbiAgICAgICAgICAgIHdoaWxlKG5vZGUpe1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGF5b3V0Tm9kZShub2RlLmtleSwgbGF5b3V0SW5mbywgbmV3TGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKG5vZGUucGFyZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlTGF5b3V0Tm9kZShrZXksIG9sZExheW91dEluZm8sIG5ld0xheW91dEluZm8pIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLmxheW91dE5vZGVzLmdldChrZXkpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBieSByZXNldGluZyB2YWxpZFJlY3QuXG4gICAgICAgICAgICBuLnZhbGlkUmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKCk7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGxheW91dCBpbmZvIGluIExheW91dE5vZGVcbiAgICAgICAgICAgIGlmIChuLmhlYWRlciA9PT0gb2xkTGF5b3V0SW5mbykgbi5oZWFkZXIgPSBuZXdMYXlvdXRJbmZvO1xuICAgICAgICAgICAgZWxzZSBpZiAobi5sYXlvdXRJbmZvID09PSBvbGRMYXlvdXRJbmZvKSBuLmxheW91dEluZm8gPSBuZXdMYXlvdXRJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5QWJvdmUoa2V5KSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xuICAgICAgICBrZXkgPSBjb2xsZWN0aW9uLmdldEtleUJlZm9yZShrZXkpO1xuICAgICAgICB3aGlsZShrZXkgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIgJiYgKHRoaXMuYWxsb3dEaXNhYmxlZEtleUZvY3VzIHx8ICF0aGlzLmRpc2FibGVkS2V5cy5oYXMoaXRlbS5rZXkpKSkgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIGtleSA9IGNvbGxlY3Rpb24uZ2V0S2V5QmVmb3JlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0S2V5QmVsb3coa2V5KSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xuICAgICAgICBrZXkgPSBjb2xsZWN0aW9uLmdldEtleUFmdGVyKGtleSk7XG4gICAgICAgIHdoaWxlKGtleSAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIml0ZW1cIiAmJiAodGhpcy5hbGxvd0Rpc2FibGVkS2V5Rm9jdXMgfHwgIXRoaXMuZGlzYWJsZWRLZXlzLmhhcyhpdGVtLmtleSkpKSByZXR1cm4ga2V5O1xuICAgICAgICAgICAga2V5ID0gY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEtleVBhZ2VBYm92ZShrZXkpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKGxheW91dEluZm8pIHtcbiAgICAgICAgICAgIGxldCBwYWdlWSA9IE1hdGgubWF4KDAsIGxheW91dEluZm8ucmVjdC55ICsgbGF5b3V0SW5mby5yZWN0LmhlaWdodCAtIHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIHdoaWxlKGxheW91dEluZm8gJiYgbGF5b3V0SW5mby5yZWN0LnkgPiBwYWdlWSl7XG4gICAgICAgICAgICAgICAgbGV0IGtleUFib3ZlID0gdGhpcy5nZXRLZXlBYm92ZShsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXlBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mbykgcmV0dXJuIGxheW91dEluZm8ua2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpcnN0S2V5KCk7XG4gICAgfVxuICAgIGdldEtleVBhZ2VCZWxvdyhrZXkpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8oa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmdldEZpcnN0S2V5KCkpO1xuICAgICAgICBpZiAobGF5b3V0SW5mbykge1xuICAgICAgICAgICAgbGV0IHBhZ2VZID0gTWF0aC5taW4odGhpcy52aXJ0dWFsaXplci5jb250ZW50U2l6ZS5oZWlnaHQsIGxheW91dEluZm8ucmVjdC55IC0gbGF5b3V0SW5mby5yZWN0LmhlaWdodCArIHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIHdoaWxlKGxheW91dEluZm8gJiYgbGF5b3V0SW5mby5yZWN0LnkgPCBwYWdlWSl7XG4gICAgICAgICAgICAgICAgbGV0IGtleUJlbG93ID0gdGhpcy5nZXRLZXlCZWxvdyhsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXlCZWxvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mbykgcmV0dXJuIGxheW91dEluZm8ua2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldExhc3RLZXkoKTtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xuICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpO1xuICAgICAgICB3aGlsZShrZXkgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIgJiYgKHRoaXMuYWxsb3dEaXNhYmxlZEtleUZvY3VzIHx8ICF0aGlzLmRpc2FibGVkS2V5cy5oYXMoaXRlbS5rZXkpKSkgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIGtleSA9IGNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpO1xuICAgICAgICB3aGlsZShrZXkgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIgJiYgKHRoaXMuYWxsb3dEaXNhYmxlZEtleUZvY3VzIHx8ICF0aGlzLmRpc2FibGVkS2V5cy5oYXMoaXRlbS5rZXkpKSkgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIGtleSA9IGNvbGxlY3Rpb24uZ2V0S2V5QmVmb3JlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0S2V5Rm9yU2VhcmNoKHNlYXJjaCwgZnJvbUtleSkge1xuICAgICAgICBpZiAoIXRoaXMuY29sbGF0b3IpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IGtleSA9IGZyb21LZXkgfHwgdGhpcy5nZXRGaXJzdEtleSgpO1xuICAgICAgICB3aGlsZShrZXkgIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgbGV0IHN1YnN0cmluZyA9IGl0ZW0udGV4dFZhbHVlLnNsaWNlKDAsIHNlYXJjaC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0udGV4dFZhbHVlICYmIHRoaXMuY29sbGF0b3IuY29tcGFyZShzdWJzdHJpbmcsIHNlYXJjaCkgPT09IDApIHJldHVybiBrZXk7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldEtleUJlbG93KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgbGF5b3V0SW5mby5vcGFjaXR5ID0gMDtcbiAgICAgICAgbGF5b3V0SW5mby50cmFuc2Zvcm0gPSBcInNjYWxlM2QoMC44LCAwLjgsIDAuOClcIjtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxuICAgIGdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIGxheW91dEluZm8ub3BhY2l0eSA9IDA7XG4gICAgICAgIGxheW91dEluZm8udHJhbnNmb3JtID0gXCJzY2FsZTNkKDAuOCwgMC44LCAwLjgpXCI7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbiAgICBnZXREcm9wVGFyZ2V0RnJvbVBvaW50KHgsIHksIGlzVmFsaWREcm9wVGFyZ2V0KSB7XG4gICAgICAgIHggKz0gdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC54O1xuICAgICAgICB5ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueTtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMudmlydHVhbGl6ZXIua2V5QXRQb2ludChuZXcgKDAsICRndFcxVCRQb2ludCkoeCwgeSkpO1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLnNpemUgPT09IDApIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJvb3RcIlxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBsZXQgcmVjdCA9IGxheW91dEluZm8ucmVjdDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAga2V5OiBsYXlvdXRJbmZvLmtleSxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJvblwiXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzbid0IGFjY2VwdGVkLCB0cnkgdGhlIHRhcmdldCBiZWZvcmUgb3IgYWZ0ZXIgZGVwZW5kaW5nIG9uIHRoZSB5IHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzIGFjY2VwdGVkLCBzdGlsbCB0cnkgdGhlIGJlZm9yZS9hZnRlciBwb3NpdGlvbnMgaWYgd2l0aGluIDEwcHhcbiAgICAgICAgLy8gb2YgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIGl0ZW0uXG4gICAgICAgIGlmICghaXNWYWxpZERyb3BUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiBcImJlZm9yZVwiXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYmVmb3JlXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJhZnRlclwiXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYWZ0ZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmICh5IDw9IHJlY3QueSArIDEwICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJiZWZvcmVcIlxuICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYmVmb3JlXCI7XG4gICAgICAgIGVsc2UgaWYgKHkgPj0gcmVjdC5tYXhZIC0gMTAgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiBcImFmdGVyXCJcbiAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSBcImFmdGVyXCI7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IExpc3RMYXlvdXQgd2l0aCBvcHRpb25zLiBTZWUgdGhlIGxpc3Qgb2YgcHJvcGVydGllcyBiZWxvdyBmb3IgYSBkZXNjcmlwdGlvblxuICAgKiBvZiB0aGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZC5cbiAgICovIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFsbG93RGlzYWJsZWRLZXlGb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IG9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCA9IG9wdGlvbnMuZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgICAgICB0aGlzLmhlYWRpbmdIZWlnaHQgPSBvcHRpb25zLmhlYWRpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCA9IG9wdGlvbnMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodDtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nIHx8IDA7XG4gICAgICAgIHRoaXMuaW5kZW50YXRpb25Gb3JJdGVtID0gb3B0aW9ucy5pbmRlbnRhdGlvbkZvckl0ZW07XG4gICAgICAgIHRoaXMuY29sbGF0b3IgPSBvcHRpb25zLmNvbGxhdG9yO1xuICAgICAgICB0aGlzLmxvYWRlckhlaWdodCA9IG9wdGlvbnMubG9hZGVySGVpZ2h0O1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVySGVpZ2h0ID0gb3B0aW9ucy5wbGFjZWhvbGRlckhlaWdodDtcbiAgICAgICAgdGhpcy5sYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sYXlvdXROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd0Rpc2FibGVkS2V5Rm9jdXMgPSBvcHRpb25zLmFsbG93RGlzYWJsZWRLZXlGb2N1cztcbiAgICAgICAgdGhpcy5sYXN0VmFsaWRSZWN0ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkoKTtcbiAgICAgICAgdGhpcy52YWxpZFJlY3QgPSBuZXcgKDAsICRndFcxVCRSZWN0KSgpO1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gbmV3ICgwLCAkZ3RXMVQkU2l6ZSkoKTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmNsYXNzICRhMTUyMTEyZTkwMjcwOWJmJGV4cG9ydCQ2MjQ0NGMzYzcyNGIxYjIwIGV4dGVuZHMgKDAsICQ2MWVmNjBmYzliMTA0MWY0JGV4cG9ydCRjYWNiYjM5MjQxNTVkNjhlKSB7XG4gICAgc2hvdWxkSW52YWxpZGF0ZUV2ZXJ5dGhpbmcoaW52YWxpZGF0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyBJZiBjb2x1bW5zIGNoYW5nZWQsIGNsZWFyIGxheW91dCBjYWNoZS5cbiAgICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZEludmFsaWRhdGVFdmVyeXRoaW5nKGludmFsaWRhdGlvbkNvbnRleHQpIHx8ICF0aGlzLmxhc3RDb2xsZWN0aW9uIHx8IHRoaXMuY29sbGVjdGlvbi5jb2x1bW5zLmxlbmd0aCAhPT0gdGhpcy5sYXN0Q29sbGVjdGlvbi5jb2x1bW5zLmxlbmd0aCB8fCB0aGlzLmNvbGxlY3Rpb24uY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IHRoaXMubGFzdENvbGxlY3Rpb24uY29sdW1uc1tpXS5rZXkgfHwgYy5wcm9wcy53aWR0aCAhPT0gdGhpcy5sYXN0Q29sbGVjdGlvbi5jb2x1bW5zW2ldLnByb3BzLndpZHRoIHx8IGMucHJvcHMubWluV2lkdGggIT09IHRoaXMubGFzdENvbGxlY3Rpb24uY29sdW1uc1tpXS5wcm9wcy5taW5XaWR0aCB8fCBjLnByb3BzLm1heFdpZHRoICE9PSB0aGlzLmxhc3RDb2xsZWN0aW9uLmNvbHVtbnNbaV0ucHJvcHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBnZXRSZXNpemVyUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBfdGhpc19nZXRMYXlvdXRJbmZvO1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldExheW91dEluZm8gPSB0aGlzLmdldExheW91dEluZm8odGhpcy5yZXNpemluZ0NvbHVtbikpID09PSBudWxsIHx8IF90aGlzX2dldExheW91dEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2dldExheW91dEluZm8ucmVjdC5tYXhYO1xuICAgIH1cbiAgICBnZXRDb2x1bW5XaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbkxheW91dF9nZXRDb2x1bW5XaWR0aDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5MYXlvdXRfZ2V0Q29sdW1uV2lkdGggPSB0aGlzLmNvbHVtbkxheW91dC5nZXRDb2x1bW5XaWR0aChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5MYXlvdXRfZ2V0Q29sdW1uV2lkdGggIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbkxheW91dF9nZXRDb2x1bW5XaWR0aCA6IDA7XG4gICAgfVxuICAgIGdldENvbHVtbk1pbldpZHRoKGtleSkge1xuICAgICAgICBsZXQgY29sdW1uID0gdGhpcy5jb2xsZWN0aW9uLmNvbHVtbnMuZmluZCgoY29sKT0+Y29sLmtleSA9PT0ga2V5KTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWluV2lkdGgoa2V5KTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uTWF4V2lkdGgoa2V5KSB7XG4gICAgICAgIGxldCBjb2x1bW4gPSB0aGlzLmNvbGxlY3Rpb24uY29sdW1ucy5maW5kKChjb2wpPT5jb2wua2V5ID09PSBrZXkpO1xuICAgICAgICBpZiAoIWNvbHVtbikgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkxheW91dC5nZXRDb2x1bW5NYXhXaWR0aChrZXkpO1xuICAgIH1cbiAgICAvLyBvdXRzaWRlLCB3aGVyZSB0aGlzIGlzIGNhbGxlZCwgc2hvdWxkIGNhbGwgcHJvcHMub25Db2x1bW5SZXNpemVTdGFydC4uLlxuICAgIHN0YXJ0UmVzaXplKGtleSkge1xuICAgICAgICB0aGlzLnJlc2l6aW5nQ29sdW1uID0ga2V5O1xuICAgIH1cbiAgICAvLyBvbmx5IHdheSB0byBjYWxsIHByb3BzLm9uQ29sdW1uUmVzaXplIHdpdGggdGhlIG5ldyBzaXplIG91dHNpZGUgb2YgTGF5b3V0IGlzIHRvIHNlbmQgdGhlIHJlc3VsdCBiYWNrXG4gICAgdXBkYXRlUmVzaXplZENvbHVtbnMoa2V5LCB3aWR0aCkge1xuICAgICAgICBsZXQgbmV3Q29udHJvbGxlZCA9IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGVudHJ5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgZW50cnkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbGV0IG5ld1NpemVzID0gdGhpcy5jb2x1bW5MYXlvdXQucmVzaXplQ29sdW1uV2lkdGgodGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5jb2xsZWN0aW9uLCBuZXdDb250cm9sbGVkLCB0aGlzLnVuY29udHJvbGxlZFdpZHRocywga2V5LCB3aWR0aCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKEFycmF5LmZyb20odGhpcy51bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXldKT0+W1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBuZXdTaXplcy5nZXQoa2V5KVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBtYXAuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB0aGlzLnVuY29udHJvbGxlZFdpZHRocyA9IG1hcDtcbiAgICAgICAgLy8gcmVsYXlvdXROb3cgc3RpbGwgdXNlcyBzZXRTdGF0ZSwgc2hvdWxkIGhhcHBlbiBhdCB0aGUgc2FtZSB0aW1lIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gY29tcG9uZW50J3Mgc3RhdGUgaXMgcHJvY2Vzc2VkIGFzIGEgcmVzdWx0IG9mIHByb3BzLm9uQ29sdW1uUmVzaXplXG4gICAgICAgIGlmICh0aGlzLnVuY29udHJvbGxlZFdpZHRocy5zaXplID4gMCkgdGhpcy52aXJ0dWFsaXplci5yZWxheW91dE5vdyh7XG4gICAgICAgICAgICBzaXplQ2hhbmdlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1NpemVzO1xuICAgIH1cbiAgICBlbmRSZXNpemUoKSB7XG4gICAgICAgIHRoaXMucmVzaXppbmdDb2x1bW4gPSBudWxsO1xuICAgIH1cbiAgICBidWlsZENvbGxlY3Rpb24oKSB7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgd2Ugd2VyZSBwcmV2aW91c2x5IGxvYWRpbmcuIFRoaXMgaXMgdXNlZCB0byBhZGp1c3QgdGhlIGFuaW1hdGlvbnMgb2YgYXN5bmMgbG9hZGluZyB2cyBpbnNlcnRzLlxuICAgICAgICBsZXQgbG9hZGluZ1N0YXRlID0gdGhpcy5jb2xsZWN0aW9uLmJvZHkucHJvcHMubG9hZGluZ1N0YXRlO1xuICAgICAgICB0aGlzLndhc0xvYWRpbmcgPSB0aGlzLmlzTG9hZGluZztcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBsb2FkaW5nU3RhdGUgPT09IFwibG9hZGluZ1wiIHx8IGxvYWRpbmdTdGF0ZSA9PT0gXCJsb2FkaW5nTW9yZVwiO1xuICAgICAgICB0aGlzLnN0aWNreUNvbHVtbkluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIHRoaXMuY29sbGVjdGlvbi5jb2x1bW5zKS8vIFRoZSBzZWxlY3Rpb24gY2VsbCBhbmQgYW55IG90aGVyIHN0aWNreSBjb2x1bW5zIGFsd2F5cyBuZWVkIHRvIGJlIHZpc2libGUuXG4gICAgICAgIC8vIEluIGFkZGl0aW9uLCByb3cgaGVhZGVycyBuZWVkIHRvIGJlIGluIHRoZSBET00gZm9yIGFjY2Vzc2liaWxpdHkgbGFiZWxpbmcuXG4gICAgICAgIGlmIChjb2x1bW4ucHJvcHMuaXNEcmFnQnV0dG9uQ2VsbCB8fCBjb2x1bW4ucHJvcHMuaXNTZWxlY3Rpb25DZWxsIHx8IHRoaXMuY29sbGVjdGlvbi5yb3dIZWFkZXJDb2x1bW5LZXlzLmhhcyhjb2x1bW4ua2V5KSkgdGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzLnB1c2goY29sdW1uLmluZGV4KTtcbiAgICAgICAgbGV0IFtjb250cm9sbGVkQ29sdW1ucywgdW5jb250cm9sbGVkQ29sdW1uc10gPSB0aGlzLmNvbHVtbkxheW91dC5zcGxpdENvbHVtbnNJbnRvQ29udHJvbGxlZEFuZFVuY29udHJvbGxlZCh0aGlzLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlZENvbHVtbnMgPSBjb250cm9sbGVkQ29sdW1ucztcbiAgICAgICAgdGhpcy51bmNvbnRyb2xsZWRDb2x1bW5zID0gdW5jb250cm9sbGVkQ29sdW1ucztcbiAgICAgICAgbGV0IGNvbFdpZHRocyA9IHRoaXMuY29sdW1uTGF5b3V0LnJlY29tYmluZUNvbHVtbnModGhpcy5jb2xsZWN0aW9uLmNvbHVtbnMsIHRoaXMudW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gdGhpcy5jb2x1bW5MYXlvdXQuYnVpbGRDb2x1bW5XaWR0aHModGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5jb2xsZWN0aW9uLCBjb2xXaWR0aHMpO1xuICAgICAgICBsZXQgaGVhZGVyID0gdGhpcy5idWlsZEhlYWRlcigpO1xuICAgICAgICBsZXQgYm9keSA9IHRoaXMuYnVpbGRCb2R5KDApO1xuICAgICAgICB0aGlzLmxhc3RQZXJzaXN0ZWRLZXlzID0gbnVsbDtcbiAgICAgICAgYm9keS5sYXlvdXRJbmZvLnJlY3Qud2lkdGggPSBNYXRoLm1heChoZWFkZXIubGF5b3V0SW5mby5yZWN0LndpZHRoLCBib2R5LmxheW91dEluZm8ucmVjdC53aWR0aCk7XG4gICAgICAgIHRoaXMuY29udGVudFNpemUgPSBuZXcgKDAsICRndFcxVCRTaXplKShib2R5LmxheW91dEluZm8ucmVjdC53aWR0aCwgYm9keS5sYXlvdXRJbmZvLnJlY3QubWF4WSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgIF07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVyKCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKDAsIDAsIDAsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwiaGVhZGVyXCIsIFwiaGVhZGVyXCIsIHJlY3QpO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBoZWFkZXJSb3cgb2YgdGhpcy5jb2xsZWN0aW9uLmhlYWRlclJvd3Mpe1xuICAgICAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmJ1aWxkQ2hpbGQoaGVhZGVyUm93LCAwLCB5KTtcbiAgICAgICAgICAgIGxheW91dE5vZGUubGF5b3V0SW5mby5wYXJlbnRLZXkgPSBcImhlYWRlclwiO1xuICAgICAgICAgICAgeSA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aCk7XG4gICAgICAgICAgICBsYXlvdXROb2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsYXlvdXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0geTtcbiAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoXCJoZWFkZXJcIiwgbGF5b3V0SW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRIZWFkZXJSb3coaGVhZGVyUm93LCB4LCB5KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkoMCwgeSwgMCwgMCk7XG4gICAgICAgIGxldCByb3cgPSBuZXcgKDAsICRndFcxVCRMYXlvdXRJbmZvKShcImhlYWRlcnJvd1wiLCBoZWFkZXJSb3cua2V5LCByZWN0KTtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgKDAsICRndFcxVCRnZXRDaGlsZE5vZGVzKShoZWFkZXJSb3csIHRoaXMuY29sbGVjdGlvbikpe1xuICAgICAgICAgICAgbGV0IGxheW91dE5vZGUgPSB0aGlzLmJ1aWxkQ2hpbGQoY2VsbCwgeCwgeSk7XG4gICAgICAgICAgICBsYXlvdXROb2RlLmxheW91dEluZm8ucGFyZW50S2V5ID0gcm93LmtleTtcbiAgICAgICAgICAgIHggPSBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5tYXhYO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5pbmRleCA9IGNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKGxheW91dE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtpLCBsYXlvdXRdIG9mIGNvbHVtbnMuZW50cmllcygpKWxheW91dC5sYXlvdXRJbmZvLnpJbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gaSArIDE7XG4gICAgICAgIHRoaXMuc2V0Q2hpbGRIZWlnaHRzKGNvbHVtbnMsIGhlaWdodCk7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZWN0LndpZHRoID0geDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IHJvdyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjb2x1bW5zLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldENoaWxkSGVpZ2h0cyhjaGlsZHJlbiwgaGVpZ2h0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKWlmIChjaGlsZC5sYXlvdXRJbmZvLnJlY3QuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY29weSB0aGUgbGF5b3V0IGluZm8gYmVmb3JlIHdlIG11dGF0ZSBpdC5cbiAgICAgICAgICAgIGNoaWxkLmxheW91dEluZm8gPSBjaGlsZC5sYXlvdXRJbmZvLmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0SW5mb3Muc2V0KGNoaWxkLmxheW91dEluZm8ua2V5LCBjaGlsZC5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIGNoaWxkLmxheW91dEluZm8ucmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCB0byBnZXQgdGhlIGNvbHVtbiB3aWR0aHMgd2hlbiByZW5kZXJpbmcgdG8gdGhlIERPTVxuICAgIGdldFJlbmRlcmVkQ29sdW1uV2lkdGgobm9kZSkge1xuICAgICAgICB2YXIgX25vZGVfY29sc3BhbjtcbiAgICAgICAgbGV0IGNvbHNwYW4gPSAoX25vZGVfY29sc3BhbiA9IG5vZGUuY29sc3BhbikgIT09IG51bGwgJiYgX25vZGVfY29sc3BhbiAhPT0gdm9pZCAwID8gX25vZGVfY29sc3BhbiA6IDE7XG4gICAgICAgIHZhciBfbm9kZV9jb2xJbmRleDtcbiAgICAgICAgbGV0IGNvbEluZGV4ID0gKF9ub2RlX2NvbEluZGV4ID0gbm9kZS5jb2xJbmRleCkgIT09IG51bGwgJiYgX25vZGVfY29sSW5kZXggIT09IHZvaWQgMCA/IF9ub2RlX2NvbEluZGV4IDogbm9kZS5pbmRleDtcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gY29sSW5kZXg7IGkgPCBjb2xJbmRleCArIGNvbHNwYW47IGkrKyl7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gdGhpcy5jb2xsZWN0aW9uLmNvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoKGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbi5rZXkpICE9IG51bGwpIHdpZHRoICs9IHRoaXMuY29sdW1uV2lkdGhzLmdldChjb2x1bW4ua2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIGdldEVzdGltYXRlZEhlaWdodChub2RlLCB3aWR0aCwgaGVpZ2h0LCBlc3RpbWF0ZWRIZWlnaHQpIHtcbiAgICAgICAgbGV0IGlzRXN0aW1hdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGhlaWdodCBpcyBhdmFpbGFibGUsIHVzZSBhbiBlc3RpbWF0ZWQgaGVpZ2h0LlxuICAgICAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIGxheW91dCBpbmZvIGV4aXN0cywgcmV1c2UgaXRzIGhlaWdodC5cbiAgICAgICAgICAgIC8vIE1hcmsgYXMgZXN0aW1hdGVkIGlmIHRoZSBzaXplIG9mIHRoZSBvdmVyYWxsIGNvbGxlY3Rpb24gdmlldyBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0gY2hhbmdlZC5cbiAgICAgICAgICAgIGxldCBwcmV2aW91c0xheW91dE5vZGUgPSB0aGlzLmxheW91dE5vZGVzLmdldChub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNMYXlvdXROb2RlKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSBub2RlICE9PSBwcmV2aW91c0xheW91dE5vZGUubm9kZSB8fCB3aWR0aCAhPT0gcHJldmlvdXNMYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC53aWR0aCB8fCBwcmV2aW91c0xheW91dE5vZGUubGF5b3V0SW5mby5lc3RpbWF0ZWRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBlc3RpbWF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNFc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGlzRXN0aW1hdGVkOiBpc0VzdGltYXRlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZENvbHVtbihub2RlLCB4LCB5KSB7XG4gICAgICAgIHZhciBfbm9kZV9wcm9wcywgX25vZGVfcHJvcHMxO1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldFJlbmRlcmVkQ29sdW1uV2lkdGgobm9kZSk7XG4gICAgICAgIGxldCB7IGhlaWdodDogaGVpZ2h0LCBpc0VzdGltYXRlZDogaXNFc3RpbWF0ZWQgfSA9IHRoaXMuZ2V0RXN0aW1hdGVkSGVpZ2h0KG5vZGUsIHdpZHRoLCB0aGlzLmhlYWRpbmdIZWlnaHQsIHRoaXMuZXN0aW1hdGVkSGVhZGluZ0hlaWdodCk7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkZ3RXMVQkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxheW91dEluZm8uaXNTdGlja3kgPSAhdGhpcy5kaXNhYmxlU3RpY2t5ICYmICgoKF9ub2RlX3Byb3BzID0gbm9kZS5wcm9wcykgPT09IG51bGwgfHwgX25vZGVfcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlX3Byb3BzLmlzRHJhZ0J1dHRvbkNlbGwpIHx8ICgoX25vZGVfcHJvcHMxID0gbm9kZS5wcm9wcykgPT09IG51bGwgfHwgX25vZGVfcHJvcHMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZV9wcm9wczEuaXNTZWxlY3Rpb25DZWxsKSk7XG4gICAgICAgIGxheW91dEluZm8uekluZGV4ID0gbGF5b3V0SW5mby5pc1N0aWNreSA/IDIgOiAxO1xuICAgICAgICBsYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBpc0VzdGltYXRlZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IGxheW91dEluZm8ucmVjdFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEJvZHkoeSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKDAsIHksIDAsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwicm93Z3JvdXBcIiwgXCJib2R5XCIsIHJlY3QpO1xuICAgICAgICBsZXQgc3RhcnRZID0geTtcbiAgICAgICAgbGV0IHNraXBwZWQgPSAwO1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgW2ksIG5vZGVdIG9mIFtcbiAgICAgICAgICAgIC4uLnRoaXMuY29sbGVjdGlvblxuICAgICAgICBdLmVudHJpZXMoKSl7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcm93SGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHJvd0hlaWdodCA9ICgoX3RoaXNfcm93SGVpZ2h0ID0gdGhpcy5yb3dIZWlnaHQpICE9PSBudWxsICYmIF90aGlzX3Jvd0hlaWdodCAhPT0gdm9pZCAwID8gX3RoaXNfcm93SGVpZ2h0IDogdGhpcy5lc3RpbWF0ZWRSb3dIZWlnaHQpICsgMTtcbiAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZWZvcmUgdGhlIHZhbGlkIHJlY3RhbmdsZSB1bmxlc3MgdGhleSBhcmUgYWxyZWFkeSBjYWNoZWQuXG4gICAgICAgICAgICBpZiAoeSArIHJvd0hlaWdodCA8IHRoaXMudmFsaWRSZWN0LnkgJiYgIXRoaXMuaXNWYWxpZChub2RlLCB5KSkge1xuICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXlvdXROb2RlID0gdGhpcy5idWlsZENoaWxkKG5vZGUsIDAsIHkpO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnBhcmVudEtleSA9IFwiYm9keVwiO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZS5pbmRleCA9IGk7XG4gICAgICAgICAgICB5ID0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QubWF4WTtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0LndpZHRoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAoeSA+IHRoaXMudmFsaWRSZWN0Lm1heFkpIHtcbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGUgcmVtYWluaW5nIGhlaWdodCBmb3Igcm93cyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbGF5b3V0IHJpZ2h0IG5vdy5cbiAgICAgICAgICAgICAgICB5ICs9ICh0aGlzLmNvbGxlY3Rpb24uc2l6ZSAtIChza2lwcGVkICsgY2hpbGRyZW4ubGVuZ3RoKSkgKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAvLyBBZGQgc29tZSBtYXJnaW4gYXJvdW5kIHRoZSBsb2FkZXIgdG8gZW5zdXJlIHRoYXQgc2Nyb2xsYmFycyBkb24ndCBmbGlja2VyIGluIGFuZCBvdXQuXG4gICAgICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKDQwLCBNYXRoLm1heCh5LCA0MCksICh3aWR0aCB8fCB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LndpZHRoKSAtIDgwLCBjaGlsZHJlbi5sZW5ndGggPT09IDAgPyB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LmhlaWdodCAtIDgwIDogNjApO1xuICAgICAgICAgICAgbGV0IGxvYWRlciA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwibG9hZGVyXCIsIFwibG9hZGVyXCIsIHJlY3QpO1xuICAgICAgICAgICAgbG9hZGVyLnBhcmVudEtleSA9IFwiYm9keVwiO1xuICAgICAgICAgICAgbG9hZGVyLmlzU3RpY2t5ID0gIXRoaXMuZGlzYWJsZVN0aWNreSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB0aGlzLmxheW91dEluZm9zLnNldChcImxvYWRlclwiLCBsb2FkZXIpO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogbG9hZGVyLFxuICAgICAgICAgICAgICAgIHZhbGlkUmVjdDogbG9hZGVyLnJlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeSA9IGxvYWRlci5yZWN0Lm1heFk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCByZWN0LndpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkoNDAsIE1hdGgubWF4KHksIDQwKSwgdGhpcy52aXJ0dWFsaXplci52aXNpYmxlUmVjdC53aWR0aCAtIDgwLCB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0LmhlaWdodCAtIDgwKTtcbiAgICAgICAgICAgIGxldCBlbXB0eSA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwiZW1wdHlcIiwgXCJlbXB0eVwiLCByZWN0KTtcbiAgICAgICAgICAgIGVtcHR5LnBhcmVudEtleSA9IFwiYm9keVwiO1xuICAgICAgICAgICAgZW1wdHkuaXNTdGlja3kgPSAhdGhpcy5kaXNhYmxlU3RpY2t5O1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRJbmZvcy5zZXQoXCJlbXB0eVwiLCBlbXB0eSk7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBlbXB0eSxcbiAgICAgICAgICAgICAgICB2YWxpZFJlY3Q6IGVtcHR5LnJlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeSA9IGVtcHR5LnJlY3QubWF4WTtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHJlY3Qud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB5IC0gc3RhcnRZO1xuICAgICAgICB0aGlzLmxheW91dEluZm9zLnNldChcImJvZHlcIiwgbGF5b3V0SW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiBsYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0aW9uKHRoaXMudmFsaWRSZWN0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZE5vZGUobm9kZSwgeCwgeSkge1xuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJoZWFkZXJyb3dcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEhlYWRlclJvdyhub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRSb3cobm9kZSwgeCwgeSk7XG4gICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICAgICAgICBjYXNlIFwicGxhY2Vob2xkZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZENvbHVtbihub2RlLCB4LCB5KTtcbiAgICAgICAgICAgIGNhc2UgXCJjZWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDZWxsKG5vZGUsIHgsIHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZSBcIiArIG5vZGUudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRSb3cobm9kZSwgeCwgeSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJGd0VzFUJFJlY3QpKHgsIHksIDAsIDApO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IG5ldyAoMCwgJGd0VzFUJExheW91dEluZm8pKFwicm93XCIsIG5vZGUua2V5LCByZWN0KTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBbaSwgY2hpbGRdIG9mIFtcbiAgICAgICAgICAgIC4uLigwLCAkZ3RXMVQkZ2V0Q2hpbGROb2Rlcykobm9kZSwgdGhpcy5jb2xsZWN0aW9uKVxuICAgICAgICBdLmVudHJpZXMoKSlpZiAoY2hpbGQudHlwZSA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIGlmICh4ID4gdGhpcy52YWxpZFJlY3QubWF4WCkge1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBleGlzdGluZyBjYWNoZWQgbGF5b3V0SW5mbyB0byBlbnN1cmUgdGhhdCBpdCBpcyBvdXQgb2Ygdmlldy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gZHVlIHRvIGNvbHVtbiByZXNpemluZy5cbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3QueCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gbGF5b3V0Tm9kZS5sYXlvdXRJbmZvLnJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZSA9IHRoaXMuYnVpbGRDaGlsZChjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgeCA9IGxheW91dE5vZGUubGF5b3V0SW5mby5yZWN0Lm1heFg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBsYXlvdXROb2RlLmxheW91dEluZm8ucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGUuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDaGlsZEhlaWdodHMoY2hpbGRyZW4sIGhlaWdodCk7XG4gICAgICAgIHJlY3Qud2lkdGggPSB0aGlzLmxheW91dEluZm9zLmdldChcImhlYWRlclwiKS5yZWN0LndpZHRoO1xuICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodCArIDE7IC8vICsxIGZvciBib3R0b20gYm9yZGVyXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsaWRSZWN0OiByZWN0LmludGVyc2VjdGlvbih0aGlzLnZhbGlkUmVjdClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRDZWxsKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgdmFyIF9ub2RlX3Byb3BzLCBfbm9kZV9wcm9wczE7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0UmVuZGVyZWRDb2x1bW5XaWR0aChub2RlKTtcbiAgICAgICAgbGV0IHsgaGVpZ2h0OiBoZWlnaHQsIGlzRXN0aW1hdGVkOiBpc0VzdGltYXRlZCB9ID0gdGhpcy5nZXRFc3RpbWF0ZWRIZWlnaHQobm9kZSwgd2lkdGgsIHRoaXMucm93SGVpZ2h0LCB0aGlzLmVzdGltYXRlZFJvd0hlaWdodCk7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gbmV3ICgwLCAkZ3RXMVQkTGF5b3V0SW5mbykobm9kZS50eXBlLCBub2RlLmtleSwgcmVjdCk7XG4gICAgICAgIGxheW91dEluZm8uaXNTdGlja3kgPSAhdGhpcy5kaXNhYmxlU3RpY2t5ICYmICgoKF9ub2RlX3Byb3BzID0gbm9kZS5wcm9wcykgPT09IG51bGwgfHwgX25vZGVfcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlX3Byb3BzLmlzRHJhZ0J1dHRvbkNlbGwpIHx8ICgoX25vZGVfcHJvcHMxID0gbm9kZS5wcm9wcykgPT09IG51bGwgfHwgX25vZGVfcHJvcHMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZV9wcm9wczEuaXNTZWxlY3Rpb25DZWxsKSk7XG4gICAgICAgIGxheW91dEluZm8uekluZGV4ID0gbGF5b3V0SW5mby5pc1N0aWNreSA/IDIgOiAxO1xuICAgICAgICBsYXlvdXRJbmZvLmVzdGltYXRlZFNpemUgPSBpc0VzdGltYXRlZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICB2YWxpZFJlY3Q6IHJlY3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpIHtcbiAgICAgICAgLy8gSWYgbGF5b3V0IGhhc24ndCB5ZXQgYmVlbiBkb25lIGZvciB0aGUgcmVxdWVzdGVkIHJlY3QsIHVuaW9uIHRoZVxuICAgICAgICAvLyBuZXcgcmVjdCB3aXRoIHRoZSBleGlzdGluZyB2YWxpZCByZWN0LCBhbmQgcmVjb21wdXRlLlxuICAgICAgICBpZiAoIXRoaXMudmFsaWRSZWN0LmNvbnRhaW5zUmVjdChyZWN0KSAmJiB0aGlzLmxhc3RDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWxpZFJlY3QgPSB0aGlzLnZhbGlkUmVjdDtcbiAgICAgICAgICAgIHRoaXMudmFsaWRSZWN0ID0gdGhpcy52YWxpZFJlY3QudW5pb24ocmVjdCk7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHRoaXMuYnVpbGRDb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1aWxkUGVyc2lzdGVkSW5kaWNlcygpO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMucm9vdE5vZGVzKXtcbiAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIG5vZGUsIHJlY3QpIHtcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHN3aXRjaChub2RlLmxheW91dEluZm8udHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiaGVhZGVyXCI6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbil7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNoaWxkLmxheW91dEluZm8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpc2libGVMYXlvdXRJbmZvcyhyZXMsIGNoaWxkLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm93Z3JvdXBcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdFZpc2libGVSb3cgPSB0aGlzLmJpbmFyeVNlYXJjaChub2RlLmNoaWxkcmVuLCByZWN0LnRvcExlZnQsIFwieVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RWaXNpYmxlUm93ID0gdGhpcy5iaW5hcnlTZWFyY2gobm9kZS5jaGlsZHJlbiwgcmVjdC5ib3R0b21SaWdodCwgXCJ5XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGVyc2lzdGVkIHJvd3MgYmVmb3JlIHRoZSB2aXNpYmxlIHJvd3MuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJzaXN0ZWRSb3dJbmRpY2VzID0gdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLmdldChub2RlLmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlcnNpc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBlcnNpc3RlZFJvd0luZGljZXMgJiYgcGVyc2lzdEluZGV4IDwgcGVyc2lzdGVkUm93SW5kaWNlcy5sZW5ndGggJiYgcGVyc2lzdGVkUm93SW5kaWNlc1twZXJzaXN0SW5kZXhdIDwgZmlyc3RWaXNpYmxlUm93KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSBwZXJzaXN0ZWRSb3dJbmRpY2VzW3BlcnNpc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWaXNpYmxlTGF5b3V0SW5mb3MocmVzLCBub2RlLmNoaWxkcmVuW2lkeF0sIHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gZmlyc3RWaXNpYmxlUm93OyBpIDw9IGxhc3RWaXNpYmxlUm93OyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwZXJzaXN0ZWQgcm93cyB0aGF0IG92ZXJsYXAgd2l0aCB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocGVyc2lzdGVkUm93SW5kaWNlcyAmJiBwZXJzaXN0SW5kZXggPCBwZXJzaXN0ZWRSb3dJbmRpY2VzLmxlbmd0aCAmJiBwZXJzaXN0ZWRSb3dJbmRpY2VzW3BlcnNpc3RJbmRleF0gPCBpKXBlcnNpc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobm9kZS5jaGlsZHJlbltpXS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlzaWJsZUxheW91dEluZm9zKHJlcywgbm9kZS5jaGlsZHJlbltpXSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBlcnNpc3RlZCByb3dzIGFmdGVyIHRoZSB2aXNpYmxlIHJvd3MuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBlcnNpc3RlZFJvd0luZGljZXMgJiYgcGVyc2lzdEluZGV4IDwgcGVyc2lzdGVkUm93SW5kaWNlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHBlcnNpc3RlZFJvd0luZGljZXNbcGVyc2lzdEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImhlYWRlcnJvd1wiOlxuICAgICAgICAgICAgY2FzZSBcInJvd1wiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0VmlzaWJsZUNlbGwgPSB0aGlzLmJpbmFyeVNlYXJjaChub2RlLmNoaWxkcmVuLCByZWN0LnRvcExlZnQsIFwieFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RWaXNpYmxlQ2VsbCA9IHRoaXMuYmluYXJ5U2VhcmNoKG5vZGUuY2hpbGRyZW4sIHJlY3QudG9wUmlnaHQsIFwieFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0aWNreUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHBlcnNpc3RlZC9zdGlja3kgY2VsbHMgYmVmb3JlIHRoZSB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyc2lzdGVkQ2VsbEluZGljZXMgPSB0aGlzLnBlcnNpc3RlZEluZGljZXMuZ2V0KG5vZGUubGF5b3V0SW5mby5rZXkpIHx8IHRoaXMuc3RpY2t5Q29sdW1uSW5kaWNlcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoc3RpY2t5SW5kZXggPCBwZXJzaXN0ZWRDZWxsSW5kaWNlcy5sZW5ndGggJiYgcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXhdIDwgZmlyc3RWaXNpYmxlQ2VsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSByZXMucHVzaChub2RlLmNoaWxkcmVuW2lkeF0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGlja3lJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGZpcnN0VmlzaWJsZUNlbGw7IGkgPD0gbGFzdFZpc2libGVDZWxsOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzdGlja3kgY2VsbHMgdGhhdCBvdmVybGFwIHdpdGggdmlzaWJsZSBjZWxscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHN0aWNreUluZGV4IDwgcGVyc2lzdGVkQ2VsbEluZGljZXMubGVuZ3RoICYmIHBlcnNpc3RlZENlbGxJbmRpY2VzW3N0aWNreUluZGV4XSA8IGkpc3RpY2t5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baV0ubGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgc3RpY2t5IGNlbGxzIGFmdGVyIHRoZSB2aXNpYmxlIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZShzdGlja3lJbmRleCA8IHBlcnNpc3RlZENlbGxJbmRpY2VzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gcGVyc2lzdGVkQ2VsbEluZGljZXNbc3RpY2t5SW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHJlcy5wdXNoKG5vZGUuY2hpbGRyZW5baWR4XS5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIFwiICsgbm9kZS5sYXlvdXRJbmZvLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmFyeVNlYXJjaChpdGVtcywgcG9pbnQsIGF4aXMpIHtcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUobG93IDw9IGhpZ2gpe1xuICAgICAgICAgICAgbGV0IG1pZCA9IGxvdyArIGhpZ2ggPj4gMTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gaXRlbXNbbWlkXTtcbiAgICAgICAgICAgIGlmIChheGlzID09PSBcInhcIiAmJiBpdGVtLmxheW91dEluZm8ucmVjdC5tYXhYIDwgcG9pbnQueCB8fCBheGlzID09PSBcInlcIiAmJiBpdGVtLmxheW91dEluZm8ucmVjdC5tYXhZIDwgcG9pbnQueSkgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMgPT09IFwieFwiICYmIGl0ZW0ubGF5b3V0SW5mby5yZWN0LnggPiBwb2ludC54IHx8IGF4aXMgPT09IFwieVwiICYmIGl0ZW0ubGF5b3V0SW5mby5yZWN0LnkgPiBwb2ludC55KSBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oaXRlbXMubGVuZ3RoIC0gMSwgbG93KSk7XG4gICAgfVxuICAgIGJ1aWxkUGVyc2lzdGVkSW5kaWNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbGl6ZXIucGVyc2lzdGVkS2V5cyA9PT0gdGhpcy5sYXN0UGVyc2lzdGVkS2V5cykgcmV0dXJuO1xuICAgICAgICB0aGlzLmxhc3RQZXJzaXN0ZWRLZXlzID0gdGhpcy52aXJ0dWFsaXplci5wZXJzaXN0ZWRLZXlzO1xuICAgICAgICB0aGlzLnBlcnNpc3RlZEluZGljZXMuY2xlYXIoKTtcbiAgICAgICAgLy8gQnVpbGQgYSBtYXAgb2YgcGFyZW50S2V5ID0+IGluZGljZXMgb2YgY2hpbGRyZW4gdG8gcGVyc2lzdC5cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMudmlydHVhbGl6ZXIucGVyc2lzdGVkS2V5cyl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0SW5mb3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBXYWxrIHVwIGFuY2VzdG9ycyBzbyBwYXJlbnRzIGFyZSBhbHNvIHBlcnNpc3RlZCBpZiBjaGlsZHJlbiBhcmUuXG4gICAgICAgICAgICB3aGlsZShsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucGFyZW50S2V5KXtcbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGlvbk5vZGUgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSB0aGlzLnBlcnNpc3RlZEluZGljZXMuZ2V0KGxheW91dEluZm8ucGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpY2t5Q29sdW1uSW5kaWNlcyBhcmUgYWx3YXlzIHBlcnNpc3RlZCBhbG9uZyB3aXRoIGFueSBjZWxscyBmcm9tIHBlcnNpc3RlZEtleXMuXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMgPSBjb2xsZWN0aW9uTm9kZS50eXBlID09PSBcImNlbGxcIiB8fCBjb2xsZWN0aW9uTm9kZS50eXBlID09PSBcImNvbHVtblwiID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5zdGlja3lDb2x1bW5JbmRpY2VzXG4gICAgICAgICAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZWRJbmRpY2VzLnNldChsYXlvdXRJbmZvLnBhcmVudEtleSwgaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubGF5b3V0Tm9kZXMuZ2V0KGxheW91dEluZm8ua2V5KS5pbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoIWluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSBpbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSB0aGlzLmxheW91dEluZm9zLmdldChsYXlvdXRJbmZvLnBhcmVudEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kaWNlcyBvZiB0aGlzLnBlcnNpc3RlZEluZGljZXMudmFsdWVzKCkpaW5kaWNlcy5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgIH1cbiAgICBnZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIGxldCByZXMgPSBzdXBlci5nZXRJbml0aWFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgICAgICAgcmVzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIGxldCByZXMgPSBzdXBlci5nZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gICAgICAgIHJlcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgQ2hyb21lIHZlcnNpb24gaXMgMTA1IG9yIGdyZWF0ZXJcbiAgICBjaGVja0Nocm9tZTEwNSgpIHtcbiAgICAgICAgdmFyIF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGE7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHdpbmRvdy5uYXZpZ2F0b3IgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaXNDaHJvbWUxMDU7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yW1widXNlckFnZW50RGF0YVwiXSkgaXNDaHJvbWUxMDUgPSAoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbXCJ1c2VyQWdlbnREYXRhXCJdKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLmJyYW5kcy5zb21lKChiKT0+Yi5icmFuZCA9PT0gXCJDaHJvbWl1bVwiICYmIE51bWJlcihiLnZlcnNpb24pID09PSAxMDUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWdleCA9IC9DaHJvbWVcXC8oXFxkKykvO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSByZWdleC5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGlzQ2hyb21lMTA1ID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+PSAyICYmIE51bWJlcihtYXRjaGVzWzFdKSA9PT0gMTA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Nocm9tZTEwNTtcbiAgICB9XG4gICAgZ2V0RHJvcFRhcmdldEZyb21Qb2ludCh4LCB5LCBpc1ZhbGlkRHJvcFRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXNfdmlydHVhbGl6ZXJfbGF5b3V0X2dldFZpc2libGVMYXlvdXRJbmZvc19maW5kO1xuICAgICAgICB4ICs9IHRoaXMudmlydHVhbGl6ZXIudmlzaWJsZVJlY3QueDtcbiAgICAgICAgeSArPSB0aGlzLnZpcnR1YWxpemVyLnZpc2libGVSZWN0Lnk7XG4gICAgICAgIC8vIE9mZnNldCBmb3IgaGVpZ2h0IG9mIGhlYWRlciByb3dcbiAgICAgICAgeSAtPSAoX3RoaXNfdmlydHVhbGl6ZXJfbGF5b3V0X2dldFZpc2libGVMYXlvdXRJbmZvc19maW5kID0gdGhpcy52aXJ0dWFsaXplci5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKG5ldyAoMCwgJGd0VzFUJFJlY3QpKHgsIHksIDEsIDEpKS5maW5kKChpbmZvKT0+aW5mby50eXBlID09PSBcImhlYWRlcnJvd1wiKSkgPT09IG51bGwgfHwgX3RoaXNfdmlydHVhbGl6ZXJfbGF5b3V0X2dldFZpc2libGVMYXlvdXRJbmZvc19maW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc192aXJ0dWFsaXplcl9sYXlvdXRfZ2V0VmlzaWJsZUxheW91dEluZm9zX2ZpbmQucmVjdC5oZWlnaHQ7XG4gICAgICAgIC8vIEN1c3RvbSB2YXJpYXRpb24gb2YgdGhpcy52aXJ0dWFsaXplci5rZXlBdFBvaW50IHRoYXQgaWdub3JlcyBib2R5XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCBwb2ludCA9IG5ldyAoMCwgJGd0VzFUJFBvaW50KSh4LCB5KTtcbiAgICAgICAgbGV0IHJlY3RBdFBvaW50ID0gbmV3ICgwLCAkZ3RXMVQkUmVjdCkocG9pbnQueCwgcG9pbnQueSwgMSwgMSk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMudmlydHVhbGl6ZXIubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0QXRQb2ludCkuZmlsdGVyKChpbmZvKT0+aW5mby50eXBlID09PSBcInJvd1wiKTtcbiAgICAgICAgLy8gTGF5b3V0IG1heSByZXR1cm4gbXVsdGlwbGUgbGF5b3V0IGluZm9zIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIHBlcnNpc3RlZCBrZXlzLCBzbyBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBhY3R1YWxseSBpbnRlcnNlY3RzLlxuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKWlmIChsYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0cyhyZWN0QXRQb2ludCkpIGtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLnNpemUgPT09IDApIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJvb3RcIlxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBsZXQgcmVjdCA9IGxheW91dEluZm8ucmVjdDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAga2V5OiBsYXlvdXRJbmZvLmtleSxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJvblwiXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzbid0IGFjY2VwdGVkLCB0cnkgdGhlIHRhcmdldCBiZWZvcmUgb3IgYWZ0ZXIgZGVwZW5kaW5nIG9uIHRoZSB5IHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGRyb3BwaW5nIG9uIHRoZSBpdGVtIGlzIGFjY2VwdGVkLCBzdGlsbCB0cnkgdGhlIGJlZm9yZS9hZnRlciBwb3NpdGlvbnMgaWYgd2l0aGluIDEwcHhcbiAgICAgICAgLy8gb2YgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIGl0ZW0uXG4gICAgICAgIGlmICghaXNWYWxpZERyb3BUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiBcImJlZm9yZVwiXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYmVmb3JlXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRHJvcFRhcmdldCh7XG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJhZnRlclwiXG4gICAgICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYWZ0ZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmICh5IDw9IHJlY3QueSArIDEwICYmIGlzVmFsaWREcm9wVGFyZ2V0KHtcbiAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogXCJiZWZvcmVcIlxuICAgICAgICB9KSkgdGFyZ2V0LmRyb3BQb3NpdGlvbiA9IFwiYmVmb3JlXCI7XG4gICAgICAgIGVsc2UgaWYgKHkgPj0gcmVjdC5tYXhZIC0gMTAgJiYgaXNWYWxpZERyb3BUYXJnZXQoe1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiBcImFmdGVyXCJcbiAgICAgICAgfSkpIHRhcmdldC5kcm9wUG9zaXRpb24gPSBcImFmdGVyXCI7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMud2FzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RQZXJzaXN0ZWRLZXlzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWRJbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmluaXRpYWxDb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0aWNreUNvbHVtbkluZGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU3RpY2t5ID0gdGhpcy5jaGVja0Nocm9tZTEwNSgpO1xuICAgICAgICB0aGlzLmNvbHVtbkxheW91dCA9IG9wdGlvbnMuY29sdW1uTGF5b3V0O1xuICAgICAgICBsZXQgW2NvbnRyb2xsZWRDb2x1bW5zLCB1bmNvbnRyb2xsZWRDb2x1bW5zXSA9IHRoaXMuY29sdW1uTGF5b3V0LnNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKHRoaXMuY29sbGVjdGlvbi5jb2x1bW5zKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVkQ29sdW1ucyA9IGNvbnRyb2xsZWRDb2x1bW5zO1xuICAgICAgICB0aGlzLnVuY29udHJvbGxlZENvbHVtbnMgPSB1bmNvbnRyb2xsZWRDb2x1bW5zO1xuICAgICAgICB0aGlzLnVuY29udHJvbGxlZFdpZHRocyA9IHRoaXMuY29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucyk7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ2MWVmNjBmYzliMTA0MWY0JGV4cG9ydCRjYWNiYjM5MjQxNTVkNjhlIGFzIExpc3RMYXlvdXQsICRhMTUyMTEyZTkwMjcwOWJmJGV4cG9ydCQ2MjQ0NGMzYzcyNGIxYjIwIGFzIFRhYmxlTGF5b3V0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-stately+layout@3.13.7_react@18.2.0/node_modules/@react-stately/layout/dist/import.mjs\n");

/***/ })

};
;