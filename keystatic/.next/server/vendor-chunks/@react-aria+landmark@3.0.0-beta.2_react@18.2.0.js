"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria+landmark@3.0.0-beta.2_react@18.2.0";
exports.ids = ["vendor-chunks/@react-aria+landmark@3.0.0-beta.2_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/landmark/dist/import.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-aria+landmark@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/landmark/dist/import.mjs ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLandmarkController: () => (/* binding */ $a86207c5d7f7e1fb$export$f50151dbd51cd1d9),\n/* harmony export */   useLandmark: () => (/* binding */ $a86207c5d7f7e1fb$export$4cc632584fd87fae)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.2_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/.pnpm/@react-aria+utils@3.23.2_react@18.2.0/node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n// Increment this version number whenever the\n// LandmarkManagerApi or Landmark interfaces change.\nconst $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;\n// Symbol under which the singleton landmark manager instance is attached to the document.\nconst $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for(\"react-aria-landmark-manager\");\nfunction $a86207c5d7f7e1fb$var$subscribe(fn) {\n    document.addEventListener(\"react-aria-landmark-manager-change\", fn);\n    return ()=>document.removeEventListener(\"react-aria-landmark-manager-change\", fn);\n}\nfunction $a86207c5d7f7e1fb$var$getLandmarkManager() {\n    if (typeof document === \"undefined\") return null;\n    // Reuse an existing instance if it has the same or greater version.\n    let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n    if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION) return instance;\n    // Otherwise, create a new instance and dispatch an event so anything using the existing\n    // instance updates and re-registers their landmarks with the new one.\n    document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();\n    document.dispatchEvent(new CustomEvent(\"react-aria-landmark-manager-change\"));\n    return document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n}\n// Subscribes a React component to the current landmark manager instance.\nfunction $a86207c5d7f7e1fb$var$useLandmarkManager() {\n    return (0, use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);\n}\nclass $a86207c5d7f7e1fb$var$LandmarkManager {\n    setupIfNeeded() {\n        if (this.isListening) return;\n        document.addEventListener(\"keydown\", this.f6Handler, {\n            capture: true\n        });\n        document.addEventListener(\"focusin\", this.focusinHandler, {\n            capture: true\n        });\n        document.addEventListener(\"focusout\", this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = true;\n    }\n    teardownIfNeeded() {\n        if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) return;\n        document.removeEventListener(\"keydown\", this.f6Handler, {\n            capture: true\n        });\n        document.removeEventListener(\"focusin\", this.focusinHandler, {\n            capture: true\n        });\n        document.removeEventListener(\"focusout\", this.focusoutHandler, {\n            capture: true\n        });\n        this.isListening = false;\n    }\n    focusLandmark(landmark, direction) {\n        var _this_landmarks_find, _this_landmarks_find_focus;\n        (_this_landmarks_find = this.landmarks.find((l)=>l.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);\n    }\n    /**\n   * Return set of landmarks with a specific role.\n   */ getLandmarksByRole(role) {\n        return new Set(this.landmarks.filter((l)=>l.role === role));\n    }\n    /**\n   * Return first landmark with a specific role.\n   */ getLandmarkByRole(role) {\n        return this.landmarks.find((l)=>l.role === role);\n    }\n    addLandmark(newLandmark) {\n        this.setupIfNeeded();\n        if (this.landmarks.find((landmark)=>landmark.ref === newLandmark.ref) || !newLandmark.ref.current) return;\n        if (this.landmarks.filter((landmark)=>landmark.role === \"main\").length > 1) console.error('Page can contain no more than one landmark with the role \"main\".');\n        if (this.landmarks.length === 0) {\n            this.landmarks = [\n                newLandmark\n            ];\n            this.checkLabels(newLandmark.role);\n            return;\n        }\n        // Binary search to insert new landmark based on position in document relative to existing landmarks.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        let start = 0;\n        let end = this.landmarks.length - 1;\n        while(start <= end){\n            let mid = Math.floor((start + end) / 2);\n            let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);\n            let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);\n            if (isNewAfterExisting) start = mid + 1;\n            else end = mid - 1;\n        }\n        this.landmarks.splice(start, 0, newLandmark);\n        this.checkLabels(newLandmark.role);\n    }\n    updateLandmark(landmark) {\n        let index = this.landmarks.findIndex((l)=>l.ref === landmark.ref);\n        if (index >= 0) {\n            this.landmarks[index] = {\n                ...this.landmarks[index],\n                ...landmark\n            };\n            this.checkLabels(this.landmarks[index].role);\n        }\n    }\n    removeLandmark(ref) {\n        this.landmarks = this.landmarks.filter((landmark)=>landmark.ref !== ref);\n        this.teardownIfNeeded();\n    }\n    /**\n   * Warn if there are 2+ landmarks with the same role but no label.\n   * Labels for landmarks with the same role must also be unique.\n   *\n   * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.\n   */ checkLabels(role) {\n        let landmarksWithRole = this.getLandmarksByRole(role);\n        if (landmarksWithRole.size > 1) {\n            let duplicatesWithoutLabel = [\n                ...landmarksWithRole\n            ].filter((landmark)=>!landmark.label);\n            if (duplicatesWithoutLabel.length > 0) console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark)=>landmark.ref.current));\n            else {\n                let labels = [\n                    ...landmarksWithRole\n                ].map((landmark)=>landmark.label);\n                let duplicateLabels = labels.filter((item, index)=>labels.indexOf(item) !== index);\n                duplicateLabels.forEach((label)=>{\n                    console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [\n                        ...landmarksWithRole\n                    ].filter((landmark)=>landmark.label === label).map((landmark)=>landmark.ref.current));\n                });\n            }\n        }\n    }\n    /**\n   * Get the landmark that is the closest parent in the DOM.\n   * Returns undefined if no parent is a landmark.\n   */ closestLandmark(element) {\n        let landmarkMap = new Map(this.landmarks.map((l)=>[\n                l.ref.current,\n                l\n            ]));\n        let currentElement = element;\n        while(currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement)currentElement = currentElement.parentElement;\n        return landmarkMap.get(currentElement);\n    }\n    /**\n   * Gets the next landmark, in DOM focus order, or previous if backwards is specified.\n   * If last landmark, next should be the first landmark.\n   * If not inside a landmark, will return first landmark.\n   * Returns undefined if there are no landmarks.\n   */ getNextLandmark(element, { backward: backward  }) {\n        var _this_landmarks_nextLandmarkIndex_ref_current;\n        let currentLandmark = this.closestLandmark(element);\n        let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;\n        if (currentLandmark) nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);\n        let wrapIfNeeded = ()=>{\n            // When we reach the end of the landmark sequence, fire a custom event that can be listened for by applications.\n            // If this event is canceled, we return immediately. This can be used to implement landmark navigation across iframes.\n            if (nextLandmarkIndex < 0) {\n                if (!element.dispatchEvent(new CustomEvent(\"react-aria-landmark-navigation\", {\n                    detail: {\n                        direction: \"backward\"\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = this.landmarks.length - 1;\n            } else if (nextLandmarkIndex >= this.landmarks.length) {\n                if (!element.dispatchEvent(new CustomEvent(\"react-aria-landmark-navigation\", {\n                    detail: {\n                        direction: \"forward\"\n                    },\n                    bubbles: true,\n                    cancelable: true\n                }))) return true;\n                nextLandmarkIndex = 0;\n            }\n            if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) return true;\n            return false;\n        };\n        if (wrapIfNeeded()) return undefined;\n        // Skip over hidden landmarks.\n        let i = nextLandmarkIndex;\n        while((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest(\"[aria-hidden=true]\")){\n            nextLandmarkIndex += backward ? -1 : 1;\n            if (wrapIfNeeded()) return undefined;\n            if (nextLandmarkIndex === i) break;\n        }\n        return this.landmarks[nextLandmarkIndex];\n    }\n    /**\n   * Look at next landmark. If an element was previously focused inside, restore focus there.\n   * If not, focus the landmark itself.\n   * If no landmarks at all, or none with focusable elements, don't move focus.\n   */ f6Handler(e) {\n        if (e.key === \"F6\") {\n            // If alt key pressed, focus main landmark, otherwise navigate forward or backward based on shift key.\n            let handled = e.altKey ? this.focusMain() : this.navigate(e.target, e.shiftKey);\n            if (handled) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    focusMain() {\n        let main = this.getLandmarkByRole(\"main\");\n        if (main && main.ref.current && document.contains(main.ref.current)) {\n            this.focusLandmark(main.ref.current, \"forward\");\n            return true;\n        }\n        return false;\n    }\n    navigate(from, backward) {\n        let nextLandmark = this.getNextLandmark(from, {\n            backward: backward\n        });\n        if (!nextLandmark) return false;\n        // If something was previously focused in the next landmark, then return focus to it\n        if (nextLandmark.lastFocused) {\n            let lastFocused = nextLandmark.lastFocused;\n            if (document.body.contains(lastFocused)) {\n                lastFocused.focus();\n                return true;\n            }\n        }\n        // Otherwise, focus the landmark itself\n        if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {\n            this.focusLandmark(nextLandmark.ref.current, backward ? \"backward\" : \"forward\");\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Sets lastFocused for a landmark, if focus is moved within that landmark.\n   * Lets the last focused landmark know it was blurred if something else is focused.\n   */ focusinHandler(e) {\n        let currentLandmark = this.closestLandmark(e.target);\n        if (currentLandmark && currentLandmark.ref.current !== e.target) this.updateLandmark({\n            ref: currentLandmark.ref,\n            lastFocused: e.target\n        });\n        let previousFocusedElement = e.relatedTarget;\n        if (previousFocusedElement) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    /**\n   * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.\n   */ focusoutHandler(e) {\n        let previousFocusedElement = e.target;\n        let nextFocusedElement = e.relatedTarget;\n        // the === document seems to be a jest thing for focus to go there on generic blur event such as landmark.blur();\n        // browsers appear to send focus instead to document.body and the relatedTarget is null when that happens\n        if (!nextFocusedElement || nextFocusedElement === document) {\n            let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n            if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n        }\n    }\n    createLandmarkController() {\n        let instance = this;\n        instance.refCount++;\n        instance.setupIfNeeded();\n        return {\n            navigate (direction, opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, direction === \"backward\");\n            },\n            focusNext (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, false);\n            },\n            focusPrevious (opts) {\n                let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n                return instance.navigate(element, true);\n            },\n            focusMain () {\n                return instance.focusMain();\n            },\n            dispose () {\n                if (instance) {\n                    instance.refCount--;\n                    instance.teardownIfNeeded();\n                    instance = null;\n                }\n            }\n        };\n    }\n    registerLandmark(landmark) {\n        if (this.landmarks.find((l)=>l.ref === landmark.ref)) this.updateLandmark(landmark);\n        else this.addLandmark(landmark);\n        return ()=>this.removeLandmark(landmark.ref);\n    }\n    constructor(){\n        this.landmarks = [];\n        this.isListening = false;\n        this.refCount = 0;\n        this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;\n        this.f6Handler = this.f6Handler.bind(this);\n        this.focusinHandler = this.focusinHandler.bind(this);\n        this.focusoutHandler = this.focusoutHandler.bind(this);\n    }\n}\nfunction $a86207c5d7f7e1fb$export$f50151dbd51cd1d9() {\n    // Get the current landmark manager and create a controller using it.\n    let instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n    let controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    let unsubscribe = $a86207c5d7f7e1fb$var$subscribe(()=>{\n        // If the landmark manager changes, dispose the old\n        // controller and create a new one.\n        controller === null || controller === void 0 ? void 0 : controller.dispose();\n        instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n        controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n    });\n    // Return a wrapper that proxies requests to the current controller instance.\n    return {\n        navigate (direction, opts) {\n            return controller.navigate(direction, opts);\n        },\n        focusNext (opts) {\n            return controller.focusNext(opts);\n        },\n        focusPrevious (opts) {\n            return controller.focusPrevious(opts);\n        },\n        focusMain () {\n            return controller.focusMain();\n        },\n        dispose () {\n            controller === null || controller === void 0 ? void 0 : controller.dispose();\n            unsubscribe();\n            controller = undefined;\n            instance = null;\n        }\n    };\n}\nfunction $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {\n    const { role: role , \"aria-label\": ariaLabel , \"aria-labelledby\": ariaLabelledby , focus: focus  } = props;\n    let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();\n    let label = ariaLabel || ariaLabelledby;\n    let [isLandmarkFocused, setIsLandmarkFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let defaultFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(true);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    let blur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsLandmarkFocused(false);\n    }, [\n        setIsLandmarkFocused\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect)(()=>{\n        if (manager) return manager.registerLandmark({\n            ref: ref,\n            label: label,\n            role: role,\n            focus: focus || defaultFocus,\n            blur: blur\n        });\n    }, [\n        manager,\n        label,\n        ref,\n        role,\n        focus,\n        defaultFocus,\n        blur\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        if (isLandmarkFocused) (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();\n    }, [\n        isLandmarkFocused,\n        ref\n    ]);\n    return {\n        landmarkProps: {\n            role: role,\n            tabIndex: isLandmarkFocused ? -1 : undefined,\n            \"aria-label\": ariaLabel,\n            \"aria-labelledby\": ariaLabelledby\n        }\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWFyaWErbGFuZG1hcmtAMy4wLjAtYmV0YS4yX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvbGFuZG1hcmsvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9IO0FBQ3hDO0FBQzhCOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1RkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxLQUFLO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixLQUFLLGNBQWMsTUFBTTtBQUM1RztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyRkFBMkY7QUFDdkc7QUFDQTtBQUNBLHdEQUF3RCwyQ0FBZTtBQUN2RSwyQkFBMkIsOENBQWtCO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsOENBQWtCO0FBQ3JDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLDhEQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLeUk7QUFDekkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LWFyaWErbGFuZG1hcmtAMy4wLjAtYmV0YS4yX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvbGFuZG1hcmsvZGlzdC9pbXBvcnQubWpzP2Q5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkVHZzYlUkdXNlU3RhdGUsIHVzZUNhbGxiYWNrIGFzICRUdnNiVSR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICRUdnNiVSR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJFR2c2JVJHVzZUxheW91dEVmZmVjdH0gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5pbXBvcnQge3VzZVN5bmNFeHRlcm5hbFN0b3JlIGFzICRUdnNiVSR1c2VTeW5jRXh0ZXJuYWxTdG9yZX0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG4vLyBJbmNyZW1lbnQgdGhpcyB2ZXJzaW9uIG51bWJlciB3aGVuZXZlciB0aGVcbi8vIExhbmRtYXJrTWFuYWdlckFwaSBvciBMYW5kbWFyayBpbnRlcmZhY2VzIGNoYW5nZS5cbmNvbnN0ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRMQU5ETUFSS19BUElfVkVSU0lPTiA9IDE7XG4vLyBTeW1ib2wgdW5kZXIgd2hpY2ggdGhlIHNpbmdsZXRvbiBsYW5kbWFyayBtYW5hZ2VyIGluc3RhbmNlIGlzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudC5cbmNvbnN0ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRsYW5kbWFya1N5bWJvbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC1hcmlhLWxhbmRtYXJrLW1hbmFnZXJcIik7XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkc3Vic2NyaWJlKGZuKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWN0LWFyaWEtbGFuZG1hcmstbWFuYWdlci1jaGFuZ2VcIiwgZm4pO1xuICAgIHJldHVybiAoKT0+ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWN0LWFyaWEtbGFuZG1hcmstbWFuYWdlci1jaGFuZ2VcIiwgZm4pO1xufVxuZnVuY3Rpb24gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlcigpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgICAvLyBSZXVzZSBhbiBleGlzdGluZyBpbnN0YW5jZSBpZiBpdCBoYXMgdGhlIHNhbWUgb3IgZ3JlYXRlciB2ZXJzaW9uLlxuICAgIGxldCBpbnN0YW5jZSA9IGRvY3VtZW50WyRhODYyMDdjNWQ3ZjdlMWZiJHZhciRsYW5kbWFya1N5bWJvbF07XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnZlcnNpb24gPj0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExBTkRNQVJLX0FQSV9WRVJTSU9OKSByZXR1cm4gaW5zdGFuY2U7XG4gICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgYW5kIGRpc3BhdGNoIGFuIGV2ZW50IHNvIGFueXRoaW5nIHVzaW5nIHRoZSBleGlzdGluZ1xuICAgIC8vIGluc3RhbmNlIHVwZGF0ZXMgYW5kIHJlLXJlZ2lzdGVycyB0aGVpciBsYW5kbWFya3Mgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICBkb2N1bWVudFskYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkbGFuZG1hcmtTeW1ib2xdID0gbmV3ICRhODYyMDdjNWQ3ZjdlMWZiJHZhciRMYW5kbWFya01hbmFnZXIoKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInJlYWN0LWFyaWEtbGFuZG1hcmstbWFuYWdlci1jaGFuZ2VcIikpO1xuICAgIHJldHVybiBkb2N1bWVudFskYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkbGFuZG1hcmtTeW1ib2xdO1xufVxuLy8gU3Vic2NyaWJlcyBhIFJlYWN0IGNvbXBvbmVudCB0byB0aGUgY3VycmVudCBsYW5kbWFyayBtYW5hZ2VyIGluc3RhbmNlLlxuZnVuY3Rpb24gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHVzZUxhbmRtYXJrTWFuYWdlcigpIHtcbiAgICByZXR1cm4gKDAsICRUdnNiVSR1c2VTeW5jRXh0ZXJuYWxTdG9yZSkoJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHN1YnNjcmliZSwgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlciwgJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJGdldExhbmRtYXJrTWFuYWdlcik7XG59XG5jbGFzcyAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkTGFuZG1hcmtNYW5hZ2VyIHtcbiAgICBzZXR1cElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpc3RlbmluZykgcmV0dXJuO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmY2SGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy5mb2N1c2luSGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuZm9jdXNvdXRIYW5kbGVyLCB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdGVhcmRvd25JZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGlzdGVuaW5nIHx8IHRoaXMubGFuZG1hcmtzLmxlbmd0aCA+IDAgfHwgdGhpcy5yZWZDb3VudCA+IDApIHJldHVybjtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5mNkhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbkhhbmRsZXIsIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLmZvY3Vzb3V0SGFuZGxlciwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBmb2N1c0xhbmRtYXJrKGxhbmRtYXJrLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX2xhbmRtYXJrc19maW5kLCBfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cztcbiAgICAgICAgKF90aGlzX2xhbmRtYXJrc19maW5kID0gdGhpcy5sYW5kbWFya3MuZmluZCgobCk9PmwucmVmLmN1cnJlbnQgPT09IGxhbmRtYXJrKSkgPT09IG51bGwgfHwgX3RoaXNfbGFuZG1hcmtzX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cyA9IF90aGlzX2xhbmRtYXJrc19maW5kLmZvY3VzKSA9PT0gbnVsbCB8fCBfdGhpc19sYW5kbWFya3NfZmluZF9mb2N1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGFuZG1hcmtzX2ZpbmRfZm9jdXMuY2FsbChfdGhpc19sYW5kbWFya3NfZmluZCwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybiBzZXQgb2YgbGFuZG1hcmtzIHdpdGggYSBzcGVjaWZpYyByb2xlLlxuICAgKi8gZ2V0TGFuZG1hcmtzQnlSb2xlKHJvbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5sYW5kbWFya3MuZmlsdGVyKChsKT0+bC5yb2xlID09PSByb2xlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgbGFuZG1hcmsgd2l0aCBhIHNwZWNpZmljIHJvbGUuXG4gICAqLyBnZXRMYW5kbWFya0J5Um9sZShyb2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmRtYXJrcy5maW5kKChsKT0+bC5yb2xlID09PSByb2xlKTtcbiAgICB9XG4gICAgYWRkTGFuZG1hcmsobmV3TGFuZG1hcmspIHtcbiAgICAgICAgdGhpcy5zZXR1cElmTmVlZGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5maW5kKChsYW5kbWFyayk9PmxhbmRtYXJrLnJlZiA9PT0gbmV3TGFuZG1hcmsucmVmKSB8fCAhbmV3TGFuZG1hcmsucmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubGFuZG1hcmtzLmZpbHRlcigobGFuZG1hcmspPT5sYW5kbWFyay5yb2xlID09PSBcIm1haW5cIikubGVuZ3RoID4gMSkgY29uc29sZS5lcnJvcignUGFnZSBjYW4gY29udGFpbiBubyBtb3JlIHRoYW4gb25lIGxhbmRtYXJrIHdpdGggdGhlIHJvbGUgXCJtYWluXCIuJyk7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFuZG1hcmtzID0gW1xuICAgICAgICAgICAgICAgIG5ld0xhbmRtYXJrXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5jaGVja0xhYmVscyhuZXdMYW5kbWFyay5yb2xlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5hcnkgc2VhcmNoIHRvIGluc2VydCBuZXcgbGFuZG1hcmsgYmFzZWQgb24gcG9zaXRpb24gaW4gZG9jdW1lbnQgcmVsYXRpdmUgdG8gZXhpc3RpbmcgbGFuZG1hcmtzLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5sYW5kbWFya3MubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUoc3RhcnQgPD0gZW5kKXtcbiAgICAgICAgICAgIGxldCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgICAgICAgIGxldCBjb21wYXJlZFBvc2l0aW9uID0gbmV3TGFuZG1hcmsucmVmLmN1cnJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5sYW5kbWFya3NbbWlkXS5yZWYuY3VycmVudCk7XG4gICAgICAgICAgICBsZXQgaXNOZXdBZnRlckV4aXN0aW5nID0gQm9vbGVhbihjb21wYXJlZFBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgfHwgY29tcGFyZWRQb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpO1xuICAgICAgICAgICAgaWYgKGlzTmV3QWZ0ZXJFeGlzdGluZykgc3RhcnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSBlbmQgPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFuZG1hcmtzLnNwbGljZShzdGFydCwgMCwgbmV3TGFuZG1hcmspO1xuICAgICAgICB0aGlzLmNoZWNrTGFiZWxzKG5ld0xhbmRtYXJrLnJvbGUpO1xuICAgIH1cbiAgICB1cGRhdGVMYW5kbWFyayhsYW5kbWFyaykge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxhbmRtYXJrcy5maW5kSW5kZXgoKGwpPT5sLnJlZiA9PT0gbGFuZG1hcmsucmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFuZG1hcmtzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmxhbmRtYXJrc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgLi4ubGFuZG1hcmtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNoZWNrTGFiZWxzKHRoaXMubGFuZG1hcmtzW2luZGV4XS5yb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVMYW5kbWFyayhyZWYpIHtcbiAgICAgICAgdGhpcy5sYW5kbWFya3MgPSB0aGlzLmxhbmRtYXJrcy5maWx0ZXIoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmICE9PSByZWYpO1xuICAgICAgICB0aGlzLnRlYXJkb3duSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUgYXJlIDIrIGxhbmRtYXJrcyB3aXRoIHRoZSBzYW1lIHJvbGUgYnV0IG5vIGxhYmVsLlxuICAgKiBMYWJlbHMgZm9yIGxhbmRtYXJrcyB3aXRoIHRoZSBzYW1lIHJvbGUgbXVzdCBhbHNvIGJlIHVuaXF1ZS5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcHJhY3RpY2VzL2xhbmRtYXJrLXJlZ2lvbnMvLlxuICAgKi8gY2hlY2tMYWJlbHMocm9sZSkge1xuICAgICAgICBsZXQgbGFuZG1hcmtzV2l0aFJvbGUgPSB0aGlzLmdldExhbmRtYXJrc0J5Um9sZShyb2xlKTtcbiAgICAgICAgaWYgKGxhbmRtYXJrc1dpdGhSb2xlLnNpemUgPiAxKSB7XG4gICAgICAgICAgICBsZXQgZHVwbGljYXRlc1dpdGhvdXRMYWJlbCA9IFtcbiAgICAgICAgICAgICAgICAuLi5sYW5kbWFya3NXaXRoUm9sZVxuICAgICAgICAgICAgXS5maWx0ZXIoKGxhbmRtYXJrKT0+IWxhbmRtYXJrLmxhYmVsKTtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVzV2l0aG91dExhYmVsLmxlbmd0aCA+IDApIGNvbnNvbGUud2FybihgUGFnZSBjb250YWlucyBtb3JlIHRoYW4gb25lIGxhbmRtYXJrIHdpdGggdGhlICcke3JvbGV9JyByb2xlLiBJZiB0d28gb3IgbW9yZSBsYW5kbWFya3Mgb24gYSBwYWdlIHNoYXJlIHRoZSBzYW1lIHJvbGUsIGFsbCBtdXN0IGJlIGxhYmVsZWQgd2l0aCBhbiBhcmlhLWxhYmVsIG9yIGFyaWEtbGFiZWxsZWRieSBhdHRyaWJ1dGU6IGAsIGR1cGxpY2F0ZXNXaXRob3V0TGFiZWwubWFwKChsYW5kbWFyayk9PmxhbmRtYXJrLnJlZi5jdXJyZW50KSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5sYW5kbWFya3NXaXRoUm9sZVxuICAgICAgICAgICAgICAgIF0ubWFwKChsYW5kbWFyayk9PmxhbmRtYXJrLmxhYmVsKTtcbiAgICAgICAgICAgICAgICBsZXQgZHVwbGljYXRlTGFiZWxzID0gbGFiZWxzLmZpbHRlcigoaXRlbSwgaW5kZXgpPT5sYWJlbHMuaW5kZXhPZihpdGVtKSAhPT0gaW5kZXgpO1xuICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUxhYmVscy5mb3JFYWNoKChsYWJlbCk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQYWdlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgbGFuZG1hcmsgd2l0aCB0aGUgJyR7cm9sZX0nIHJvbGUgYW5kICcke2xhYmVsfScgbGFiZWwuIElmIHR3byBvciBtb3JlIGxhbmRtYXJrcyBvbiBhIHBhZ2Ugc2hhcmUgdGhlIHNhbWUgcm9sZSwgdGhleSBtdXN0IGhhdmUgdW5pcXVlIGxhYmVsczogYCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGFuZG1hcmtzV2l0aFJvbGVcbiAgICAgICAgICAgICAgICAgICAgXS5maWx0ZXIoKGxhbmRtYXJrKT0+bGFuZG1hcmsubGFiZWwgPT09IGxhYmVsKS5tYXAoKGxhbmRtYXJrKT0+bGFuZG1hcmsucmVmLmN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBsYW5kbWFyayB0aGF0IGlzIHRoZSBjbG9zZXN0IHBhcmVudCBpbiB0aGUgRE9NLlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBwYXJlbnQgaXMgYSBsYW5kbWFyay5cbiAgICovIGNsb3Nlc3RMYW5kbWFyayhlbGVtZW50KSB7XG4gICAgICAgIGxldCBsYW5kbWFya01hcCA9IG5ldyBNYXAodGhpcy5sYW5kbWFya3MubWFwKChsKT0+W1xuICAgICAgICAgICAgICAgIGwucmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZShjdXJyZW50RWxlbWVudCAmJiAhbGFuZG1hcmtNYXAuaGFzKGN1cnJlbnRFbGVtZW50KSAmJiBjdXJyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KWN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhbmRtYXJrTWFwLmdldChjdXJyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IGxhbmRtYXJrLCBpbiBET00gZm9jdXMgb3JkZXIsIG9yIHByZXZpb3VzIGlmIGJhY2t3YXJkcyBpcyBzcGVjaWZpZWQuXG4gICAqIElmIGxhc3QgbGFuZG1hcmssIG5leHQgc2hvdWxkIGJlIHRoZSBmaXJzdCBsYW5kbWFyay5cbiAgICogSWYgbm90IGluc2lkZSBhIGxhbmRtYXJrLCB3aWxsIHJldHVybiBmaXJzdCBsYW5kbWFyay5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGxhbmRtYXJrcy5cbiAgICovIGdldE5leHRMYW5kbWFyayhlbGVtZW50LCB7IGJhY2t3YXJkOiBiYWNrd2FyZCAgfSkge1xuICAgICAgICB2YXIgX3RoaXNfbGFuZG1hcmtzX25leHRMYW5kbWFya0luZGV4X3JlZl9jdXJyZW50O1xuICAgICAgICBsZXQgY3VycmVudExhbmRtYXJrID0gdGhpcy5jbG9zZXN0TGFuZG1hcmsoZWxlbWVudCk7XG4gICAgICAgIGxldCBuZXh0TGFuZG1hcmtJbmRleCA9IGJhY2t3YXJkID8gdGhpcy5sYW5kbWFya3MubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIGlmIChjdXJyZW50TGFuZG1hcmspIG5leHRMYW5kbWFya0luZGV4ID0gdGhpcy5sYW5kbWFya3MuaW5kZXhPZihjdXJyZW50TGFuZG1hcmspICsgKGJhY2t3YXJkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IHdyYXBJZk5lZWRlZCA9ICgpPT57XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGxhbmRtYXJrIHNlcXVlbmNlLCBmaXJlIGEgY3VzdG9tIGV2ZW50IHRoYXQgY2FuIGJlIGxpc3RlbmVkIGZvciBieSBhcHBsaWNhdGlvbnMuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGV2ZW50IGlzIGNhbmNlbGVkLCB3ZSByZXR1cm4gaW1tZWRpYXRlbHkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGxhbmRtYXJrIG5hdmlnYXRpb24gYWNyb3NzIGlmcmFtZXMuXG4gICAgICAgICAgICBpZiAobmV4dExhbmRtYXJrSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicmVhY3QtYXJpYS1sYW5kbWFyay1uYXZpZ2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiYmFja3dhcmRcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXh0TGFuZG1hcmtJbmRleCA9IHRoaXMubGFuZG1hcmtzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRMYW5kbWFya0luZGV4ID49IHRoaXMubGFuZG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInJlYWN0LWFyaWEtbGFuZG1hcmstbmF2aWdhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcImZvcndhcmRcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXh0TGFuZG1hcmtJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dExhbmRtYXJrSW5kZXggPCAwIHx8IG5leHRMYW5kbWFya0luZGV4ID49IHRoaXMubGFuZG1hcmtzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh3cmFwSWZOZWVkZWQoKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gU2tpcCBvdmVyIGhpZGRlbiBsYW5kbWFya3MuXG4gICAgICAgIGxldCBpID0gbmV4dExhbmRtYXJrSW5kZXg7XG4gICAgICAgIHdoaWxlKChfdGhpc19sYW5kbWFya3NfbmV4dExhbmRtYXJrSW5kZXhfcmVmX2N1cnJlbnQgPSB0aGlzLmxhbmRtYXJrc1tuZXh0TGFuZG1hcmtJbmRleF0ucmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF90aGlzX2xhbmRtYXJrc19uZXh0TGFuZG1hcmtJbmRleF9yZWZfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfbGFuZG1hcmtzX25leHRMYW5kbWFya0luZGV4X3JlZl9jdXJyZW50LmNsb3Nlc3QoXCJbYXJpYS1oaWRkZW49dHJ1ZV1cIikpe1xuICAgICAgICAgICAgbmV4dExhbmRtYXJrSW5kZXggKz0gYmFja3dhcmQgPyAtMSA6IDE7XG4gICAgICAgICAgICBpZiAod3JhcElmTmVlZGVkKCkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobmV4dExhbmRtYXJrSW5kZXggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmRtYXJrc1tuZXh0TGFuZG1hcmtJbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgKiBMb29rIGF0IG5leHQgbGFuZG1hcmsuIElmIGFuIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZm9jdXNlZCBpbnNpZGUsIHJlc3RvcmUgZm9jdXMgdGhlcmUuXG4gICAqIElmIG5vdCwgZm9jdXMgdGhlIGxhbmRtYXJrIGl0c2VsZi5cbiAgICogSWYgbm8gbGFuZG1hcmtzIGF0IGFsbCwgb3Igbm9uZSB3aXRoIGZvY3VzYWJsZSBlbGVtZW50cywgZG9uJ3QgbW92ZSBmb2N1cy5cbiAgICovIGY2SGFuZGxlcihlKSB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gXCJGNlwiKSB7XG4gICAgICAgICAgICAvLyBJZiBhbHQga2V5IHByZXNzZWQsIGZvY3VzIG1haW4gbGFuZG1hcmssIG90aGVyd2lzZSBuYXZpZ2F0ZSBmb3J3YXJkIG9yIGJhY2t3YXJkIGJhc2VkIG9uIHNoaWZ0IGtleS5cbiAgICAgICAgICAgIGxldCBoYW5kbGVkID0gZS5hbHRLZXkgPyB0aGlzLmZvY3VzTWFpbigpIDogdGhpcy5uYXZpZ2F0ZShlLnRhcmdldCwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzTWFpbigpIHtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLmdldExhbmRtYXJrQnlSb2xlKFwibWFpblwiKTtcbiAgICAgICAgaWYgKG1haW4gJiYgbWFpbi5yZWYuY3VycmVudCAmJiBkb2N1bWVudC5jb250YWlucyhtYWluLnJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0xhbmRtYXJrKG1haW4ucmVmLmN1cnJlbnQsIFwiZm9yd2FyZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmF2aWdhdGUoZnJvbSwgYmFja3dhcmQpIHtcbiAgICAgICAgbGV0IG5leHRMYW5kbWFyayA9IHRoaXMuZ2V0TmV4dExhbmRtYXJrKGZyb20sIHtcbiAgICAgICAgICAgIGJhY2t3YXJkOiBiYWNrd2FyZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFuZXh0TGFuZG1hcmspIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBwcmV2aW91c2x5IGZvY3VzZWQgaW4gdGhlIG5leHQgbGFuZG1hcmssIHRoZW4gcmV0dXJuIGZvY3VzIHRvIGl0XG4gICAgICAgIGlmIChuZXh0TGFuZG1hcmsubGFzdEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0Rm9jdXNlZCA9IG5leHRMYW5kbWFyay5sYXN0Rm9jdXNlZDtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGxhc3RGb2N1c2VkKSkge1xuICAgICAgICAgICAgICAgIGxhc3RGb2N1c2VkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBmb2N1cyB0aGUgbGFuZG1hcmsgaXRzZWxmXG4gICAgICAgIGlmIChuZXh0TGFuZG1hcmsucmVmLmN1cnJlbnQgJiYgZG9jdW1lbnQuY29udGFpbnMobmV4dExhbmRtYXJrLnJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0xhbmRtYXJrKG5leHRMYW5kbWFyay5yZWYuY3VycmVudCwgYmFja3dhcmQgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIGxhc3RGb2N1c2VkIGZvciBhIGxhbmRtYXJrLCBpZiBmb2N1cyBpcyBtb3ZlZCB3aXRoaW4gdGhhdCBsYW5kbWFyay5cbiAgICogTGV0cyB0aGUgbGFzdCBmb2N1c2VkIGxhbmRtYXJrIGtub3cgaXQgd2FzIGJsdXJyZWQgaWYgc29tZXRoaW5nIGVsc2UgaXMgZm9jdXNlZC5cbiAgICovIGZvY3VzaW5IYW5kbGVyKGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRMYW5kbWFyayA9IHRoaXMuY2xvc2VzdExhbmRtYXJrKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKGN1cnJlbnRMYW5kbWFyayAmJiBjdXJyZW50TGFuZG1hcmsucmVmLmN1cnJlbnQgIT09IGUudGFyZ2V0KSB0aGlzLnVwZGF0ZUxhbmRtYXJrKHtcbiAgICAgICAgICAgIHJlZjogY3VycmVudExhbmRtYXJrLnJlZixcbiAgICAgICAgICAgIGxhc3RGb2N1c2VkOiBlLnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHByZXZpb3VzRm9jdXNlZEVsZW1lbnQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIGlmIChwcmV2aW91c0ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsgPSB0aGlzLmNsb3Nlc3RMYW5kbWFyayhwcmV2aW91c0ZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UHJldmlvdXNMYW5kbWFyayAmJiBjbG9zZXN0UHJldmlvdXNMYW5kbWFyay5yZWYuY3VycmVudCA9PT0gcHJldmlvdXNGb2N1c2VkRWxlbWVudCkgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBUcmFjayBpZiB0aGUgZm9jdXMgaXMgbG9zdCB0byB0aGUgYm9keS4gSWYgaXQgaXMsIGRvIGNsZWFudXAgb24gdGhlIGxhbmRtYXJrIHRoYXQgbGFzdCBoYWQgZm9jdXMuXG4gICAqLyBmb2N1c291dEhhbmRsZXIoZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0O1xuICAgICAgICBsZXQgbmV4dEZvY3VzZWRFbGVtZW50ID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAvLyB0aGUgPT09IGRvY3VtZW50IHNlZW1zIHRvIGJlIGEgamVzdCB0aGluZyBmb3IgZm9jdXMgdG8gZ28gdGhlcmUgb24gZ2VuZXJpYyBibHVyIGV2ZW50IHN1Y2ggYXMgbGFuZG1hcmsuYmx1cigpO1xuICAgICAgICAvLyBicm93c2VycyBhcHBlYXIgdG8gc2VuZCBmb2N1cyBpbnN0ZWFkIHRvIGRvY3VtZW50LmJvZHkgYW5kIHRoZSByZWxhdGVkVGFyZ2V0IGlzIG51bGwgd2hlbiB0aGF0IGhhcHBlbnNcbiAgICAgICAgaWYgKCFuZXh0Rm9jdXNlZEVsZW1lbnQgfHwgbmV4dEZvY3VzZWRFbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgbGV0IGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrID0gdGhpcy5jbG9zZXN0TGFuZG1hcmsocHJldmlvdXNGb2N1c2VkRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsgJiYgY2xvc2VzdFByZXZpb3VzTGFuZG1hcmsucmVmLmN1cnJlbnQgPT09IHByZXZpb3VzRm9jdXNlZEVsZW1lbnQpIGNsb3Nlc3RQcmV2aW91c0xhbmRtYXJrLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVMYW5kbWFya0NvbnRyb2xsZXIoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIGluc3RhbmNlLnJlZkNvdW50Kys7XG4gICAgICAgIGluc3RhbmNlLnNldHVwSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmlnYXRlIChkaXJlY3Rpb24sIG9wdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UubmF2aWdhdGUoZWxlbWVudCwgZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzTmV4dCAob3B0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5uYXZpZ2F0ZShlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mcm9tKSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5uYXZpZ2F0ZShlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1c01haW4gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5mb2N1c01haW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVmQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudGVhcmRvd25JZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlckxhbmRtYXJrKGxhbmRtYXJrKSB7XG4gICAgICAgIGlmICh0aGlzLmxhbmRtYXJrcy5maW5kKChsKT0+bC5yZWYgPT09IGxhbmRtYXJrLnJlZikpIHRoaXMudXBkYXRlTGFuZG1hcmsobGFuZG1hcmspO1xuICAgICAgICBlbHNlIHRoaXMuYWRkTGFuZG1hcmsobGFuZG1hcmspO1xuICAgICAgICByZXR1cm4gKCk9PnRoaXMucmVtb3ZlTGFuZG1hcmsobGFuZG1hcmsucmVmKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sYW5kbWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5pc0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJExBTkRNQVJLX0FQSV9WRVJTSU9OO1xuICAgICAgICB0aGlzLmY2SGFuZGxlciA9IHRoaXMuZjZIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZm9jdXNpbkhhbmRsZXIgPSB0aGlzLmZvY3VzaW5IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZm9jdXNvdXRIYW5kbGVyID0gdGhpcy5mb2N1c291dEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkZjUwMTUxZGJkNTFjZDFkOSgpIHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbGFuZG1hcmsgbWFuYWdlciBhbmQgY3JlYXRlIGEgY29udHJvbGxlciB1c2luZyBpdC5cbiAgICBsZXQgaW5zdGFuY2UgPSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkZ2V0TGFuZG1hcmtNYW5hZ2VyKCk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UuY3JlYXRlTGFuZG1hcmtDb250cm9sbGVyKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlID0gJGE4NjIwN2M1ZDdmN2UxZmIkdmFyJHN1YnNjcmliZSgoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgbGFuZG1hcmsgbWFuYWdlciBjaGFuZ2VzLCBkaXNwb3NlIHRoZSBvbGRcbiAgICAgICAgLy8gY29udHJvbGxlciBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgY29udHJvbGxlciA9PT0gbnVsbCB8fCBjb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaW5zdGFuY2UgPSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkZ2V0TGFuZG1hcmtNYW5hZ2VyKCk7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UuY3JlYXRlTGFuZG1hcmtDb250cm9sbGVyKCk7XG4gICAgfSk7XG4gICAgLy8gUmV0dXJuIGEgd3JhcHBlciB0aGF0IHByb3hpZXMgcmVxdWVzdHMgdG8gdGhlIGN1cnJlbnQgY29udHJvbGxlciBpbnN0YW5jZS5cbiAgICByZXR1cm4ge1xuICAgICAgICBuYXZpZ2F0ZSAoZGlyZWN0aW9uLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5uYXZpZ2F0ZShkaXJlY3Rpb24sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c05leHQgKG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmZvY3VzTmV4dChvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZm9jdXNQcmV2aW91cyhvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNNYWluICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmZvY3VzTWFpbigpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgfHwgY29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkNGNjNjMyNTg0ZmQ4N2ZhZShwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyByb2xlOiByb2xlICwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCAsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5ICwgZm9jdXM6IGZvY3VzICB9ID0gcHJvcHM7XG4gICAgbGV0IG1hbmFnZXIgPSAkYTg2MjA3YzVkN2Y3ZTFmYiR2YXIkdXNlTGFuZG1hcmtNYW5hZ2VyKCk7XG4gICAgbGV0IGxhYmVsID0gYXJpYUxhYmVsIHx8IGFyaWFMYWJlbGxlZGJ5O1xuICAgIGxldCBbaXNMYW5kbWFya0ZvY3VzZWQsIHNldElzTGFuZG1hcmtGb2N1c2VkXSA9ICgwLCAkVHZzYlUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgZGVmYXVsdEZvY3VzID0gKDAsICRUdnNiVSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0SXNMYW5kbWFya0ZvY3VzZWQodHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRJc0xhbmRtYXJrRm9jdXNlZFxuICAgIF0pO1xuICAgIGxldCBibHVyID0gKDAsICRUdnNiVSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0SXNMYW5kbWFya0ZvY3VzZWQoZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0SXNMYW5kbWFya0ZvY3VzZWRcbiAgICBdKTtcbiAgICAoMCwgJFR2c2JVJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKG1hbmFnZXIpIHJldHVybiBtYW5hZ2VyLnJlZ2lzdGVyTGFuZG1hcmsoe1xuICAgICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICByb2xlOiByb2xlLFxuICAgICAgICAgICAgZm9jdXM6IGZvY3VzIHx8IGRlZmF1bHRGb2N1cyxcbiAgICAgICAgICAgIGJsdXI6IGJsdXJcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBtYW5hZ2VyLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcmVmLFxuICAgICAgICByb2xlLFxuICAgICAgICBmb2N1cyxcbiAgICAgICAgZGVmYXVsdEZvY3VzLFxuICAgICAgICBibHVyXG4gICAgXSk7XG4gICAgKDAsICRUdnNiVSR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHZhciBfcmVmX2N1cnJlbnQ7XG4gICAgICAgIGlmIChpc0xhbmRtYXJrRm9jdXNlZCkgKF9yZWZfY3VycmVudCA9IHJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVmX2N1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWZfY3VycmVudC5mb2N1cygpO1xuICAgIH0sIFtcbiAgICAgICAgaXNMYW5kbWFya0ZvY3VzZWQsXG4gICAgICAgIHJlZlxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhbmRtYXJrUHJvcHM6IHtcbiAgICAgICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgICAgICB0YWJJbmRleDogaXNMYW5kbWFya0ZvY3VzZWQgPyAtMSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTg2MjA3YzVkN2Y3ZTFmYiRleHBvcnQkNGNjNjMyNTg0ZmQ4N2ZhZSBhcyB1c2VMYW5kbWFyaywgJGE4NjIwN2M1ZDdmN2UxZmIkZXhwb3J0JGY1MDE1MWRiZDUxY2QxZDkgYXMgY3JlYXRlTGFuZG1hcmtDb250cm9sbGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-aria+landmark@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/landmark/dist/import.mjs\n");

/***/ })

};
;